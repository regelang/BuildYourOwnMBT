/// ================================================================================
/// # ğŸ¯ å—è¡¨è¾¾å¼çš„ KNF å˜æ¢ï¼šè¯­å¥åºåˆ—çš„å¤„ç†
///
/// åœ¨å®Œæˆäº†è¯­å¥çš„ç»Ÿä¸€åˆ†å‘ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨è¦å¤„ç†**å—è¡¨è¾¾å¼ (Block Expression)** çš„è½¬æ¢ã€‚
/// è¿™æ˜¯ KNF å˜æ¢ä¸­çš„ä¸€ä¸ªé‡è¦ç»„ä»¶ï¼Œå› ä¸ºå®ƒå¤„ç†è¯­å¥åºåˆ—å’Œä»£ç å—çš„ç»“æ„ã€‚
///
/// ## ğŸŒŸ ä»€ä¹ˆæ˜¯å—è¡¨è¾¾å¼ï¼Ÿ
///
/// **å—è¡¨è¾¾å¼**æ˜¯ç”±èŠ±æ‹¬å·åŒ…å›´çš„è¯­å¥åºåˆ—ï¼Œå®ƒä»¬çš„å½¢å¼æ˜¯ï¼š
///
/// ```
/// {
///   let x: Int = 10;
///   let mut y: Double = 3.14;
///   z = 42;
///   print_int(z);
///   return z;
/// }
/// ```
///
/// **å—è¡¨è¾¾å¼çš„ç‰¹ç‚¹**ï¼š
/// - **è¯­å¥åºåˆ—**ï¼šåŒ…å«å¤šä¸ªè¯­å¥ï¼ŒæŒ‰é¡ºåºæ‰§è¡Œ
/// - **ä½œç”¨åŸŸ**ï¼šåˆ›å»ºæ–°çš„ä½œç”¨åŸŸï¼Œå˜é‡åœ¨å…¶ä¸­æœ‰æ•ˆ
/// - **è¿”å›å€¼**ï¼šæœ€åä¸€ä¸ªè¯­å¥çš„å€¼ä½œä¸ºå—è¡¨è¾¾å¼çš„å€¼
/// - **å‰¯ä½œç”¨**ï¼šè¯­å¥å¯èƒ½äº§ç”Ÿå‰¯ä½œç”¨ï¼ˆèµ‹å€¼ã€å‡½æ•°è°ƒç”¨ç­‰ï¼‰
///
/// ## ğŸ” å—è¡¨è¾¾å¼çš„å¤„ç†ç­–ç•¥
///
/// å—è¡¨è¾¾å¼çš„è½¬æ¢ç›¸å¯¹ç®€å•ï¼Œä¸»è¦é‡‡ç”¨**å¾ªç¯éå†**çš„ç­–ç•¥ï¼š
///
/// ### æ ¸å¿ƒæ€æƒ³ï¼šé¡ºåºå¤„ç†
///
/// å¯¹äºå—è¡¨è¾¾å¼ä¸­çš„æ¯ä¸ªè¯­å¥ï¼š
/// 1. **é¡ºåºå¤„ç†**ï¼šæŒ‰ç…§è¯­å¥åœ¨ä»£ç ä¸­çš„é¡ºåºä¾æ¬¡å¤„ç†
/// 2. **è¯­å¥è½¬æ¢**ï¼šä½¿ç”¨ `stmt_to_knf` å°†æ¯ä¸ªè¯­å¥è½¬æ¢ä¸º KNF å½¢å¼
/// 3. **ç»“æœåˆå¹¶**ï¼šå°†æ‰€æœ‰è¯­å¥çš„ KNF ç»“æœåˆå¹¶åˆ°ä¸€ä¸ªè¯­å¥åˆ—è¡¨ä¸­
/// 4. **å—æ„é€ **ï¼šç”¨åˆå¹¶åçš„è¯­å¥åˆ—è¡¨æ„é€  `KnfBlock`
///
/// ### å¤„ç†æµç¨‹
///
/// ```
/// {
///   stmt1;  // -> knf_stmts1
///   stmt2;  // -> knf_stmts2
///   stmt3;  // -> knf_stmts3
/// }
/// ```
///
/// **è½¬æ¢è¿‡ç¨‹**ï¼š
/// 1. å¤„ç† `stmt1`ï¼Œå¾—åˆ° `knf_stmts1`
/// 2. å¤„ç† `stmt2`ï¼Œå¾—åˆ° `knf_stmts2`
/// 3. å¤„ç† `stmt3`ï¼Œå¾—åˆ° `knf_stmts3`
/// 4. åˆå¹¶æ‰€æœ‰è¯­å¥ï¼š`[knf_stmts1, knf_stmts2, knf_stmts3]`
/// 5. æ„é€  `KnfBlock`
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `block_expr_to_knf` å‡½æ•°
///
/// åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œä½ éœ€è¦å®ç° `Context::block_expr_to_knf` å‡½æ•°ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// å—è¡¨è¾¾å¼çš„è½¬æ¢é‡‡ç”¨**å¾ªç¯éå†**çš„ç­–ç•¥ï¼š
///
/// 1. **åˆå§‹åŒ–**ï¼šåˆ›å»ºç©ºçš„è¯­å¥åˆ—è¡¨
/// 2. **å¾ªç¯å¤„ç†**ï¼šéå†å—è¡¨è¾¾å¼ä¸­çš„æ¯ä¸ªè¯­å¥
/// 3. **è¯­å¥è½¬æ¢**ï¼šå¯¹æ¯ä¸ªè¯­å¥è°ƒç”¨ `stmt_to_knf`
/// 4. **ç»“æœåˆå¹¶**ï¼šå°†è½¬æ¢ç»“æœåˆå¹¶åˆ°è¯­å¥åˆ—è¡¨ä¸­
/// 5. **å—æ„é€ **ï¼šç”¨åˆå¹¶åçš„è¯­å¥åˆ—è¡¨æ„é€  `KnfBlock`
///
/// ### ğŸ”§ å…³é”®å®ç°ç»†èŠ‚
///
/// #### å¾ªç¯éå†çš„å®ç°
/// ```
/// for stmt in expr.stmts {
///   let knf_stmts = self.stmt_to_knf(stmt)
///   stmts.append(knf_stmts)
/// }
/// ```
///
/// **å…³é”®ç‚¹**ï¼š
/// - ä½¿ç”¨ `for` å¾ªç¯éå†è¯­å¥åˆ—è¡¨
/// - å¯¹æ¯ä¸ªè¯­å¥è°ƒç”¨ `stmt_to_knf`
/// - ä½¿ç”¨ `append` åˆå¹¶è¯­å¥åˆ—è¡¨
/// - ä¿æŒè¯­å¥çš„åŸå§‹é¡ºåº
///
/// #### KnfBlock çš„æ„é€ 
/// ```
/// KnfBlock::{ stmts }
/// ```
///
/// **å…³é”®ç‚¹**ï¼š
/// - `KnfBlock` åªåŒ…å«è¯­å¥åˆ—è¡¨
/// - ä¸éœ€è¦é¢å¤–çš„ç±»å‹ä¿¡æ¯
/// - è¯­å¥çš„é¡ºåºå¾ˆé‡è¦
///
/// ## ğŸš€ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// è¿™ä¸ªæµ‹è¯•æ–‡ä»¶åŒ…å«äº†ä¸€ä¸ªå¤æ‚çš„å—è¡¨è¾¾å¼è½¬æ¢ï¼š
///
/// ### æµ‹è¯•å—è¡¨è¾¾å¼ï¼š
/// ```
/// {
///   let x: Int = 10;        // LetStmt
///   let mut y: Double = 3.14;  // LetMutStmt
///   let mut z: Int = 0;    // LetMutStmt
///   z = 42;                // AssignStmt
///   print_int(z);          // ExprStmt
///   return z;              // ReturnStmt
/// }
/// ```
///
/// ### è½¬æ¢ç»“æœåˆ†æï¼š
///
/// **è¯­å¥ 1**ï¼š`let x: Int = 10;`
/// - è½¬æ¢ç»“æœï¼š`Let(x, Int, Int(10))`
/// - ç‰¹ç‚¹ï¼šç®€å•çš„ Let è¯­å¥
///
/// **è¯­å¥ 2**ï¼š`let mut y: Double = 3.14;`
/// - è½¬æ¢ç»“æœï¼š`LetMut(y, Double, Double(3.14))`
/// - ç‰¹ç‚¹ï¼šLet Mut è¯­å¥
///
/// **è¯­å¥ 3**ï¼š`let mut z: Int = 0;`
/// - è½¬æ¢ç»“æœï¼š`LetMut(z, Int, Int(0))`
/// - ç‰¹ç‚¹ï¼šLet Mut è¯­å¥
///
/// **è¯­å¥ 4**ï¼š`z = 42;`
/// - è½¬æ¢ç»“æœï¼š`Assign(z, Int(42))`
/// - ç‰¹ç‚¹ï¼šç®€å•çš„èµ‹å€¼è¯­å¥
///
/// **è¯­å¥ 5**ï¼š`print_int(z);`
/// - è½¬æ¢ç»“æœï¼š`ExprStmt(Call(print_int, [z]))`
/// - ç‰¹ç‚¹ï¼šè¡¨è¾¾å¼è¯­å¥ï¼Œå‡½æ•°è°ƒç”¨
///
/// **è¯­å¥ 6**ï¼š`return z;`
/// - è½¬æ¢ç»“æœï¼š`Return(Ident(z))`
/// - ç‰¹ç‚¹ï¼šè¿”å›è¯­å¥
///
/// ## ğŸ’¡ å®ç°æç¤º
///
/// 1. **å¾ªç¯éå†**ï¼šä½¿ç”¨ `for` å¾ªç¯éå†è¯­å¥åˆ—è¡¨
/// 2. **è¯­å¥è½¬æ¢**ï¼šå¯¹æ¯ä¸ªè¯­å¥è°ƒç”¨ `stmt_to_knf`
/// 3. **ç»“æœåˆå¹¶**ï¼šä½¿ç”¨ `append` åˆå¹¶è¯­å¥åˆ—è¡¨
/// 4. **é¡ºåºä¿æŒ**ï¼šç¡®ä¿è¯­å¥æŒ‰åŸå§‹é¡ºåºå¤„ç†
/// 5. **å—æ„é€ **ï¼šç”¨åˆå¹¶åçš„è¯­å¥åˆ—è¡¨æ„é€  `KnfBlock`
///
/// ## ğŸ”® è®¾è®¡æ€æƒ³
///
/// å—è¡¨è¾¾å¼çš„å¤„ç†ä½“ç°äº†ä»¥ä¸‹è®¾è®¡æ€æƒ³ï¼š
///
/// - **é¡ºåºæ€§**ï¼šè¯­å¥æŒ‰é¡ºåºæ‰§è¡Œï¼Œä¿æŒåŸå§‹é¡ºåº
/// - **ç»„åˆæ€§**ï¼šå°†å¤šä¸ªè¯­å¥ç»„åˆæˆä¸€ä¸ªå—
/// - **å§”æ‰˜æ€§**ï¼šå°†å…·ä½“è¯­å¥çš„å¤„ç†å§”æ‰˜ç»™ `stmt_to_knf`
/// - **ç®€å•æ€§**ï¼šå¤„ç†é€»è¾‘ç›¸å¯¹ç®€å•ï¼Œä¸»è¦æ˜¯å¾ªç¯å’Œåˆå¹¶
///
/// ## ğŸ¯ å¼€å§‹å®ç°å§ï¼
///
/// è¿™æ˜¯å—è¡¨è¾¾å¼å¤„ç†çš„é˜¶æ®µï¼é€šè¿‡å®ç° `block_expr_to_knf` å‡½æ•°ï¼Œ
/// æˆ‘ä»¬å°†å®Œæˆè¯­å¥åºåˆ—çš„å¤„ç†ï¼Œä¸ºåç»­æ›´å¤æ‚çš„æ§åˆ¶æµå¤„ç†å¥ å®šåŸºç¡€ã€‚
///
/// **å‡†å¤‡å¥½å¤„ç†è¯­å¥åºåˆ—äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å®ç°ï¼**
/// ================================================================================

///|
test "Block Expr Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup type environment for testing
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })

  // For return statement
  typecheck_ctx.current_func_ret_ty = Some(Int)

  // Setup knf context
  knf_ctx.globals.set("print_int", Function([Int], Unit))

  // Test Parts
  let code =
    #|{
    #|  let x: Int = 10;
    #|  let mut y: Double = 3.14;
    #|  let mut z : Int = 0;
    #|  z = 42;
    #|  print_int(z);
    #|  return z;
    #|}

  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)
  let (stmt, _) = @parser.parse_block_expr(tokens)
  let checked_block = typecheck_ctx.check_block_expr(stmt)
  let knf_block = knf_ctx.block_expr_to_knf(checked_block)
  assert_true(knf_block.stmts.length() is 6)

  // Test 1: Parse and transform `let x: Int = 10;`
  assert_true(
    knf_block.stmts[0] is Let(name1, Int, init_expr) &&
    name1 is { id: "x", .. } &&
    init_expr is Int(10),
  )

  // Test 2: Parse and transform `let mut y: Double = 3.14;`
  assert_true(
    knf_block.stmts[1] is LetMut(name2, Double, init_expr2) &&
    name2 is { id: "y", .. } &&
    init_expr2 is Double(3.14),
  )

  // Test 3: Parse and transform `let mut z : Int = 0;`
  assert_true(
    knf_block.stmts[2] is LetMut(name3, Int, init_expr3) &&
    name3 is { id: "z", .. } &&
    init_expr3 is Int(0),
  )

  // Test 4: Parse and transform `z = 42;`
  assert_true(
    knf_block.stmts[3] is Assign(name3, expr3) &&
    name3 is { id: "z", .. } &&
    expr3 is Int(42),
  )

  // Test 4: Parse and transform `print_int(z);` (ExprStmt)
  assert_true(
    knf_block.stmts[4] is ExprStmt(call_expr) &&
    call_expr is Call(func, args) &&
    func is { id: "print_int", .. } &&
    args is [arg] &&
    arg is { id: "z", .. },
  )

  // Test 5: Parse and transform `return z;` (ReturnStmt)
  assert_true(
    knf_block.stmts[5] is Return(return_expr) &&
    return_expr is Ident({ id: "z", .. }),
  )
}
