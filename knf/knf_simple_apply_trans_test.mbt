/// ================================================================================
/// # ğŸ¯ ç®€å•åº”ç”¨è¡¨è¾¾å¼çš„ KNF å˜æ¢ï¼šä»åŸå­åˆ°åº”ç”¨
///
/// åœ¨å®Œæˆäº†åŸå­è¡¨è¾¾å¼çš„è½¬æ¢ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨è¦å¤„ç†**åº”ç”¨è¡¨è¾¾å¼ (Apply Expression)**ã€‚
/// åº”ç”¨è¡¨è¾¾å¼æ˜¯æ¯”åŸå­è¡¨è¾¾å¼æ›´å¤æ‚ä¸€å±‚çš„è¡¨è¾¾å¼ï¼Œå®ƒä»¬åŒ…å«äº†å‡½æ•°è°ƒç”¨ã€æ•°ç»„è®¿é—®ã€å­—æ®µè®¿é—®ç­‰æ“ä½œã€‚
///
/// ## ğŸŒŸ ä»€ä¹ˆæ˜¯åº”ç”¨è¡¨è¾¾å¼ï¼Ÿ
///
/// **åº”ç”¨è¡¨è¾¾å¼**æ˜¯èƒ½å¤Ÿè¢«"åº”ç”¨"æˆ–"è°ƒç”¨"çš„è¡¨è¾¾å¼ï¼Œå®ƒä»¬åŒ…æ‹¬ï¼š
///
/// - **åŸå­è¡¨è¾¾å¼**ï¼š`42`ã€`x`ã€`"hello"`ï¼ˆä½œä¸ºåº”ç”¨è¡¨è¾¾å¼çš„åŸºç¡€ï¼‰
/// - **æ•°ç»„è®¿é—®**ï¼š`arr[0]`ã€`matrix[i][j]`
/// - **å­—æ®µè®¿é—®**ï¼š`point.x`ã€`person.name`
/// - **å‡½æ•°è°ƒç”¨**ï¼š`f(x)`ã€`add(a, b)`ã€`obj.method(args)`
///
/// åœ¨ç¼–è¯‘å™¨çš„è¯­æ³•åˆ†æä¸­ï¼Œåº”ç”¨è¡¨è¾¾å¼å…·æœ‰**å·¦ç»“åˆæ€§**å’Œ**é«˜ä¼˜å…ˆçº§**ï¼Œ
/// è¿™æ„å‘³ç€åƒ `f(x)[0].field` è¿™æ ·çš„è¡¨è¾¾å¼ä¼šè¢«æ­£ç¡®è§£æä¸º `((f(x))[0]).field`ã€‚
///
/// ## ğŸ” ApplyExpr çš„ç»“æ„å±‚æ¬¡
///
/// åº”ç”¨è¡¨è¾¾å¼é‡‡ç”¨äº†ä¸€ç§**é€’å½’çš„ç»“æ„è®¾è®¡**ï¼š
///
/// ```moonbit
/// enum ApplyExprKind {
///   AtomExpr(AtomExpr)                    // åŸºç¡€ï¼šåŸå­è¡¨è¾¾å¼
///   ArrayAccess(ApplyExpr, Expr)         // æ•°ç»„è®¿é—®ï¼šarr[index]
///   FieldAccess(ApplyExpr, String)       // å­—æ®µè®¿é—®ï¼šobj.field
///   Call(ApplyExpr, Array[Expr])         // å‡½æ•°è°ƒç”¨ï¼šfunc(args...)
/// }
/// ```
///
/// **å…³é”®è§‚å¯Ÿ**ï¼šé™¤äº† `AtomExpr` ä¹‹å¤–ï¼Œå…¶ä»–æ‰€æœ‰ç±»å‹éƒ½åŒ…å«ä¸€ä¸ª `ApplyExpr` ä½œä¸º"åŸºç¡€"ï¼Œ
/// è¿™å½¢æˆäº†ä¸€ä¸ªé€’å½’çš„ç»“æ„ï¼Œä½¿å¾—å¤æ‚çš„è¡¨è¾¾å¼å¯ä»¥å±‚å±‚åµŒå¥—ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `apply_expr_to_knf` å‡½æ•°
///
/// åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œä½ éœ€è¦å®ç° `Context::apply_expr_to_knf` å‡½æ•°ã€‚
/// å¥½æ¶ˆæ¯æ˜¯ï¼Œå¯¹äº**ç®€å•çš„åº”ç”¨è¡¨è¾¾å¼**ï¼ˆåªåŒ…å«åŸå­è¡¨è¾¾å¼ï¼‰ï¼Œå®ç°éå¸¸ç®€å•ï¼
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// ç”±äºè¿™ä¸ªæµ‹è¯•åªæ¶‰åŠç®€å•çš„åº”ç”¨è¡¨è¾¾å¼ï¼Œä½ éœ€è¦å¤„ç†çš„æ¨¡å¼åŒ¹é…éå¸¸ç®€å•ï¼š
///
/// ```moonbit
/// match apply_expr.kind {
///   AtomExpr(atom_expr) => self.atom_expr_to_knf(atom_expr)
///   // å…¶ä»–å¤æ‚æƒ…å†µæš‚æ—¶ä¸éœ€è¦å¤„ç†
/// }
/// ```
///
/// **å°±è¿™ä¹ˆç®€å•ï¼** å½“åº”ç”¨è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªåŸå­è¡¨è¾¾å¼æ—¶ï¼Œç›´æ¥è°ƒç”¨ `atom_expr_to_knf` å³å¯ã€‚
///
/// ### ğŸ”„ é€’å½’è®¾è®¡çš„ä¼˜åŠ¿
///
/// è¿™ç§é€’å½’è®¾è®¡çš„å¥½å¤„æ˜¯ï¼š
/// - **ç®€å•æƒ…å†µ**ï¼šåŸå­è¡¨è¾¾å¼ç›´æ¥å¤„ç†
/// - **å¤æ‚æƒ…å†µ**ï¼šé€šè¿‡é€’å½’è°ƒç”¨å¤„ç†åµŒå¥—ç»“æ„
/// - **æ‰©å±•æ€§**ï¼šå¯ä»¥è½»æ¾æ·»åŠ æ–°çš„åº”ç”¨è¡¨è¾¾å¼ç±»å‹
///
/// ## ğŸš€ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// è¿™ä¸ªæµ‹è¯•æ–‡ä»¶ä¸“é—¨æµ‹è¯•**ç®€å•çš„åº”ç”¨è¡¨è¾¾å¼**ï¼Œå³åªåŒ…å«åŸå­è¡¨è¾¾å¼çš„åº”ç”¨è¡¨è¾¾å¼ï¼š
///
/// 1. **å­—é¢é‡**ï¼š`42`ã€`3.14`ã€`true`ã€`"hello"`
/// 2. **æ ‡è¯†ç¬¦**ï¼š`x`ã€`y`ã€`z`
///
/// æ‰€æœ‰è¿™äº›è¡¨è¾¾å¼åœ¨ `ApplyExpr` ä¸­éƒ½è¢«åŒ…è£…ä¸º `AtomExpr(atom_expr)`ï¼Œ
/// æ‰€ä»¥è½¬æ¢è¿‡ç¨‹å°±æ˜¯ç®€å•åœ°è°ƒç”¨ `atom_expr_to_knf`ã€‚
///
/// ## ğŸ› ï¸ ä¸Šä¸‹æ–‡ç®¡ç†
///
/// ç”±äºæˆ‘ä»¬åªæ˜¯ç®€å•åœ°å§”æ‰˜ç»™ `atom_expr_to_knf`ï¼Œä¸Šä¸‹æ–‡ç®¡ç†å®Œå…¨ç”±è¯¥å‡½æ•°å¤„ç†ï¼š
///
/// - **å˜é‡æŸ¥æ‰¾**ï¼šé€šè¿‡ `lookup_name` æŸ¥æ‰¾å˜é‡
/// - **ä½œç”¨åŸŸç®¡ç†**ï¼šå¤„ç†å±€éƒ¨ã€çˆ¶ä½œç”¨åŸŸå’Œå…¨å±€å˜é‡
/// - **é”™è¯¯å¤„ç†**ï¼šå¤„ç†æœªå®šä¹‰å˜é‡ç­‰é”™è¯¯
///
/// ## ğŸ’¡ å®ç°æç¤º
///
/// 1. **æ¨¡å¼åŒ¹é…**ï¼šä½¿ç”¨ `match` è¯­å¥å¤„ç† `ApplyExprKind`
/// 2. **ç®€å•å§”æ‰˜**ï¼šå¯¹äº `AtomExpr` æƒ…å†µï¼Œç›´æ¥è°ƒç”¨ `atom_expr_to_knf`
/// 3. **é”™è¯¯å¤„ç†**ï¼šæš‚æ—¶ä¸éœ€è¦å¤„ç†å…¶ä»–å¤æ‚æƒ…å†µ
/// 4. **è¿”å›å€¼**ï¼šä¿æŒä¸ `atom_expr_to_knf` ç›¸åŒçš„è¿”å›ç±»å‹
///
/// ## ğŸ”® æœªæ¥æ‰©å±•
///
/// è™½ç„¶è¿™ä¸ªæµ‹è¯•åªå¤„ç†ç®€å•æƒ…å†µï¼Œä½† `apply_expr_to_knf` å‡½æ•°çš„è®¾è®¡å·²ç»ä¸ºå¤„ç†å¤æ‚æƒ…å†µåšå¥½äº†å‡†å¤‡ï¼š
///
/// - **æ•°ç»„è®¿é—®**ï¼š`arr[index]` â†’ `ArrayAccess(array_name, index_name)`
/// - **å­—æ®µè®¿é—®**ï¼š`obj.field` â†’ `FieldAccess(obj_name, field_name)`
/// - **å‡½æ•°è°ƒç”¨**ï¼š`func(args)` â†’ `Call(func_name, arg_names)`
///
/// è¿™äº›å¤æ‚æƒ…å†µä¼šåœ¨åç»­çš„æµ‹è¯•ä¸­é€æ­¥å®ç°ã€‚
///
/// ## ğŸ¯ å¼€å§‹å®ç°å§ï¼
///
/// è¿™ä¸ªå‡½æ•°å¯èƒ½æ˜¯ä½ åˆ°ç›®å‰ä¸ºæ­¢å®ç°çš„æœ€ç®€å•çš„ KNF è½¬æ¢å‡½æ•°ï¼
/// åªéœ€è¦è¯†åˆ«å‡º `AtomExpr` æ¨¡å¼ï¼Œç„¶åå§”æ‰˜ç»™å·²ç»å®ç°çš„ `atom_expr_to_knf` å‡½æ•°å³å¯ã€‚
///
/// **å‡†å¤‡å¥½ä½“éªŒè¿™ç§"ç®€å•å§”æ‰˜"çš„ä¼˜é›…è®¾è®¡äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å®ç°ï¼**
/// ================================================================================

///|
test "Simple Apply Expr Knf Transformation Test" {
  // set x, y, z type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("y", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("z", { kind: Bool, mutable: false })
  let knf_ctx = Context::new()
  knf_ctx.globals.set("x", Int)
  let _ = knf_ctx.add_new_name("y", Double)
  knf_ctx.enter_scope()
  let _ = knf_ctx.add_new_name("z", Bool)

  // Code parse, typecheck, knf transform
  let code =
    #|42 3.14 true "hello"
    #|x y z
  let tokens = @lexer.tokenize(code)
  let (e, tok_view) = @parser.parse_apply_expr(tokens)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Int(42))
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Double(3.14))
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Bool(true))
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is String("hello"))
  // find Global Ident `x`
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Ident({ id: "x", slot: 0 }))
  // find Parent Ident `y`
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Ident({ id: "y", slot: 0 }))
  // find Local Ident `z`
  let (e, _) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Ident({ id: "z", slot: 0 }))
}
