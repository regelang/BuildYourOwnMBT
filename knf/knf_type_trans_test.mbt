/// ================================================================================
/// # ðŸš€ æ¬¢è¿Žæ¥åˆ° KNF å˜æ¢çš„ä¸–ç•Œï¼
///
/// ðŸŽ‰ **æ­å–œä½ å®Œæˆäº†ç±»åž‹æ£€æŸ¥é˜¶æ®µçš„æ‰€æœ‰æŒ‘æˆ˜ï¼** ðŸŽ‰
///
/// çŽ°åœ¨ï¼Œæˆ‘ä»¬å°†è¿›å…¥ç¼–è¯‘å™¨æž„å»ºä¹‹æ—…çš„ç¬¬å››ä¸ªé‡è¦é˜¶æ®µï¼š**KNF å˜æ¢ (Kernel Normal Form Transformation)**ã€‚
/// è¿™æ˜¯è¿žæŽ¥é«˜çº§è¯­è¨€å’Œåº•å±‚ä»£ç ç”Ÿæˆä¹‹é—´çš„å…³é”®æ¡¥æ¢ï¼
///
/// ## ðŸŒŸ ä»€ä¹ˆæ˜¯ä¸­é—´è¡¨ç¤º IRï¼Ÿ
///
/// åœ¨ç¼–è¯‘å™¨çš„ä¸–ç•Œä¸­ï¼Œ**ä¸­é—´è¡¨ç¤º (Intermediate Representation, IR)** æ˜¯ä¸€ä¸ªæžå…¶é‡è¦çš„æ¦‚å¿µã€‚
/// æƒ³è±¡ä¸€ä¸‹ï¼Œç¼–è¯‘å™¨å°±åƒä¸€ä¸ªç¿»è¯‘å®˜ï¼Œéœ€è¦å°†äººç±»ç¼–å†™çš„é«˜çº§è¯­è¨€ä»£ç ç¿»è¯‘æˆæœºå™¨èƒ½å¤Ÿç†è§£çš„æŒ‡ä»¤ã€‚
/// ä½†æ˜¯ï¼Œè¿™ä¸ªç¿»è¯‘è¿‡ç¨‹å¾€å¾€ä¸æ˜¯ä¸€æ­¥åˆ°ä½çš„ï¼Œè€Œæ˜¯éœ€è¦ç»è¿‡å¤šä¸ªä¸­é—´æ­¥éª¤ã€‚
///
/// **IR å°±æ˜¯è¿™äº›ä¸­é—´æ­¥éª¤ä¸­çš„"é€šç”¨è¯­è¨€"**ï¼š
/// - å®ƒæ—¢ä¸åƒæºä»£ç é‚£æ ·å¤æ‚å’Œå¤šæ ·åŒ–
/// - ä¹Ÿä¸åƒæœºå™¨ç é‚£æ ·åº•å±‚å’Œç‰¹å®šäºŽç¡¬ä»¶
/// - è€Œæ˜¯å¤„äºŽä¸¤è€…ä¹‹é—´çš„ä¸€ä¸ª**æŠ½è±¡å±‚æ¬¡**ï¼Œæ—¢ä¿æŒäº†ç¨‹åºçš„æ ¸å¿ƒè¯­ä¹‰ï¼Œåˆç®€åŒ–äº†åŽç»­çš„å¤„ç†
///
/// ## ðŸ”„ ä»€ä¹ˆæ˜¯ ANFï¼Ÿ
///
/// **ANF (Administrative Normal Form)** æ˜¯ä¸€ç§é‡è¦çš„ä¸­é—´è¡¨ç¤ºå½¢å¼ã€‚
/// å®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**å°†æ‰€æœ‰çš„å¤æ‚è¡¨è¾¾å¼éƒ½åˆ†è§£æˆç®€å•çš„åŽŸå­æ“ä½œ**ã€‚
///
/// åœ¨ ANF ä¸­ï¼š
/// - æ¯ä¸ªè¡¨è¾¾å¼è¦ä¹ˆæ˜¯ä¸€ä¸ª**åŽŸå­å€¼**ï¼ˆå˜é‡ã€å­—é¢é‡ç­‰ï¼‰
/// - è¦ä¹ˆæ˜¯ä¸€ä¸ª**ç®€å•çš„å‡½æ•°è°ƒç”¨**ï¼Œå…¶å‚æ•°éƒ½æ˜¯åŽŸå­å€¼
/// - å¤æ‚çš„åµŒå¥—è¡¨è¾¾å¼ä¼šè¢«"æ‹‰å¹³"ï¼Œé€šè¿‡å¼•å…¥ä¸´æ—¶å˜é‡æ¥åˆ†è§£
///
/// ä¾‹å¦‚ï¼Œ`f(g(x), h(y))` ä¼šè¢«è½¬æ¢ä¸ºï¼š
/// ```
/// let temp1 = g(x)
/// let temp2 = h(y)
/// let result = f(temp1, temp2)
/// ```
///
/// ## âš¡ ä»€ä¹ˆæ˜¯ KNFï¼Ÿ
///
/// **KNF (Kernel Normal Form)** æ˜¯ ANF çš„ä¸€ä¸ªæ›´ä¸¥æ ¼çš„å˜ä½“ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬å½“å‰é˜¶æ®µè¦å®žçŽ°çš„ä¸­é—´è¡¨ç¤ºã€‚
///
/// KNF åœ¨ ANF çš„åŸºç¡€ä¸Šè¿›ä¸€æ­¥ç®€åŒ–ï¼š
/// - **æ›´ä¸¥æ ¼çš„è¡¨è¾¾å¼ç»“æž„**ï¼šç¡®ä¿æ¯ä¸ªè¡¨è¾¾å¼éƒ½æ˜¯"åŽŸå­"çš„
/// - **ç»Ÿä¸€çš„æŽ§åˆ¶æµ**ï¼šæ‰€æœ‰çš„æŽ§åˆ¶æµéƒ½é€šè¿‡ç‰¹å®šçš„ç»“æž„æ¥è¡¨è¾¾
/// - **ç®€åŒ–çš„ç±»åž‹ç³»ç»Ÿ**ï¼šç±»åž‹ä¿¡æ¯è¢«è§„èŒƒåŒ–ï¼Œä¾¿äºŽåŽç»­å¤„ç†
///
/// KNF çš„ä¸»è¦ä¼˜åŠ¿ï¼š
/// - **ä¾¿äºŽä¼˜åŒ–**ï¼šç®€åŒ–çš„ç»“æž„è®©ç¼–è¯‘å™¨æ›´å®¹æ˜“è¿›è¡Œå„ç§ä¼˜åŒ–
/// - **ä¾¿äºŽä»£ç ç”Ÿæˆ**ï¼šæŽ¥è¿‘ç›®æ ‡æœºå™¨çš„æ‰§è¡Œæ¨¡åž‹
/// - **ä¾¿äºŽåˆ†æž**ï¼šç¨‹åºçš„ç»“æž„æ›´åŠ æ¸…æ™°ï¼Œä¾¿äºŽé™æ€åˆ†æž
///
/// ## ðŸŽ¯ æˆ‘ä»¬çŽ°åœ¨å¤„äºŽä»€ä¹ˆä½ç½®ï¼Ÿ
///
/// è®©æˆ‘ä»¬å›žé¡¾ä¸€ä¸‹ç¼–è¯‘å™¨çš„å®Œæ•´æµç¨‹ï¼š
///
/// ```
/// æºä»£ç  â†’ è¯æ³•åˆ†æž â†’ è¯­æ³•åˆ†æž â†’ ç±»åž‹æ£€æŸ¥ â†’ **KNFå˜æ¢** â†’ LLVM(SSA) â†’ æœºå™¨ç 
/// ```
///
/// **æˆ‘ä»¬çŽ°åœ¨æ­£å¤„äºŽ KNF å˜æ¢é˜¶æ®µï¼**
///
/// - âœ… **å·²å®Œæˆ**ï¼šè¯æ³•åˆ†æžã€è¯­æ³•åˆ†æžã€ç±»åž‹æ£€æŸ¥
/// - ðŸ”„ **æ­£åœ¨è¿›è¡Œ**ï¼šKNF å˜æ¢
/// - â³ **å³å°†åˆ°æ¥**ï¼šLLVM ä»£ç ç”Ÿæˆï¼ˆSSA å½¢å¼ï¼‰
///
/// ## ðŸ”® æŽ¥ä¸‹æ¥ä¼šè¿›å…¥ LLVM (SSA)
///
/// å®Œæˆ KNF å˜æ¢åŽï¼Œæˆ‘ä»¬å°†è¿›å…¥ **LLVM ä»£ç ç”Ÿæˆé˜¶æ®µ**ã€‚
/// LLVM ä½¿ç”¨ **SSA (Static Single Assignment)** å½¢å¼ä½œä¸ºå…¶æ ¸å¿ƒä¸­é—´è¡¨ç¤ºï¼š
///
/// - **SSA ç‰¹ç‚¹**ï¼šæ¯ä¸ªå˜é‡åªè¢«èµ‹å€¼ä¸€æ¬¡ï¼Œé€šè¿‡ phi å‡½æ•°å¤„ç†æŽ§åˆ¶æµåˆå¹¶
/// - **LLVM ä¼˜åŠ¿**ï¼šæˆç†Ÿçš„ä¼˜åŒ–æ¡†æž¶ï¼Œæ”¯æŒå¤šç§ç›®æ ‡æž¶æž„
/// - **æˆ‘ä»¬çš„ç›®æ ‡**ï¼šå°† KNF å½¢å¼çš„ä»£ç è½¬æ¢ä¸º LLVM IRï¼Œæœ€ç»ˆç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ°ç±»åž‹å˜æ¢
///
/// åœ¨è¿™ä¸ªæµ‹è¯•æ–‡ä»¶ä¸­ï¼Œä½ éœ€è¦å®Œæˆ `type.mbt` æ–‡ä»¶ä¸­çš„ä¸¤ä¸ªå…³é”®å‡½æ•°ï¼š
///
/// ### 1. `typekind_to_knf` å‡½æ•°
///
/// è¿™ä¸ªå‡½æ•°è´Ÿè´£å°†ç±»åž‹æ£€æŸ¥é˜¶æ®µçš„ `TypeKind` è½¬æ¢ä¸º KNF é˜¶æ®µçš„ `Type`ã€‚
/// ä½ éœ€è¦å¤„ç†å„ç§ç±»åž‹ï¼š
/// - åŸºæœ¬ç±»åž‹ï¼š`Unit`ã€`Int`ã€`Bool`ã€`Double`ã€`String`
/// - å¤åˆç±»åž‹ï¼š`Array`ã€`Struct`ã€`Tuple`ã€`Function`
/// - é”™è¯¯å¤„ç†ï¼šå¯¹äºŽä¸æ”¯æŒçš„ç±»åž‹ï¼ŒæŠ›å‡º `KnfTransformError`
///
/// ### 2. `type_to_knf` å‡½æ•°
///
/// è¿™ä¸ªå‡½æ•°æ˜¯ `typekind_to_knf` çš„åŒ…è£…å™¨ï¼Œå°†å®Œæ•´çš„ `@typecheck.Type` å¯¹è±¡è½¬æ¢ä¸º KNF çš„ `Type`ã€‚
///
/// ## ðŸ› ï¸ ä¸Šä¸‹æ–‡ç®¡ç†
///
/// ä¸Žtypechecké˜¶æ®µä¸€æ ·ï¼Œæˆ‘ä»¬åŒæ ·éœ€è¦ä¸€ä¸ªContextç»“æž„ä½“æ¥ç®¡ç†ä¸Šä¸‹æ–‡ï¼Œä½†æœ‰æ‰€ä¸åŒçš„æ˜¯ï¼ŒTypechecké˜¶æ®µï¼Œ
/// æˆ‘ä»¬æŠŠæ¯ä¸€ä¸ªBlockçœ‹åšä¸€ä¸ªç‹¬ç«‹çš„ä½œç”¨åŸŸï¼Œè€Œåœ¨KNFé˜¶æ®µï¼Œæˆ‘ä»¬æŠŠæ•´ä¸ªå‡½æ•°ä½“çœ‹åšä¸€ä¸ªä½œç”¨åŸŸï¼Œ
///
/// `context.mbt` æ–‡ä»¶ä¸­å·²ç»å®šä¹‰å¥½äº† `Context` ç»“æž„ä½“ï¼Œä½ éœ€è¦ä½¿ç”¨å®ƒæ¥ç®¡ç†ç±»åž‹å˜æ¢è¿‡ç¨‹ä¸­çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚
///
/// ## ðŸš€ å¼€å§‹ä½ çš„ KNF ä¹‹æ—…ï¼
///
/// ç±»åž‹å˜æ¢æ˜¯ KNF å˜æ¢çš„åŸºç¡€ï¼Œåªæœ‰æ­£ç¡®åœ°å°†ç±»åž‹ç³»ç»Ÿè½¬æ¢åˆ° KNF å½¢å¼ï¼Œ
/// æˆ‘ä»¬æ‰èƒ½ç»§ç»­è¿›è¡Œè¡¨è¾¾å¼å’Œè¯­å¥çš„å˜æ¢ã€‚
///
/// **å‡†å¤‡å¥½è¿ŽæŽ¥è¿™ä¸ªæ¿€åŠ¨äººå¿ƒçš„æ–°é˜¶æ®µäº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å§ï¼**
/// ================================================================================

///|
test "Type Knf Transformation Test" {
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = Context::new()
  let code =
    #|Int Unit Bool Double String Array[Int]
    #|(Int, Double, Bool)
    #|(Int, Int) -> Bool
    #|(Array[Double]) -> String
  // Parse
  let tokens = @lexer.tokenize(code)
  let (t, tok_view) = @parser.parse_type(tokens)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Int)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Unit)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Bool)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Double)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is String)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Array(Int))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Tuple([Int, Double, Bool]))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Function([Int, Int], Bool))
  let (t, _) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Function([Array(Double)], String))
}
