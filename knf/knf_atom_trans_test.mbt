/// ================================================================================
/// # ğŸ¯ å®Œæ•´åŸå­è¡¨è¾¾å¼çš„ KNF å˜æ¢ï¼šå¤„ç†å¤æ‚æƒ…å†µ
///
/// åœ¨å®Œæˆäº†ç®€å•åŸå­è¡¨è¾¾å¼çš„è½¬æ¢ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨è¦å¤„ç†**å®Œæ•´çš„åŸå­è¡¨è¾¾å¼ (Atom Expression)** è½¬æ¢ã€‚
/// è¿™ä¸ªæµ‹è¯•å°†æ¶µç›–åŸå­è¡¨è¾¾å¼çš„æ‰€æœ‰å¤æ‚æƒ…å†µï¼ŒåŒ…æ‹¬æ‹¬å·è¡¨è¾¾å¼ã€æ•°ç»„ã€å…ƒç»„ã€ç»“æ„ä½“æ„é€ ç­‰ã€‚
///
/// ## ğŸŒŸ åŸå­è¡¨è¾¾å¼çš„å®Œæ•´ç±»å‹
///
/// **åŸå­è¡¨è¾¾å¼**æ˜¯è¡¨è¾¾å¼çš„åŸºç¡€æ„å»ºå—ï¼Œå®ƒä»¬åŒ…æ‹¬ï¼š
///
/// - **å­—é¢é‡**ï¼š`42`ã€`3.14`ã€`true`ã€`"hello"`ã€`()`
/// - **æ ‡è¯†ç¬¦**ï¼š`x`ã€`y`ã€`z`ï¼ˆå˜é‡åï¼‰
/// - **æ‹¬å·è¡¨è¾¾å¼**ï¼š`(a + b)`ï¼ˆåŒ…å«å¤æ‚è¡¨è¾¾å¼ï¼‰
/// - **æ•°ç»„å­—é¢é‡**ï¼š`[1, 2, 3]`ã€`[x, y, z]`
/// - **å…ƒç»„å­—é¢é‡**ï¼š`(x, y, z)`ã€`(a, b)`
/// - **æ•°ç»„æ„é€ **ï¼š`Array::make(5, 0)`
/// - **ç»“æ„ä½“æ„é€ **ï¼š`Point::{ x: 10, y: 20 }`
///
/// åœ¨ KNF å˜æ¢ä¸­ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯å°†è¿™äº›åŸå­è¡¨è¾¾å¼è½¬æ¢ä¸ºè§„èŒƒåŒ–çš„å½¢å¼ã€‚
///
/// ## ğŸ” å¤æ‚åŸå­è¡¨è¾¾å¼çš„å¤„ç†ç­–ç•¥
///
/// å¯¹äºåŒ…å«å­è¡¨è¾¾å¼çš„åŸå­è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦é‡‡ç”¨**é€’å½’å¤„ç†**çš„ç­–ç•¥ï¼š
///
/// ### 1. æ‹¬å·è¡¨è¾¾å¼ (Paren)
/// ```
/// Paren(inner_expr) => self.expr_to_knf(inner_expr)
/// ```
/// ç›´æ¥é€’å½’è°ƒç”¨ `expr_to_knf` å¤„ç†å†…éƒ¨è¡¨è¾¾å¼ã€‚
///
/// ### 2. æ•°ç»„å­—é¢é‡ (Array)
///
/// **å…³é”®æ­¥éª¤**ï¼š
/// 1. éå†æ•°ç»„ä¸­çš„æ¯ä¸ªè¡¨è¾¾å¼
/// 2. é€’å½’è°ƒç”¨ `expr_to_knf` å¤„ç†æ¯ä¸ªè¡¨è¾¾å¼
/// 3. åˆå¹¶æ‰€æœ‰è¯­å¥
/// 4. ä¸ºæ¯ä¸ªè¡¨è¾¾å¼åˆ›å»ºä¸´æ—¶å˜é‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
/// 5. è¿”å› `ArrayLiteral` ç»“æœ
///
/// ### 3. å…ƒç»„å­—é¢é‡ (Tuple)
///
/// å¤„ç†æ–¹å¼ä¸æ•°ç»„å­—é¢é‡ç±»ä¼¼ã€‚
///
/// ### 4. æ•°ç»„æ„é€  (ArrayMake)
///
/// **å…³é”®æ­¥éª¤**ï¼š
/// 1. åˆ†åˆ«å¤„ç†å¤§å°è¡¨è¾¾å¼å’Œåˆå§‹åŒ–è¡¨è¾¾å¼
/// 2. åˆå¹¶æ‰€æœ‰è¯­å¥
/// 3. ä¸ºæ¯ä¸ªè¡¨è¾¾å¼åˆ›å»ºä¸´æ—¶å˜é‡
/// 4. è¿”å› `ArrayMake` ç»“æœ
///
/// ### 5. ç»“æ„ä½“æ„é€  (StructConstruct)
///
/// **å…³é”®æ­¥éª¤**ï¼š
/// 1. éå†ç»“æ„ä½“çš„æ¯ä¸ªå­—æ®µ
/// 2. é€’å½’å¤„ç†æ¯ä¸ªå­—æ®µçš„è¡¨è¾¾å¼
/// 3. åˆå¹¶æ‰€æœ‰è¯­å¥
/// 4. ä¸ºæ¯ä¸ªå­—æ®µè¡¨è¾¾å¼åˆ›å»ºä¸´æ—¶å˜é‡
/// 5. è¿”å› `CreateStruct` ç»“æœ
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®Œå–„ `atom_expr_to_knf` å‡½æ•°
///
/// åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œä½ éœ€è¦å®Œå–„ `Context::atom_expr_to_knf` å‡½æ•°ï¼Œ
/// å¤„ç†æ‰€æœ‰ç±»å‹çš„åŸå­è¡¨è¾¾å¼ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// å¯¹äºåŒ…å«å­è¡¨è¾¾å¼çš„åŸå­è¡¨è¾¾å¼ï¼Œæ ¸å¿ƒç­–ç•¥æ˜¯ï¼š
/// 1. **é€’å½’è°ƒç”¨** `expr_to_knf` å¤„ç†å­è¡¨è¾¾å¼
/// 2. **åˆå¹¶è¯­å¥** å°†æ‰€æœ‰å­è¡¨è¾¾å¼çš„è¯­å¥åˆå¹¶
/// 3. **åˆ›å»ºä¸´æ—¶å˜é‡** ä¸ºå¤æ‚å­è¡¨è¾¾å¼åˆ›å»ºä¸´æ—¶å˜é‡
/// 4. **æ„é€ ç»“æœ** ä½¿ç”¨ä¸´æ—¶å˜é‡æ„é€ æœ€ç»ˆçš„ KNF è¡¨è¾¾å¼
///
/// ## ğŸš€ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// è¿™ä¸ªæµ‹è¯•æ–‡ä»¶åŒ…å«äº†å¤šç§å¤æ‚åŸå­è¡¨è¾¾å¼çš„è½¬æ¢ï¼š
///
/// 1. **æ‹¬å·è¡¨è¾¾å¼**ï¼š`(a + b)` â†’ `Binary(Add, a, b)`ï¼ˆæ— é¢å¤–è¯­å¥ï¼‰
/// 2. **æ•°ç»„å­—é¢é‡**ï¼š`[1, 2, 3]` â†’ `Let(tmp1, Int, Int(1)); Let(tmp2, Int, Int(2)); Let(tmp3, Int, Int(3)); ArrayLiteral([tmp1, tmp2, tmp3])`
/// 3. **å…ƒç»„å­—é¢é‡**ï¼š`(x, y, z)` â†’ `TupleLiteral([x, y, z])`ï¼ˆæ— é¢å¤–è¯­å¥ï¼‰
/// 4. **æ•°ç»„æ„é€ **ï¼š`Array::make(5, 0)` â†’ `Let(tmp1, Int, Int(5)); Let(tmp2, Int, Int(0)); ArrayMake(tmp1, tmp2)`
/// 5. **ç»“æ„ä½“æ„é€ **ï¼š`Point::{ x: 10, y: 20 }` â†’ `Let(tmp1, Int, Int(10)); Let(tmp2, Int, Int(20)); CreateStruct("Point", [("x", tmp1), ("y", tmp2)])`
///
/// ## ğŸ’¡ å®ç°æç¤º
///
/// 1. **é€’å½’å¤„ç†**ï¼šå¯¹äºåŒ…å«å­è¡¨è¾¾å¼çš„åŸå­è¡¨è¾¾å¼ï¼Œä½¿ç”¨ `expr_to_knf` é€’å½’å¤„ç†
/// 2. **è¯­å¥åˆå¹¶**ï¼šä½¿ç”¨ `append` åˆå¹¶æ‰€æœ‰å­è¡¨è¾¾å¼çš„è¯­å¥
/// 3. **ä¸´æ—¶å˜é‡**ï¼šä½¿ç”¨ `expr_to_knf_name` ä¸ºå¤æ‚è¡¨è¾¾å¼åˆ›å»ºä¸´æ—¶å˜é‡
/// 4. **ç±»å‹è½¬æ¢**ï¼šä½¿ç”¨ `typekind_to_knf` è½¬æ¢ç±»å‹ä¿¡æ¯
/// 5. **æ¨¡å¼åŒ¹é…**ï¼šä½¿ç”¨ `match` è¯­å¥å¤„ç†ä¸åŒçš„åŸå­è¡¨è¾¾å¼ç±»å‹
///
/// ## ğŸ”® KNF å˜æ¢çš„å®Œæ•´æ€§
///
/// é€šè¿‡å¤„ç†æ‰€æœ‰ç±»å‹çš„åŸå­è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å®ç°äº†ï¼š
///
/// - **å®Œæ•´æ€§**ï¼šè¦†ç›–äº†æ‰€æœ‰å¯èƒ½çš„åŸå­è¡¨è¾¾å¼ç±»å‹
/// - **ä¸€è‡´æ€§**ï¼šæ‰€æœ‰å¤æ‚æƒ…å†µéƒ½é‡‡ç”¨ç›¸åŒçš„é€’å½’å¤„ç†ç­–ç•¥
/// - **è§„èŒƒåŒ–**ï¼šå°†å¤æ‚çš„åµŒå¥—ç»“æ„è½¬æ¢ä¸ºç®€å•çš„åŸå­æ“ä½œ
/// - **å¯æ‰©å±•æ€§**ï¼šä¸ºåç»­çš„ä¼˜åŒ–å’Œä»£ç ç”Ÿæˆæä¾›äº†æ ‡å‡†åŒ–çš„å½¢å¼
///
/// ## ğŸ¯ å¼€å§‹å®ç°å§ï¼
///
/// è¿™æ˜¯åŸå­è¡¨è¾¾å¼è½¬æ¢çš„å®Œæ•´ç‰ˆæœ¬ï¼é€šè¿‡é€’å½’å¤„ç†æ‰€æœ‰å¤æ‚æƒ…å†µï¼Œ
/// æˆ‘ä»¬å°†åŸå­è¡¨è¾¾å¼è½¬æ¢ä¸ºè§„èŒƒåŒ–çš„ KNF å½¢å¼ã€‚
///
/// **å‡†å¤‡å¥½å¤„ç†æ‰€æœ‰ç±»å‹çš„åŸå­è¡¨è¾¾å¼äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å®ç°ï¼**
/// ================================================================================

///|
test "Atom Expr Knf Transformation Test" {
  // set a, b, x, y, z type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("a", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("b", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("x", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("y", { kind: String, mutable: false })
  typecheck_ctx.type_env.set("z", { kind: Bool, mutable: false })
  let point_struct_def : @typecheck.StructDef = {
    name: "Point",
    fields: [
      { name: "x", ty: { kind: Int, mutable: false } },
      { name: "y", ty: { kind: Int, mutable: false } },
    ],
  }
  typecheck_ctx.struct_defs.set("Point", point_struct_def)
  let knf_ctx = Context::new()
  knf_ctx.globals.set("x", Double)
  let _ = knf_ctx.add_new_name("y", String)
  knf_ctx.enter_scope()
  let _ = knf_ctx.add_new_name("z", Bool)
  let _ = knf_ctx.add_new_name("a", Int)
  let _ = knf_ctx.add_new_name("b", Int)

  // Code parse, typecheck, knf transform
  let code =
    #|(a + b)
    #|[1, 2, 3]
    #|(x, y, z)
    #|Array::make(5, 0)
    #|Point::{ x: 10, y: 20 }
  let tokens = @lexer.tokenize(code)
  // Parse and transform `(a + b)`.
  let (e, tok_view) = @parser.parse_atom_expr(tokens)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [] &&
    knf_expr is Binary(Add, l, r) &&
    l is { id: "a", .. } &&
    r is { id: "b", .. },
  )
  // Parse and transform `[1, 2, 3]`.
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [s1, s2, s3] &&
    s1 is Let(n1, Int, Int(1)) &&
    s2 is Let(n2, Int, Int(2)) &&
    s3 is Let(n3, Int, Int(3)) &&
    knf_expr is ArrayLiteral(_, [a1, a2, a3]) &&
    n1 == a1 &&
    n2 == a2 &&
    n3 == a3,
  )
  // Parse and transform `(x, y, z)`.
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [] &&
    knf_expr is TupleLiteral([t1, t2, t3]) &&
    t1 is { id: "x", .. } &&
    t2 is { id: "y", .. } &&
    t3 is { id: "z", .. },
  )
  // Parse and transform `Array::make(5, 0)`.
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Int, Int(5)) &&
    s2 is Let(n2, Int, Int(0)) &&
    knf_expr is ArrayMake(size_name, init_name) &&
    size_name == n1 &&
    init_name == n2,
  )
  // Parse and transform `Point::{ x: 10, y: 20 }`.
  let (e, _) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Int, Int(10)) &&
    s2 is Let(n2, Int, Int(20)) &&
    knf_expr is CreateStruct("Point", [("x", f1), ("y", f2)]) &&
    n1 == f1 &&
    n2 == f2,
  )
}
