/// ================================================================================
/// # ğŸ”„ While è¯­å¥çš„ KNF è½¬æ¢
///
/// ## ğŸ¯ ä»€ä¹ˆæ˜¯ While è¯­å¥ï¼Ÿ
///
/// While è¯­å¥æ˜¯ç¼–ç¨‹è¯­è¨€ä¸­çš„å¾ªç¯æ§åˆ¶ç»“æ„ï¼Œå®ƒå…è®¸ç¨‹åºé‡å¤æ‰§è¡Œä¸€æ®µä»£ç ï¼Œç›´åˆ°æŸä¸ªæ¡ä»¶ä¸å†æ»¡è¶³ã€‚
/// While è¯­å¥çš„åŸºæœ¬ç»“æ„æ˜¯ï¼š
/// while (condition) {
///   // å¾ªç¯ä½“
/// }
///
/// ## ğŸ” ç»“æ„å·®å¼‚åˆ†æ
///
/// åœ¨è¯­æ³•æ ‘ä¸­ï¼ŒWhile è¯­å¥çš„ç»“æ„ç›¸å¯¹ç®€å•ï¼š
/// - `cond`: æ¡ä»¶è¡¨è¾¾å¼
/// - `body`: å¾ªç¯ä½“ï¼ˆBlockExprï¼‰
///
/// ä½†åœ¨ KNF ä¸­ï¼ŒWhile è¯­å¥çš„ç»“æ„æ›´åŠ ç»Ÿä¸€ï¼š
/// - `KnfStmt::While(cond_block, body_block)`
/// - æ¡ä»¶è¢«åŒ…è£…åœ¨ä¸€ä¸ª `KnfBlock` ä¸­
/// - å¾ªç¯ä½“ä¹Ÿè¢«åŒ…è£…åœ¨ä¸€ä¸ª `KnfBlock` ä¸­
///
/// ## ğŸ› ï¸ å®ç°æ€è·¯
///
/// å®ç° `while_stmt_to_knf` å‡½æ•°éœ€è¦ä¸‰ä¸ªä¸»è¦æ­¥éª¤ï¼š
///
/// ### 1. æ¡ä»¶è½¬æ¢
/// - ä½¿ç”¨ `expr_to_knf` è½¬æ¢æ¡ä»¶è¡¨è¾¾å¼
/// - å°†æ¡ä»¶è¯­å¥åŒ…è£…ä¸º `ExprStmt`
/// - åˆ›å»ºæ¡ä»¶å— `KnfBlock`
///
/// ### 2. å¾ªç¯ä½“è½¬æ¢
/// - ä½¿ç”¨ `block_expr_to_knf` è½¬æ¢å¾ªç¯ä½“
/// - ç›´æ¥å¾—åˆ° `KnfBlock`
///
/// ### 3. æ„é€  While è¯­å¥
/// - åˆ›å»º `KnfStmt::While(cond_block, body_block)`
/// - è¿”å›åŒ…å«å•ä¸ª While è¯­å¥çš„æ•°ç»„
///
/// ## ğŸ”§ å…³é”®å®ç°ç»†èŠ‚
///
/// ### æ¡ä»¶å—å¤„ç†
/// æ¡ä»¶è¡¨è¾¾å¼å¯èƒ½åŒ…å«å¤æ‚çš„å­è¡¨è¾¾å¼ï¼Œéœ€è¦å…ˆè½¬æ¢ä¸º KNFï¼š
/// while (i < 10) { ... }
/// è½¬æ¢ä¸ºï¼š
/// let tmp = 10;
/// while (i < tmp) { ... }
///
/// ### å¾ªç¯ä½“å¤„ç†
/// å¾ªç¯ä½“æ˜¯ä¸€ä¸ª `BlockExpr`ï¼Œç›´æ¥ä½¿ç”¨ `block_expr_to_knf` è½¬æ¢ï¼š
/// {
///   sum = sum + i;
///   i = i + 1;
/// }
/// è½¬æ¢ä¸ºï¼š
/// {
///   sum = sum + i;
///   let tmp = 1;
///   i = i + tmp;
/// }
///
/// ### ç»Ÿä¸€ç»“æ„
/// KNF ä¸­çš„ While è¯­å¥ç»“æ„ç»Ÿä¸€ä¸ºï¼š
/// While(cond_block, body_block)
/// å…¶ä¸­ï¼š
/// - `cond_block`: åŒ…å«æ¡ä»¶è®¡ç®—å’Œæ¡ä»¶è¡¨è¾¾å¼çš„è¯­å¥å—
/// - `body_block`: åŒ…å«å¾ªç¯ä½“è¯­å¥çš„è¯­å¥å—
///
/// ## ğŸ“ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼šç®€å•å¾ªç¯
/// while (i < 10) {
///   sum = sum + i;
///   i = i + 1;
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. æ¡ä»¶ `i < 10` è½¬æ¢ä¸º `let tmp = 10; i < tmp`
/// 2. å¾ªç¯ä½“è½¬æ¢ä¸ºåŒ…å«èµ‹å€¼å’Œå¢é‡æ“ä½œçš„è¯­å¥å—
/// 3. æ„é€  `While(cond_block, body_block)`
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼šå¸¦å‡½æ•°è°ƒç”¨çš„å¾ªç¯
/// 
/// ```
/// while (x > 0) {
///   print_int(x);
///   x = x - 1;
/// }
/// ```
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. æ¡ä»¶ `x > 0` è½¬æ¢ä¸º `let tmp = 0; x > tmp`
/// 2. å¾ªç¯ä½“åŒ…å«å‡½æ•°è°ƒç”¨å’Œé€’å‡æ“ä½œ
/// 3. æ„é€  `While(cond_block, body_block)`
///
/// ## ğŸ’¡ è®¾è®¡æ€æƒ³
///
/// ### ç»Ÿä¸€ç»“æ„
/// å°†æ¡ä»¶è¡¨è¾¾å¼åŒ…è£…åœ¨ `KnfBlock` ä¸­ï¼Œä½¿å¾— While è¯­å¥çš„ç»“æ„æ›´åŠ ç»Ÿä¸€å’Œä¸€è‡´ã€‚
///
/// ### æ¡ä»¶è®¡ç®—
/// æ¡ä»¶è¡¨è¾¾å¼ä¸­çš„å¤æ‚è®¡ç®—è¢«æå–ä¸ºç‹¬ç«‹çš„è¯­å¥ï¼Œç¡®ä¿æ¡ä»¶åˆ¤æ–­çš„åŸå­æ€§ã€‚
///
/// ### å¾ªç¯ä½“å¤„ç†
/// å¾ªç¯ä½“ä½œä¸º `BlockExpr` ç›´æ¥è½¬æ¢ï¼Œä¿æŒåŸæœ‰çš„è¯­å¥ç»“æ„ã€‚
///
/// ### ç®€åŒ–è¡¨ç¤º
/// åœ¨ KNF ä¸­ç®€åŒ–å¾ªç¯æ§åˆ¶æµçš„è¡¨ç¤ºï¼Œä¸ºåç»­çš„ä¼˜åŒ–å’Œä»£ç ç”Ÿæˆåšå‡†å¤‡ã€‚
///
/// ## ğŸš€ å®ç°æŒ‘æˆ˜
///
/// ### æ¡ä»¶è¡¨è¾¾å¼å¤æ‚æ€§
/// æ¡ä»¶è¡¨è¾¾å¼å¯èƒ½åŒ…å«å‡½æ•°è°ƒç”¨ã€å¤æ‚è¿ç®—ç­‰ï¼Œéœ€è¦æ­£ç¡®è½¬æ¢ä¸º KNF å½¢å¼ã€‚
///
/// ### å¾ªç¯ä½“è¯­å¥
/// å¾ªç¯ä½“ä¸­çš„è¯­å¥éœ€è¦æ­£ç¡®è½¬æ¢ï¼ŒåŒ…æ‹¬èµ‹å€¼ã€å‡½æ•°è°ƒç”¨ç­‰ã€‚
///
/// ### ä¸´æ—¶å˜é‡ç®¡ç†
/// æ¡ä»¶è¡¨è¾¾å¼ä¸­çš„ä¸´æ—¶å˜é‡éœ€è¦æ­£ç¡®ç®¡ç†ï¼Œé¿å…å‘½åå†²çªã€‚
///
/// ## ğŸ¯ å®ç°ç›®æ ‡
///
/// å®Œæˆ `while_stmt.mbt` ä¸­çš„ `while_stmt_to_knf` å‡½æ•°ï¼Œå®ç° While è¯­å¥çš„ KNF è½¬æ¢ã€‚
/// å‡½æ•°åº”è¯¥ï¼š
/// 1. æ­£ç¡®è½¬æ¢æ¡ä»¶è¡¨è¾¾å¼ä¸ºæ¡ä»¶å—
/// 2. æ­£ç¡®è½¬æ¢å¾ªç¯ä½“ä¸ºè¯­å¥å—
/// 3. æ„é€ ç»Ÿä¸€çš„ While è¯­å¥ç»“æ„
/// 4. å¤„ç†å¤æ‚çš„æ¡ä»¶è¡¨è¾¾å¼å’Œå¾ªç¯ä½“è¯­å¥
///
/// ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹å®ç° While è¯­å¥çš„è½¬æ¢å§ï¼ğŸš€
///
/// ================================================================================

///|
test "While Stmt Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup type environment for testing
  typecheck_ctx.type_env.set("i", { kind: Int, mutable: true })
  typecheck_ctx.type_env.set("sum", { kind: Int, mutable: true })
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: true })
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })

  // Setup knf context
  let _ = knf_ctx.add_new_name("i", Int)
  let _ = knf_ctx.add_new_name("sum", Int)
  let _ = knf_ctx.add_new_name("x", Int)
  knf_ctx.globals.set("print_int", Function([Int], Unit))

  // Test 1: Simple while loop: while (i < 10) { sum = sum + i; i = i + 1; }
  let code1 =
    #|while (i < 10) {
    #|  sum = sum + i;
    #|  i = i + 1;
    #|}
  let tokens1 = @lexer.tokenize(code1)
  let (while_stmt1, _) = @parser.parse_while_stmt(tokens1)
  let checked_while_stmt1 = typecheck_ctx.check_while_stmt(while_stmt1)
  let knf_while_stmts1 = knf_ctx.while_stmt_to_knf(checked_while_stmt1)

  // Test 1: Check that we get a While statement
  assert_true(knf_while_stmts1.length() is 1)
  assert_true(knf_while_stmts1[0] is While(_, _))
  guard knf_while_stmts1[0] is While(cond_block, body_block)

  // Test 1: Check condition block (should have let for 10 and the condition expression)
  // Condition block should have: let tmp = 10; and i < tmp;
  assert_true(cond_block.stmts.length() is 2)
  assert_true(
    cond_block.stmts[0] is Let(tmp_name, Int, Int(10)) &&
    tmp_name is { id: "tmp", slot: 0 },
  )
  assert_true(
    cond_block.stmts[1] is ExprStmt(Binary(LT, i_name, tmp_cond)) &&
    i_name is { id: "i", .. } &&
    tmp_cond is { id: "tmp", slot: 0 },
  )

  // Body block should have:
  // 1. sum = sum + i; (no expansion needed, operands are identifiers)
  // 2. let tmp$1 : Int = 1; (extract literal)
  // 3. i = i + tmp$1; (assignment)
  assert_true(body_block.stmts.length() is 3)
  assert_true(
    body_block.stmts[0] is Assign(sum_name, Binary(Add, sum_name2, i_name2)) &&
    sum_name is { id: "sum", .. } &&
    sum_name2 is { id: "sum", .. } &&
    i_name2 is { id: "i", .. },
  )
  assert_true(
    body_block.stmts[1] is Let(tmp_lit, Int, Int(1)) &&
    tmp_lit is { id: "tmp", slot: 1 },
  )
  assert_true(
    body_block.stmts[2] is Assign(i_name3, Binary(Add, i_name4, tmp_add)) &&
    i_name3 is { id: "i", .. } &&
    i_name4 is { id: "i", .. } &&
    tmp_add is { id: "tmp", slot: 1 },
  )

  // Test 2: While with function call: while (x > 0) { print_int(x); x = x - 1; }
  let code2 =
    #|while (x > 0) {
    #|  print_int(x);
    #|  x = x - 1;
    #|}
  let tokens2 = @lexer.tokenize(code2)
  let (while_stmt2, _) = @parser.parse_while_stmt(tokens2)
  let checked_while_stmt2 = typecheck_ctx.check_while_stmt(while_stmt2)
  let knf_while_stmts2 = knf_ctx.while_stmt_to_knf(checked_while_stmt2)
  assert_true(knf_while_stmts2.length() is 1)
  guard knf_while_stmts2[0] is While(cond_block, body_block)

  // Test 2: Check structure
  // Condition block: let tmp = 0; x > tmp;
  assert_true(cond_block.stmts.length() is 2)
  assert_true(
    cond_block.stmts[0] is Let(_, Int, Int(0)) &&
    cond_block.stmts[1] is ExprStmt(Binary(GT, _, _)),
  )

  // Body block: print_int(x); x = x - 1;
  // Similar to test 1: print_int(x); let tmp = 1; x = x - tmp;
  assert_true(body_block.stmts.length() is 3)
  assert_true(body_block.stmts[0] is ExprStmt(Call(_, _)))
  assert_true(body_block.stmts[1] is Let(_, Int, Int(1)))
  assert_true(body_block.stmts[2] is Assign(_, Binary(Sub, _, _)))
}
