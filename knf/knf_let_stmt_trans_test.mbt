/// ================================================================================
/// # ğŸ¯ Let è¯­å¥çš„ KNF å˜æ¢ï¼šæ¨¡å¼åŒ¹é…çš„æŒ‘æˆ˜
///
/// åœ¨å®Œæˆäº† Let Mut è¯­å¥çš„è½¬æ¢ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨è¦å¤„ç†**Let è¯­å¥**çš„è½¬æ¢ã€‚
/// è¿™æ˜¯ KNF å˜æ¢ä¸­çš„ä¸€ä¸ªé‡è¦æŒ‘æˆ˜ï¼Œå› ä¸ºå®ƒæ¶‰åŠåˆ°**æ¨¡å¼åŒ¹é… (Pattern Matching)** çš„æ¦‚å¿µã€‚
///
/// ## ğŸŒŸ ä»€ä¹ˆæ˜¯ Let è¯­å¥ï¼Ÿ
///
/// **Let è¯­å¥**æ˜¯å£°æ˜ä¸å¯å˜å˜é‡çš„è¯­å¥ï¼Œå®ƒä»¬çš„å½¢å¼æ˜¯ï¼š
///
/// ```
/// let x: Int = 10;              // ç®€å•å˜é‡ç»‘å®š
/// let (a, b) = (42.0, 33.0);   // å…ƒç»„è§£æ„
/// let _ = print_int(x);         // é€šé…ç¬¦ç»‘å®š
/// ```
///
/// **Let è¯­å¥çš„ç‰¹ç‚¹**ï¼š
/// - **ä¸å¯å˜æ€§**ï¼šå£°æ˜çš„å˜é‡ä¸èƒ½åœ¨åç»­ä»£ç ä¸­è¢«ä¿®æ”¹
/// - **æ¨¡å¼åŒ¹é…**ï¼šæ”¯æŒå¤æ‚çš„æ¨¡å¼åŒ¹é…å’Œè§£æ„
/// - **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶ç¡®ä¿ç±»å‹åŒ¹é…
/// - **ä½œç”¨åŸŸ**ï¼šå˜é‡åœ¨å£°æ˜çš„ä½œç”¨åŸŸå†…æœ‰æ•ˆ
///
/// ## ğŸ” æ¨¡å¼åŒ¹é…çš„æŒ‘æˆ˜
///
/// Let è¯­å¥çš„æ ¸å¿ƒæŒ‘æˆ˜åœ¨äº**æ¨¡å¼åŒ¹é…**ï¼Œç‰¹åˆ«æ˜¯**å…ƒç»„è§£æ„**ï¼š
///
/// ### é—®é¢˜ï¼šä½æ•ˆçš„å…ƒç»„æ„é€ 
///
/// å¯¹äº `let (a, b) = (1, 2)` è¿™æ ·çš„è¯­å¥ï¼Œä¸€ä¸ªç›´è§‚ä½†ä½æ•ˆçš„è½¬æ¢æ–¹å¼æ˜¯ï¼š
///
/// ```
/// let tmp1 = 1;
/// let tmp2 = 2;
/// let tmp3 = (tmp1, tmp2);    // æ„é€ å…ƒç»„
/// let a = tmp3.0;             // è®¿é—®å…ƒç»„å…ƒç´ 
/// let b = tmp3.1;
/// ```
///
/// **é—®é¢˜**ï¼š
/// - éœ€è¦æ„é€ ä¸å¿…è¦çš„å…ƒç»„å¯¹è±¡
/// - å¢åŠ å†…å­˜åˆ†é…å¼€é”€
/// - åœ¨åç»­ä¼˜åŒ–ä¸­éš¾ä»¥æ¶ˆé™¤
///
/// ### è§£å†³æ–¹æ¡ˆï¼šç›´æ¥ç»‘å®š
///
/// æ›´å¥½çš„æ–¹å¼æ˜¯**ç›´æ¥ç»‘å®š**ï¼š
///
/// ```
/// let tmp1 = 1;
/// let tmp2 = 2;
/// let a = tmp1;               // ç›´æ¥ç»‘å®š
/// let b = tmp2;
/// ```
///
/// **ä¼˜åŠ¿**ï¼š
/// - é¿å…ä¸å¿…è¦çš„å…ƒç»„æ„é€ 
/// - å‡å°‘å†…å­˜åˆ†é…
/// - ä¸ºåç»­ä¼˜åŒ–æä¾›æ›´å¥½çš„åŸºç¡€
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `let_stmt_to_knf` å‡½æ•°
///
/// åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œä½ éœ€è¦å®ç° `Context::let_stmt_to_knf` å‡½æ•°ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// Let è¯­å¥çš„è½¬æ¢åˆ†ä¸ºä¸¤ä¸ªä¸»è¦æ­¥éª¤ï¼š
///
/// 1. **å¤„ç†åˆå§‹åŒ–è¡¨è¾¾å¼**ï¼šä½¿ç”¨ `expr_to_knf` å¤„ç†å³ä¾§è¡¨è¾¾å¼
/// 2. **æ¨¡å¼ç»‘å®š**ï¼šä½¿ç”¨ `bind_pattern_to_expr` å¤„ç†å·¦ä¾§æ¨¡å¼
///
/// ### ğŸ”§ æ¨¡å¼ç»‘å®šçš„æ ¸å¿ƒç­–ç•¥
///
/// å¯¹äºä¸åŒçš„æ¨¡å¼ç±»å‹ï¼Œéœ€è¦é‡‡ç”¨ä¸åŒçš„ç­–ç•¥ï¼š
///
/// #### 1. ç®€å•æ ‡è¯†ç¬¦æ¨¡å¼
/// - ç›´æ¥åˆ›å»ºå˜é‡ç»‘å®š
/// - ä½¿ç”¨ `add_new_name` åˆ›å»ºå˜é‡å
///
/// #### 2. é€šé…ç¬¦æ¨¡å¼
/// - ä½¿ç”¨ `Name::wildcard()` åˆ›å»ºé€šé…ç¬¦å
/// - ä»ç„¶éœ€è¦å¤„ç†è¡¨è¾¾å¼ï¼ˆå¯èƒ½æœ‰å‰¯ä½œç”¨ï¼‰
///
/// #### 3. å…ƒç»„æ¨¡å¼ï¼ˆå…³é”®æŒ‘æˆ˜ï¼‰
/// - **æ£€æµ‹å…ƒç»„å­—é¢é‡**ï¼šå¦‚æœå³ä¾§æ˜¯ `TupleLiteral`ï¼Œç›´æ¥è§£æ„
/// - **é¿å…å…ƒç»„æ„é€ **ï¼šä¸åˆ›å»ºä¸­é—´å…ƒç»„å¯¹è±¡
/// - **é€’å½’ç»‘å®š**ï¼šå¯¹æ¯ä¸ªå­æ¨¡å¼é€’å½’è°ƒç”¨ç»‘å®šå‡½æ•°
///
/// ## ğŸš€ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// è¿™ä¸ªæµ‹è¯•æ–‡ä»¶åŒ…å«äº†å¤šç§ Let è¯­å¥çš„è½¬æ¢ï¼š
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼š`let x: Int = 10;`
/// **è½¬æ¢ç»“æœ**ï¼š`Let(x, Int, Int(10))`
/// **ç‰¹ç‚¹**ï¼šç®€å•çš„æ ‡è¯†ç¬¦ç»‘å®š
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼š`let (a, b) = (42.0, 33.0);`
/// **æœŸæœ›è½¬æ¢**ï¼š
/// ```
/// let tmp1: Double = 42.0;
/// let tmp2: Double = 33.0;
/// let a = tmp1;
/// let b = tmp2;
/// ```
/// **å…³é”®ç‚¹**ï¼šé¿å…æ„é€ ä¸­é—´å…ƒç»„
///
/// ### æµ‹è¯•ç”¨ä¾‹ 3ï¼š`let y: Double = a + b;`
/// **è½¬æ¢ç»“æœ**ï¼š`Let(y, Double, Binary(Add, a, b))`
/// **ç‰¹ç‚¹**ï¼šå¤æ‚è¡¨è¾¾å¼çš„ç»‘å®š
///
/// ### æµ‹è¯•ç”¨ä¾‹ 4ï¼š`let _ = print_int(x);`
/// **è½¬æ¢ç»“æœ**ï¼š`Let(_, Unit, Call(print_int, [x]))`
/// **ç‰¹ç‚¹**ï¼šé€šé…ç¬¦ç»‘å®šï¼Œå¤„ç†å‰¯ä½œç”¨
///
/// ## ğŸ’¡ å®ç°æç¤º
///
/// 1. **è¡¨è¾¾å¼å¤„ç†**ï¼šä½¿ç”¨ `expr_to_knf` å¤„ç†åˆå§‹åŒ–è¡¨è¾¾å¼
/// 2. **æ¨¡å¼æ£€æµ‹**ï¼šæ£€æµ‹å…ƒç»„å­—é¢é‡ï¼Œé¿å…ä¸å¿…è¦çš„æ„é€ 
/// 3. **é€’å½’ç»‘å®š**ï¼šå¯¹å…ƒç»„æ¨¡å¼ä½¿ç”¨é€’å½’ç»‘å®šç­–ç•¥
/// 4. **ç±»å‹åŒ¹é…**ï¼šç¡®ä¿æ¨¡å¼å’Œè¡¨è¾¾å¼çš„ç±»å‹åŒ¹é…
/// 5. **é”™è¯¯å¤„ç†**ï¼šå¤„ç†æ¨¡å¼åŒ¹é…å¤±è´¥çš„æƒ…å†µ
///
/// ## ğŸ”® ä¼˜åŒ–æ€è€ƒ
///
/// åœ¨å®ç°è¿‡ç¨‹ä¸­ï¼Œè€ƒè™‘ä»¥ä¸‹ä¼˜åŒ–é—®é¢˜ï¼š
///
/// ### é—®é¢˜ï¼šæ˜¯å¦å¯ä»¥ç›´æ¥ç»‘å®šå­—é¢é‡ï¼Ÿ
/// å¯¹äº `let (a, b) = (42.0, 33.0)`ï¼Œæ˜¯å¦å¯ä»¥ç›´æ¥ç”Ÿæˆï¼š
/// ```
/// let a = 42.0;
/// let b = 33.0;
/// ```
///
/// **æ€è€ƒ**ï¼š
/// - è¿™åœ¨é€»è¾‘ä¸Šæ˜¯æ­£ç¡®çš„
/// - ä½†åœ¨ KNF å˜æ¢é˜¶æ®µå¯èƒ½éš¾ä»¥å®ç°
/// - éœ€è¦æ·±å…¥åˆ†æè¡¨è¾¾å¼çš„ç»“æ„
///
/// ### æ›´å¥½çš„æ–¹å¼ï¼Ÿ
/// è€ƒè™‘æ˜¯å¦æœ‰æ›´å¥½çš„ä¼˜åŒ–ç­–ç•¥ï¼š
/// - åœ¨å“ªä¸ªé˜¶æ®µè¿›è¡Œä¼˜åŒ–æ›´åˆé€‚ï¼Ÿ
/// - å¦‚ä½•å¹³è¡¡å®ç°çš„å¤æ‚åº¦å’Œä¼˜åŒ–æ•ˆæœï¼Ÿ
/// - å¦‚ä½•ç¡®ä¿ä¼˜åŒ–çš„æ­£ç¡®æ€§ï¼Ÿ
///
/// ## ğŸ¯ å¼€å§‹å®ç°å§ï¼
///
/// è¿™æ˜¯æ¨¡å¼åŒ¹é…çš„ç¬¬ä¸€ä¸ªæŒ‘æˆ˜ï¼é€šè¿‡å®ç° Let è¯­å¥çš„è½¬æ¢ï¼Œ
/// æˆ‘ä»¬å°†æŒæ¡æ¨¡å¼åŒ¹é…çš„æ ¸å¿ƒæ€æƒ³ï¼Œä¸ºåç»­æ›´å¤æ‚çš„æ¨¡å¼å¤„ç†å¥ å®šåŸºç¡€ã€‚
///
/// **å‡†å¤‡å¥½è¿æ¥æ¨¡å¼åŒ¹é…çš„æŒ‘æˆ˜äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å®ç°ï¼**
/// ================================================================================

///|
test "Let Stmt Knf Transformation Test" {
  // Prelucde Parts
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })
  let knf_ctx = @knf.Context::new()
  knf_ctx.globals.set("print_int", Function([Int], Unit))
  // Test Parts
  let code =
    #|let x: Int = 10;
    #|let (a, b) = (42.0, 33.0);
    #|let y: Double = a + b;
    #|let _ = print_int(x);
  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)
  // Parse and transform `let x: Int = 10;`
  let (stmt, tok_view) = @parser.parse_let_stmt(tokens)
  let stmt = typecheck_ctx.check_let_stmt(stmt)
  let knf_stmts = knf_ctx.let_stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is Let(name1, Int, init_expr) &&
    name1 is { id: "x", .. } &&
    init_expr is Int(10),
  )
  // Parse and transform `let (a, b) = (42.0, 33.0);`
  // It Should be transformed into 4 let statements in knf
  // 1. let tmp1: Double = 42.0;
  // 2. let tmp2: Double = 33.0;
  // 3. let a = tmp1;
  // 4. let b = tmp2;
  // Not: let tmp3 = (tmp1, tmp2); then let a = tmp1.0; let b = tmp1.1
  // Although it's correct, it's not efficient way, be cause we need
  // to create a tuple object in memory.
  //
  // Ask: Does `let a = 42.0; let b = 33.0;` better?
  // Well, you can try it. But it may not easy in knf transformation phase.
  let (stmt1, tok_view) = @parser.parse_let_stmt(tok_view)
  let stmt1 = typecheck_ctx.check_let_stmt(stmt1)
  let knf_stmts1 = knf_ctx.let_stmt_to_knf(stmt1)
  assert_true(
    knf_stmts1 is [s1, s2, s3, s4] &&
    s1 is Let(n1, Double, Double(42.0)) &&
    s2 is Let(n2, Double, Double(33.0)) &&
    s3 is Let(a, _, Ident(n1_)) &&
    s4 is Let(b, _, Ident(n2_)) &&
    n1 == n1_ &&
    n2 == n2_ &&
    a is { id: "a", .. } &&
    b is { id: "b", .. },
  )
  // Parse and transform `let y: Double = a + b;`
  let (stmt2, tok_view) = @parser.parse_let_stmt(tok_view)
  let stmt2 = typecheck_ctx.check_let_stmt(stmt2)
  let knf_stmts2 = knf_ctx.let_stmt_to_knf(stmt2)
  assert_true(
    knf_stmts2 is [s2] &&
    s2 is Let(name2, Double, init_expr2) &&
    name2 is { id: "y", .. } &&
    init_expr2 is Binary(Add, left, right) &&
    left is { id: "a", .. } &&
    right is { id: "b", .. },
  )
  // Parse and transform `let _ = print_int(y);`
  let (stmt3, _) = @parser.parse_let_stmt(tok_view)
  let stmt3 = typecheck_ctx.check_let_stmt(stmt3)
  let knf_stmts3 = knf_ctx.let_stmt_to_knf(stmt3)
  assert_true(
    knf_stmts3 is [s3] &&
    s3 is Let(_, Unit, call_expr) &&
    call_expr is Call(func, args) &&
    func is { id: "print_int", .. } &&
    args is [arg] &&
    arg is { id: "x", .. },
  )
}
