
/// ================================================================================
/// # ðŸ”’ å±€éƒ¨å‡½æ•°çš„ KNF è½¬æ¢ï¼ˆé—­åŒ…ï¼‰
///
/// æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•å°†å±€éƒ¨å‡½æ•°è½¬æ¢ä¸º KNF å½¢å¼ã€‚
/// è¿™æ˜¯ä¸€ä¸ª**éš¾ç‚¹**ï¼Œéœ€è¦æ·±å…¥ç†è§£é—­åŒ…å’Œå˜é‡æ•èŽ·çš„æ¦‚å¿µã€‚
///
/// ## ðŸŽ¯ ä»€ä¹ˆæ˜¯å±€éƒ¨å‡½æ•°ï¼Ÿ
///
/// å±€éƒ¨å‡½æ•°æ˜¯åœ¨å…¶ä»–å‡½æ•°å†…éƒ¨å®šä¹‰çš„å‡½æ•°ï¼Œå®ƒä»¬å¯ä»¥è®¿é—®å¤–éƒ¨å‡½æ•°çš„å˜é‡ã€‚
/// å±€éƒ¨å‡½æ•°çš„åŸºæœ¬ç»“æž„æ˜¯ï¼š
/// fn outer_function() -> Unit {
///   let x = 1;
///   fn inner_function() -> Unit {
///     // å¯ä»¥è®¿é—® x
///   }
/// }
///
/// å±€éƒ¨å‡½æ•°çš„ç‰¹ç‚¹ï¼š
/// - å®šä¹‰åœ¨å…¶ä»–å‡½æ•°å†…éƒ¨
/// - å¯ä»¥è®¿é—®å¤–éƒ¨å‡½æ•°çš„å˜é‡ï¼ˆé—­åŒ…ï¼‰
/// - éœ€è¦è®°å½•æ•èŽ·çš„å˜é‡
/// - å½¢æˆåµŒå¥—çš„ä½œç”¨åŸŸç»“æž„
///
/// ## ðŸ” ç»“æž„å·®å¼‚åˆ†æž
///
/// åœ¨è¯­æ³•æ ‘ä¸­ï¼Œå±€éƒ¨å‡½æ•°çš„ç»“æž„ç›¸å¯¹ç®€å•ï¼š
/// - `fname`: å‡½æ•°åç§°ï¼ˆStringï¼‰
/// - `param_list`: å‚æ•°åˆ—è¡¨ï¼ˆArray[(String, Type)]ï¼‰
/// - `ret_ty`: è¿”å›žç±»åž‹ï¼ˆTypeï¼‰
/// - `body`: å‡½æ•°ä½“ï¼ˆBlockExprï¼‰
///
/// åœ¨ KNF ä¸­ï¼Œå±€éƒ¨å‡½æ•°è¢«è½¬æ¢ä¸ºé—­åŒ…ï¼š
/// - `KnfClosure`: åŒ…å« nameã€paramsã€ret_tyã€bodyã€captured_vars çš„ç»“æž„ä½“
/// - `captured_vars`: æ•èŽ·çš„å˜é‡æ˜ å°„ï¼ˆMap[Name, Type]ï¼‰
/// - éœ€è¦è®°å½•å“ªäº›å˜é‡è¢«æ•èŽ·
///
/// ## ðŸ› ï¸ å®žçŽ°æ€è·¯
///
/// å®žçŽ° `local_function_to_knf` å‡½æ•°éœ€è¦å››ä¸ªä¸»è¦æ­¥éª¤ï¼š
///
/// ### 1. å‡½æ•°ç±»åž‹æž„é€ 
/// - éåŽ†å‚æ•°åˆ—è¡¨ï¼Œè½¬æ¢å‚æ•°ç±»åž‹
/// - è½¬æ¢è¿”å›žç±»åž‹
/// - æž„é€ å‡½æ•°ç±»åž‹ `Function(param_types, ret_ty)`
/// - åˆ›å»ºå‡½æ•°åç§°
///
/// ### 2. è¿›å…¥å‡½æ•°ä½œç”¨åŸŸ
/// - ä½¿ç”¨ `enter_scope()` åˆ›å»ºæ–°çš„ä½œç”¨åŸŸ
/// - ä¸ºå‡½æ•°å‚æ•°æä¾›ç‹¬ç«‹çš„ä½œç”¨åŸŸ
///
/// ### 3. å‚æ•°å¤„ç†å’Œå‡½æ•°ä½“è½¬æ¢
/// - å¤„ç†å‚æ•°åˆ—è¡¨ï¼Œä¸ºæ¯ä¸ªå‚æ•°åˆ›å»º Name
/// - ä½¿ç”¨ `block_expr_to_knf` è½¬æ¢å‡½æ•°ä½“
/// - åœ¨è½¬æ¢è¿‡ç¨‹ä¸­ï¼Œ`lookup_name` ä¼šè‡ªåŠ¨è®°å½•æ•èŽ·çš„å˜é‡
///
/// ### 4. é€€å‡ºä½œç”¨åŸŸå¹¶æž„é€ é—­åŒ…
/// - ä½¿ç”¨ `exit_scope()` é€€å‡ºå‡½æ•°ä½œç”¨åŸŸ
/// - èŽ·å–æ•èŽ·çš„å˜é‡æ˜ å°„
/// - è¿”å›ž `KnfClosure` ç»“æž„
///
/// ## ðŸ”§ å…³é”®å®žçŽ°ç»†èŠ‚
///
/// ### å˜é‡æ•èŽ·æœºåˆ¶
/// è¿™æ˜¯å±€éƒ¨å‡½æ•°è½¬æ¢çš„**æ ¸å¿ƒéš¾ç‚¹**ï¼š
/// - å½“å±€éƒ¨å‡½æ•°è®¿é—®å¤–éƒ¨å˜é‡æ—¶ï¼Œéœ€è¦"æ•èŽ·"è¿™äº›å˜é‡
/// - æ•èŽ·çš„å˜é‡éœ€è¦å­˜å‚¨åœ¨é—­åŒ…ä¸­
/// - éœ€è¦ä¿®æ”¹ `lookup_name` å‡½æ•°çš„ä½œç”¨æ–¹å¼
///
/// ### æ•èŽ·è®°å½•ç­–ç•¥
/// å½“ä¸€ä¸ªå˜é‡åœ¨å±€éƒ¨çŽ¯å¢ƒå†…æ²¡æœ‰æ‰¾åˆ°æ—¶ï¼š
/// - å®ƒåº”è¯¥å‘å®ƒçš„çˆ¶çŽ¯å¢ƒè¿›è¡Œå¯»æ‰¾
/// - å¦‚æžœæ‰¾åˆ°ï¼Œéœ€è¦è®°å½•æ•èŽ·
/// - å¦‚æžœçˆ¶çŽ¯å¢ƒæ²¡æœ‰æ‰¾åˆ°ï¼Œçˆ¶çŽ¯å¢ƒçš„çˆ¶çŽ¯å¢ƒæ‰¾åˆ°äº†
/// - é‚£ä¹ˆçˆ¶çŽ¯å¢ƒä¹Ÿéœ€è¦è®°å½•æ•èŽ·
///
/// ### ä½œç”¨åŸŸé“¾éåŽ†
/// å˜é‡æŸ¥æ‰¾éœ€è¦æ²¿ç€ä½œç”¨åŸŸé“¾å‘ä¸ŠéåŽ†ï¼š
/// - å½“å‰ä½œç”¨åŸŸ -> çˆ¶ä½œç”¨åŸŸ -> çˆ¶çˆ¶ä½œç”¨åŸŸ -> ...
/// - æ¯ä¸ªæ‰¾åˆ°å˜é‡çš„ä½œç”¨åŸŸéƒ½éœ€è¦è®°å½•æ•èŽ·
/// - ç¡®ä¿æ‰€æœ‰å¿…è¦çš„å˜é‡éƒ½è¢«æ­£ç¡®æ•èŽ·
///
/// ### é—­åŒ…æž„é€ 
/// é—­åŒ…éœ€è¦åŒ…å«ï¼š
/// - å‡½æ•°åç§°å’Œå‚æ•°
/// - è¿”å›žç±»åž‹
/// - å‡½æ•°ä½“
/// - æ•èŽ·çš„å˜é‡æ˜ å°„
///
/// ## ðŸ“ æµ‹è¯•ç”¨ä¾‹è§£æž
///
/// ### æµ‹è¯•ç”¨ä¾‹ï¼šåµŒå¥—å±€éƒ¨å‡½æ•°
/// fn foo() -> Unit {
///   let x = 1;
///   fn bar() -> Unit {
///     fn baz() -> Unit {
///       print_int(x);  // baz æ•èŽ· x
///     }
///     baz();
///   }
///   bar();
/// }
///
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. `foo` å‡½æ•°ï¼šå®šä¹‰å˜é‡ x
/// 2. `bar` å‡½æ•°ï¼šæ•èŽ· xï¼ˆå› ä¸º baz éœ€è¦è®¿é—® xï¼‰
/// 3. `baz` å‡½æ•°ï¼šæ•èŽ· xï¼ˆç›´æŽ¥è®¿é—® xï¼‰
/// 4. æ¯ä¸ªé—­åŒ…éƒ½è®°å½•å…¶æ•èŽ·çš„å˜é‡
///
/// ### æ•èŽ·åˆ†æž
/// - `bar` é—­åŒ…ï¼šcaptured_vars = {x: Int}
/// - `baz` é—­åŒ…ï¼šcaptured_vars = {x: Int}
/// - ä¸¤ä¸ªé—­åŒ…éƒ½æ•èŽ·äº†åŒä¸€ä¸ªå˜é‡ x
///
/// ## ðŸ’¡ è®¾è®¡æ€æƒ³
///
/// ### é—­åŒ…æ¦‚å¿µ
/// å±€éƒ¨å‡½æ•°å½¢æˆé—­åŒ…ï¼Œå¯ä»¥è®¿é—®å¤–éƒ¨å‡½æ•°çš„å˜é‡ã€‚
///
/// ### å˜é‡æ•èŽ·
/// éœ€è¦è‡ªåŠ¨è¯†åˆ«å’Œè®°å½•è¢«æ•èŽ·çš„å˜é‡ã€‚
///
/// ### ä½œç”¨åŸŸé“¾
/// å˜é‡æŸ¥æ‰¾éœ€è¦æ²¿ç€ä½œç”¨åŸŸé“¾è¿›è¡Œã€‚
///
/// ### åµŒå¥—æ”¯æŒ
/// æ”¯æŒå¤šå±‚åµŒå¥—çš„å±€éƒ¨å‡½æ•°ã€‚
///
/// ## ðŸš€ å®žçŽ°æŒ‘æˆ˜
///
/// ### æ•èŽ·è¯†åˆ«
/// è¿™æ˜¯**æœ€å¤§çš„éš¾ç‚¹**ï¼š
/// - éœ€è¦è¯†åˆ«å“ªäº›å˜é‡è¢«å±€éƒ¨å‡½æ•°è®¿é—®
/// - éœ€è¦è®°å½•æ•èŽ·çš„å˜é‡
/// - éœ€è¦å¤„ç†åµŒå¥—çš„ä½œç”¨åŸŸ
///
/// ### ä½œç”¨åŸŸç®¡ç†
/// éœ€è¦æ­£ç¡®ç®¡ç†åµŒå¥—çš„ä½œç”¨åŸŸï¼š
/// - è¿›å…¥å’Œé€€å‡ºä½œç”¨åŸŸçš„æ—¶æœº
/// - ä½œç”¨åŸŸé“¾çš„ç»´æŠ¤
/// - æ•èŽ·å˜é‡çš„è®°å½•
///
/// ### å˜é‡æŸ¥æ‰¾
/// éœ€è¦ä¿®æ”¹ `lookup_name` å‡½æ•°ï¼š
/// - å½“å˜é‡åœ¨å±€éƒ¨çŽ¯å¢ƒå†…æ²¡æœ‰æ‰¾åˆ°æ—¶
/// - å‘çˆ¶çŽ¯å¢ƒè¿›è¡Œå¯»æ‰¾
/// - è®°å½•æ•èŽ·ä¿¡æ¯
/// - å¤„ç†å¤šå±‚åµŒå¥—çš„æƒ…å†µ
///
/// ### é—­åŒ…æž„é€ 
/// éœ€è¦æ­£ç¡®æž„é€ é—­åŒ…ï¼š
/// - åŒ…å«æ‰€æœ‰å¿…è¦çš„ä¿¡æ¯
/// - æ­£ç¡®è®°å½•æ•èŽ·çš„å˜é‡
/// - ä¿æŒä½œç”¨åŸŸçš„å®Œæ•´æ€§
///
/// ## ðŸŽ¯ å®žçŽ°ç›®æ ‡
///
/// å®Œæˆ `closure.mbt` ä¸­çš„ `local_function_to_knf` å‡½æ•°ï¼Œå®žçŽ°å±€éƒ¨å‡½æ•°çš„ KNF è½¬æ¢ã€‚
/// å‡½æ•°åº”è¯¥ï¼š
/// 1. æ­£ç¡®æž„é€ å‡½æ•°ç±»åž‹å’Œåç§°
/// 2. æ­£ç¡®ç®¡ç†å‡½æ•°ä½œç”¨åŸŸ
/// 3. æ­£ç¡®å¤„ç†å‚æ•°åˆ—è¡¨
/// 4. æ­£ç¡®è½¬æ¢å‡½æ•°ä½“
/// 5. æ­£ç¡®è®°å½•æ•èŽ·çš„å˜é‡
/// 6. è¿”å›žå®Œæ•´çš„ KnfClosure ç»“æž„
///
/// ## ðŸ¤” æ€è€ƒé¢˜
///
/// å¦‚ä½•ä¿®æ”¹ `lookup_name` å‡½æ•°æ¥æ”¯æŒå˜é‡æ•èŽ·ï¼Ÿ
/// - å½“ä¸€ä¸ªå˜é‡åœ¨å±€éƒ¨çŽ¯å¢ƒå†…æ²¡æœ‰æ‰¾åˆ°æ—¶ï¼Œåº”è¯¥å¦‚ä½•å¤„ç†ï¼Ÿ
/// - å¦‚ä½•è®°å½•æ•èŽ·çš„å˜é‡ï¼Ÿ
/// - å¦‚ä½•å¤„ç†å¤šå±‚åµŒå¥—çš„ä½œç”¨åŸŸï¼Ÿ
/// - å¦‚ä½•ç¡®ä¿æ‰€æœ‰å¿…è¦çš„å˜é‡éƒ½è¢«æ­£ç¡®æ•èŽ·ï¼Ÿ
///
/// çŽ°åœ¨è®©æˆ‘ä»¬å¼€å§‹å®žçŽ°å±€éƒ¨å‡½æ•°çš„è½¬æ¢å§ï¼ðŸš€
///
/// ================================================================================

///|
test "Local Function Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup builtin functions
  typecheck_ctx.func_types.set("print_int", Function([Int], Unit))
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })
  // Typecheck ctx need to know about 'foo' ahead of time.
  // So that we can call `check_top_function` directly.
  typecheck_ctx.func_types.set("foo", Function([], Unit))
  knf_ctx.globals.set("print_int", Function([Int], Unit))

  let code = 
    #|fn foo() -> Unit {
    #|  let x = 1;
    #|  fn bar() -> Unit {
    #|    fn baz() -> Unit {
    #|      print_int(x);
    #|    }
    #|    baz();
    #|  }
    #|  bar();
    #|}
  let tokens = @lexer.tokenize(code)
  let (top_func, _) = @parser.parse_top_function(tokens)
  let typechecked_func = typecheck_ctx.check_top_function(top_func)
  let knf_func = knf_ctx.top_function_to_knf(typechecked_func)
  assert_true(knf_func.body.stmts.length() is 3)
  // Second statement is local function 'bar'
  assert_true(
    knf_func.body.stmts[1] is ClosureDef(closure) &&  // closure 'bar'
    closure.captured_vars.length() is 1 &&  // bar captures 'x'
    closure.body.stmts is [s1, _] &&
    s1 is ClosureDef(inner_closure) &&  // inner closure 'baz'
    inner_closure.captured_vars.length() is 1 // baz captures 'x' from bar
  )
}
