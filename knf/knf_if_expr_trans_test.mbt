/// ================================================================================
/// # ğŸ¯ If è¡¨è¾¾å¼çš„ KNF å˜æ¢ï¼šæ¡ä»¶æ§åˆ¶æµçš„å¤„ç†
///
/// åœ¨å®Œæˆäº†å—è¡¨è¾¾å¼çš„è½¬æ¢ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨è¦å¤„ç†**If è¡¨è¾¾å¼ (If Expression)** çš„è½¬æ¢ã€‚
/// è¿™æ˜¯ KNF å˜æ¢ä¸­çš„ä¸€ä¸ªé‡è¦æŒ‘æˆ˜ï¼Œå› ä¸ºå®ƒæ¶‰åŠåˆ°**æ¡ä»¶æ§åˆ¶æµ (Conditional Control Flow)** çš„å¤„ç†ã€‚
///
/// ## ğŸŒŸ ä»€ä¹ˆæ˜¯ If è¡¨è¾¾å¼ï¼Ÿ
///
/// **If è¡¨è¾¾å¼**æ˜¯æ¡ä»¶æ§åˆ¶æµçš„æ ¸å¿ƒï¼Œå®ƒä»¬çš„å½¢å¼æ˜¯ï¼š
///
/// ```
/// if (y > 0) {          // ç®€å• if-else
///   x = 10;
/// } else {
///   x = 20;
/// }
///
/// if (x < 5) {          // åªæœ‰ ifï¼Œæ²¡æœ‰ else
///   print_int(x);
/// }
///
/// if x > 10 {           // if-else if-else é“¾
///   y
/// } else if x > 5 {
///   y + 1
/// } else {
///   y + 2
/// }
/// ```
///
/// **If è¡¨è¾¾å¼çš„ç‰¹ç‚¹**ï¼š
/// - **æ¡ä»¶åˆ†æ”¯**ï¼šæ ¹æ®æ¡ä»¶é€‰æ‹©ä¸åŒçš„æ‰§è¡Œè·¯å¾„
/// - **åµŒå¥—ç»“æ„**ï¼šæ”¯æŒ else if çš„åµŒå¥—ç»“æ„
/// - **å¯é€‰ else**ï¼šelse å—æ˜¯å¯é€‰çš„
/// - **è¡¨è¾¾å¼å€¼**ï¼šæ•´ä¸ª if è¡¨è¾¾å¼æœ‰è¿”å›å€¼
///
/// ## ğŸ” If è¡¨è¾¾å¼çš„ç»“æ„å·®å¼‚
///
/// If è¡¨è¾¾å¼åœ¨è¯­æ³•æ ‘å’Œ KNF ä¸­çš„ç»“æ„å­˜åœ¨é‡è¦å·®å¼‚ï¼š
///
/// ### è¯­æ³•æ ‘ä¸­çš„ç»“æ„
/// ```
/// IfExpr {
///   cond: Expr,
///   then_block: BlockExpr,
///   else_block: Either[IfExpr, BlockExpr]?  // å…³é”®å·®å¼‚
/// }
/// ```
///
/// **å…³é”®ç‰¹ç‚¹**ï¼š
/// - `else_block` æ˜¯ `Either` ç±»å‹
/// - `Left(IfExpr)` è¡¨ç¤º else if
/// - `Right(BlockExpr)` è¡¨ç¤º else å—
/// - `None` è¡¨ç¤ºæ²¡æœ‰ else
///
/// ### KNF ä¸­çš„ç»“æ„
/// ```
/// If(cond, KnfBlock, KnfBlock)  // ç»Ÿä¸€ç»“æ„
/// ```
///
/// **å…³é”®ç‰¹ç‚¹**ï¼š
/// - ä¸¤ä¸ª `KnfBlock`ï¼šthen å—å’Œ else å—
/// - else if è¢«åµŒå¥—åˆ° else å—ä¸­
/// - ç»“æ„æ›´åŠ ç»Ÿä¸€å’Œç®€åŒ–
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `if_expr_to_knf` å‡½æ•°
///
/// åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œä½ éœ€è¦å®ç° `Context::if_expr_to_knf` å‡½æ•°ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// If è¡¨è¾¾å¼çš„è½¬æ¢åˆ†ä¸ºä¸‰ä¸ªä¸»è¦æ­¥éª¤ï¼š
///
/// 1. **å¤„ç†æ¡ä»¶**ï¼šä½¿ç”¨ `expr_to_knf` å¤„ç†æ¡ä»¶è¡¨è¾¾å¼
/// 2. **å¤„ç† then å—**ï¼šä½¿ç”¨ `block_expr_to_knf` å¤„ç† then å—
/// 3. **å¤„ç† else å—**ï¼šæ ¹æ® else å—çš„ç±»å‹è¿›è¡Œä¸åŒå¤„ç†
///
/// ### ğŸ”§ å…³é”®å®ç°ç»†èŠ‚
///
/// #### æ¡ä»¶å¤„ç†
/// ```
/// let (cond_stmts, cond_knf_expr) = self.expr_to_knf(if_expr.cond)
/// stmts.append(cond_stmts)
/// ```
///
/// **å…³é”®ç‚¹**ï¼š
/// - ä½¿ç”¨ `expr_to_knf` å¤„ç†æ¡ä»¶
/// - åˆå¹¶æ¡ä»¶å¯èƒ½äº§ç”Ÿçš„è¯­å¥
/// - æ¡ä»¶è¡¨è¾¾å¼ä½œä¸º if çš„ç¬¬ä¸€ä¸ªå‚æ•°
///
/// #### Then å—å¤„ç†
/// ```
/// let then_knf_block = self.block_expr_to_knf(if_expr.then_block)
/// ```
///
/// **å…³é”®ç‚¹**ï¼š
/// - ä½¿ç”¨ `block_expr_to_knf` å¤„ç† then å—
/// - then å—æ€»æ˜¯å­˜åœ¨çš„
/// - ç»“æœç›´æ¥ä½œä¸º if çš„ç¬¬äºŒä¸ªå‚æ•°
///
/// #### Else å—å¤„ç†ï¼ˆæ ¸å¿ƒæŒ‘æˆ˜ï¼‰
/// ```
/// match if_expr.else_block {
///   Some(Left(else_if_expr)) => {
///     // å¤„ç† else ifï¼šé€’å½’è°ƒç”¨ if_expr_to_knf
///     let (else_stmts, nested_if_knf) = self.if_expr_to_knf(else_if_expr)
///     stmts.append(else_stmts)
///     KnfBlock::{ stmts: [KnfStmt::ExprStmt(nested_if_knf)] }
///   }
///   Some(Right(else_block_expr)) => {
///     // å¤„ç† else å—ï¼šä½¿ç”¨ block_expr_to_knf
///     self.block_expr_to_knf(else_block_expr)
///   }
///   None => {
///     // æ²¡æœ‰ elseï¼šåˆ›å»ºç©ºçš„ KnfBlock
///     KnfBlock::{ stmts: [] }
///   }
/// }
/// ```
///
/// **å…³é”®ç‚¹**ï¼š
/// - **else if å¤„ç†**ï¼šé€’å½’è°ƒç”¨ `if_expr_to_knf`ï¼Œå°†ç»“æœåŒ…è£…ä¸º `ExprStmt`
/// - **else å—å¤„ç†**ï¼šä½¿ç”¨ `block_expr_to_knf` ç›´æ¥å¤„ç†
/// - **æ—  else å¤„ç†**ï¼šåˆ›å»ºç©ºçš„ `KnfBlock`
/// - **åµŒå¥—ç»“æ„**ï¼šelse if è¢«åµŒå¥—åˆ° else å—ä¸­
///
/// ## ğŸš€ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// è¿™ä¸ªæµ‹è¯•æ–‡ä»¶åŒ…å«äº†ä¸‰ç§ If è¡¨è¾¾å¼çš„è½¬æ¢ï¼š
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼šç®€å• if-else
/// ```
/// if (y > 0) {
///   x = 10;
/// } else {
///   x = 20;
/// }
/// ```
///
/// **è½¬æ¢ç»“æœ**ï¼š
/// - æ¡ä»¶ï¼š`Binary(GT, y, tmp)`ï¼ˆå…¶ä¸­ tmp æ˜¯ 0 çš„ä¸´æ—¶å˜é‡ï¼‰
/// - Then å—ï¼š`[Assign(x, Int(10))]`
/// - Else å—ï¼š`[Assign(x, Int(20))]`
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼šåªæœ‰ ifï¼Œæ²¡æœ‰ else
/// ```
/// if (x < 5) {
///   print_int(x);
/// }
/// ```
///
/// **è½¬æ¢ç»“æœ**ï¼š
/// - æ¡ä»¶ï¼š`Binary(LT, x, tmp)`ï¼ˆå…¶ä¸­ tmp æ˜¯ 5 çš„ä¸´æ—¶å˜é‡ï¼‰
/// - Then å—ï¼š`[ExprStmt(Call(print_int, [x]))]`
/// - Else å—ï¼š`[]`ï¼ˆç©ºå—ï¼‰
///
/// ### æµ‹è¯•ç”¨ä¾‹ 3ï¼šif-else if-else é“¾
/// ```
/// if x > 10 {
///   y
/// } else if x > 5 {
///   y + 1
/// } else {
///   y + 2
/// }
/// ```
///
/// **è½¬æ¢ç»“æœ**ï¼š
/// - å¤–å±‚æ¡ä»¶ï¼š`Binary(GT, x, tmp1)`ï¼ˆå…¶ä¸­ tmp1 æ˜¯ 10 çš„ä¸´æ—¶å˜é‡ï¼‰
/// - Then å—ï¼š`[ExprStmt(Ident(y))]`
/// - Else å—ï¼š`[ExprStmt(If(nested_cond, nested_then, nested_else))]`
/// - åµŒå¥—æ¡ä»¶ï¼š`Binary(GT, x, tmp2)`ï¼ˆå…¶ä¸­ tmp2 æ˜¯ 5 çš„ä¸´æ—¶å˜é‡ï¼‰
///
/// **å…³é”®è§‚å¯Ÿ**ï¼š
/// - else if è¢«è½¬æ¢ä¸ºåµŒå¥—çš„ If è¡¨è¾¾å¼
/// - åµŒå¥—çš„ If è¢«åŒ…è£…ä¸º `ExprStmt`
/// - ä¿æŒäº†åŸå§‹çš„åµŒå¥—ç»“æ„
///
/// ## ğŸ’¡ å®ç°æç¤º
///
/// 1. **æ¡ä»¶å¤„ç†**ï¼šä½¿ç”¨ `expr_to_knf` å¤„ç†æ¡ä»¶è¡¨è¾¾å¼
/// 2. **Then å—å¤„ç†**ï¼šä½¿ç”¨ `block_expr_to_knf` å¤„ç† then å—
/// 3. **Else å—åˆ†å‘**ï¼šä½¿ç”¨ `match` å¤„ç† `Either` ç±»å‹
/// 4. **é€’å½’å¤„ç†**ï¼šå¯¹ else if ä½¿ç”¨é€’å½’è°ƒç”¨
/// 5. **åµŒå¥—åŒ…è£…**ï¼šå°†åµŒå¥—çš„ if åŒ…è£…ä¸º `ExprStmt`
///
/// ## ğŸ”® è®¾è®¡æ€æƒ³
///
/// If è¡¨è¾¾å¼çš„å¤„ç†ä½“ç°äº†ä»¥ä¸‹è®¾è®¡æ€æƒ³ï¼š
///
/// - **ç»Ÿä¸€ç»“æ„**ï¼šå°†å¤æ‚çš„ else if é“¾è½¬æ¢ä¸ºç»Ÿä¸€çš„ If ç»“æ„
/// - **é€’å½’å¤„ç†**ï¼šä½¿ç”¨é€’å½’å¤„ç†åµŒå¥—çš„ else if
/// - **åµŒå¥—åŒ…è£…**ï¼šå°†åµŒå¥—ç»“æ„åŒ…è£…ä¸ºè¡¨è¾¾å¼è¯­å¥
/// - **ç®€åŒ–è¡¨ç¤º**ï¼šåœ¨ KNF ä¸­ç®€åŒ–æ¡ä»¶æ§åˆ¶æµçš„è¡¨ç¤º
///
/// ## ğŸ¯ å¼€å§‹å®ç°å§ï¼
///
/// è¿™æ˜¯æ¡ä»¶æ§åˆ¶æµå¤„ç†çš„é˜¶æ®µï¼é€šè¿‡å®ç° `if_expr_to_knf` å‡½æ•°ï¼Œ
/// æˆ‘ä»¬å°†å®Œæˆæ¡ä»¶åˆ†æ”¯çš„å¤„ç†ï¼Œä¸ºåç»­æ›´å¤æ‚çš„æ§åˆ¶æµå¤„ç†å¥ å®šåŸºç¡€ã€‚
///
/// **å‡†å¤‡å¥½å¤„ç†æ¡ä»¶æ§åˆ¶æµäº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å®ç°ï¼**
/// ================================================================================

///|
test "If Expr Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup type environment for testing
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: true })
  typecheck_ctx.type_env.set("y", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })

  // Setup knf context
  let _ = knf_ctx.add_new_name("x", Int)
  let _ = knf_ctx.add_new_name("y", Int)
  knf_ctx.globals.set("print_int", Function([Int], Unit))

  // Test 1: Simple if-else expression: if (y > 0) { x = 10; } else { x = 20; }
  let code1 =
    #|if (y > 0) {
    #|  x = 10;
    #|} else {
    #|  x = 20;
    #|}
  let tokens1 = @lexer.tokenize(code1)
  let (if_expr1, _) = @parser.parse_if_expr(tokens1)
  let checked_if_expr1 = typecheck_ctx.check_if_expr(if_expr1)
  let (stmts1, knf_if_expr1) = knf_ctx.if_expr_to_knf(checked_if_expr1)

  // Test 1: Check that condition generates a statement for the literal 0
  assert_true(stmts1.length() is 1)
  assert_true(
    stmts1[0] is Let(tmp_name, Int, Int(0)) && tmp_name is { id: "tmp", .. },
  )

  // Test 1: Check the if expression structure
  assert_true(
    knf_if_expr1 is If(cond, then_block, else_block) &&
    cond is Binary(GT, y_name, tmp_cond) &&
    y_name is { id: "y", .. } &&
    tmp_cond is { id: "tmp", .. } &&
    then_block.stmts.length() is 1 &&
    then_block.stmts[0] is Assign(x_name1, Int(10)) &&
    x_name1 is { id: "x", .. } &&
    else_block.stmts.length() is 1 &&
    else_block.stmts[0] is Assign(x_name2, Int(20)) &&
    x_name2 is { id: "x", .. },
  )

  // Test 2: If without else: if (x < 5) { print_int(x); }
  let code2 =
    #|if (x < 5) {
    #|  print_int(x);
    #|}
  let tokens2 = @lexer.tokenize(code2)
  let (if_expr2, _) = @parser.parse_if_expr(tokens2)
  let checked_if_expr2 = typecheck_ctx.check_if_expr(if_expr2)
  let (stmts2, knf_if_expr2) = knf_ctx.if_expr_to_knf(checked_if_expr2)

  // Test 2: Check that condition generates a statement for the literal 5
  assert_true(stmts2.length() is 1)
  assert_true(
    stmts2[0] is Let(tmp_name2, Int, Int(5)) &&
    tmp_name2 is { id: "tmp", slot: 1 },
  )

  // Test 2: Check the if expression structure (no else block)
  assert_true(
    knf_if_expr2 is If(cond2, then_block2, else_block2) &&
    cond2 is Binary(LT, x_name3, tmp_cond2) &&
    x_name3 is { id: "x", .. } &&
    tmp_cond2 is { id: "tmp", slot: 1 } &&
    then_block2.stmts.length() is 1 &&
    then_block2.stmts[0] is ExprStmt(Call(print_func, [x_arg])) &&
    print_func is { id: "print_int", .. } &&
    x_arg is { id: "x", .. } &&
    else_block2.stmts.is_empty(),
  )

  // Test 3: If-else if-else chain
  let code3 =
    #|if x > 10 {
    #|  y
    #|} else if x > 5 {
    #|  y + 1
    #|} else {
    #|  y + 2
    #|}
  let tokens3 = @lexer.tokenize(code3)
  let (if_expr3, _) = @parser.parse_if_expr(tokens3)
  let checked_if_expr3 = typecheck_ctx.check_if_expr(if_expr3)
  let (stmts3, knf_if_expr3) = knf_ctx.if_expr_to_knf(checked_if_expr3)

  // Test 3: Check that condition generates a statement for the literal 10
  assert_true(stmts3.length() is 2)
  assert_true(
    stmts3 is [s1, s2] &&
    s1 is Let(_, Int, Int(10)) &&
    s2 is Let(_, Int, Int(5)),
  )
  assert_true(
    knf_if_expr3 is If(cond3, then_block3, else_block3) &&
    cond3 is Binary(GT, _, _) &&
    then_block3.stmts is [_] &&
    else_block3.stmts is [ExprStmt(e1)] &&
    e1 is If(nested_cond, _, _) &&
    nested_cond is Binary(GT, _, _),
  )
}
