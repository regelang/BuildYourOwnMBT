/// ================================================================================
/// # ğŸ”§ Apply è¡¨è¾¾å¼çš„ KNF è½¬æ¢
///
/// ## ğŸ¯ ä»€ä¹ˆæ˜¯ Apply è¡¨è¾¾å¼ï¼Ÿ
///
/// Apply è¡¨è¾¾å¼æ˜¯ç¼–ç¨‹è¯­è¨€ä¸­ç”¨äºè®¿é—®å’Œè°ƒç”¨çš„è¡¨è¾¾å¼ï¼Œå®ƒä»¬åŒ…æ‹¬ï¼š
/// - åŸå­è¡¨è¾¾å¼ï¼ˆAtomExprï¼‰
/// - æ•°ç»„è®¿é—®ï¼ˆArrayAccessï¼‰
/// - å­—æ®µè®¿é—®ï¼ˆFieldAccessï¼‰
/// - å‡½æ•°è°ƒç”¨ï¼ˆCallï¼‰
///
/// Apply è¡¨è¾¾å¼çš„ç‰¹ç‚¹ï¼š
/// - æ”¯æŒé“¾å¼è®¿é—®ï¼ˆå¦‚ `arr[0][1]`ï¼‰
/// - æ”¯æŒåµŒå¥—è°ƒç”¨ï¼ˆå¦‚ `f(g(x))`ï¼‰
/// - éœ€è¦é€’å½’å¤„ç†å­è¡¨è¾¾å¼
/// - å¯èƒ½äº§ç”Ÿå¤æ‚çš„ä¸­é—´è¯­å¥
///
/// ## ğŸ” ç»“æ„å·®å¼‚åˆ†æ
///
/// åœ¨è¯­æ³•æ ‘ä¸­ï¼ŒApply è¡¨è¾¾å¼çš„ç»“æ„ç›¸å¯¹å¤æ‚ï¼š
/// - `AtomExpr`: åŸå­è¡¨è¾¾å¼
/// - `ArrayAccess`: æ•°ç»„è®¿é—®ï¼ˆApplyExpr, Exprï¼‰
/// - `FieldAccess`: å­—æ®µè®¿é—®ï¼ˆApplyExpr, Stringï¼‰
/// - `Call`: å‡½æ•°è°ƒç”¨ï¼ˆApplyExpr, Array[Expr]ï¼‰
///
/// åœ¨ KNF ä¸­ï¼ŒApply è¡¨è¾¾å¼è¢«è½¬æ¢ä¸ºï¼š
/// - `AtomExpr`: ç›´æ¥è½¬æ¢ä¸º KNF åŸå­è¡¨è¾¾å¼
/// - `ArrayAccess`: è½¬æ¢ä¸º `ArrayAccess(Name, Name)`
/// - `FieldAccess`: è½¬æ¢ä¸º `FieldAccess(Name, String)`
/// - `Call`: è½¬æ¢ä¸º `Call(Name, Array[Name])`
///
/// ## ğŸ› ï¸ å®ç°æ€è·¯
///
/// å®ç° `apply_expr_to_knf` å‡½æ•°éœ€è¦å››ä¸ªä¸»è¦åˆ†æ”¯ï¼š
///
/// ### 1. AtomExpr å¤„ç†
/// - ç›´æ¥è°ƒç”¨ `atom_expr_to_knf` è½¬æ¢
/// - è¿™æ˜¯æœ€ç®€å•çš„æƒ…å†µï¼Œä¸éœ€è¦é¢å¤–å¤„ç†
///
/// ### 2. ArrayAccess å¤„ç†
/// - é€’å½’è½¬æ¢æ•°ç»„è¡¨è¾¾å¼å’Œç´¢å¼•è¡¨è¾¾å¼
/// - ä½¿ç”¨ `expr_to_knf_name` åˆ›å»ºä¸´æ—¶å˜é‡
/// - åˆå¹¶æ‰€æœ‰è¯­å¥å¹¶è¿”å› `ArrayAccess`
///
/// ### 3. FieldAccess å¤„ç†
/// - é€’å½’è½¬æ¢ç»“æ„ä½“è¡¨è¾¾å¼
/// - ä½¿ç”¨ `expr_to_knf_name` åˆ›å»ºä¸´æ—¶å˜é‡
/// - è¿”å› `FieldAccess`
///
/// ### 4. Call å¤„ç†
/// - é€’å½’è½¬æ¢è¢«è°ƒç”¨è¡¨è¾¾å¼å’Œæ‰€æœ‰å‚æ•°
/// - ä¸ºæ¯ä¸ªè¡¨è¾¾å¼åˆ›å»ºä¸´æ—¶å˜é‡
/// - åˆå¹¶æ‰€æœ‰è¯­å¥å¹¶è¿”å› `Call`
///
/// ## ğŸ”§ å…³é”®å®ç°ç»†èŠ‚
///
/// ### é€’å½’å¤„ç†
/// Apply è¡¨è¾¾å¼éœ€è¦é€’å½’å¤„ç†å­è¡¨è¾¾å¼ï¼š
/// - æ•°ç»„è®¿é—®ï¼š`arr[0][1]` éœ€è¦å…ˆå¤„ç† `arr[0]`ï¼Œå†å¤„ç† `[1]`
/// - å­—æ®µè®¿é—®ï¼š`point.x.y` éœ€è¦å…ˆå¤„ç† `point.x`ï¼Œå†å¤„ç† `.y`
/// - å‡½æ•°è°ƒç”¨ï¼š`f(g(x))` éœ€è¦å…ˆå¤„ç† `g(x)`ï¼Œå†å¤„ç† `f(...)`
///
/// ### ä¸´æ—¶å˜é‡åˆ›å»º
/// ä½¿ç”¨ `expr_to_knf_name` ä¸ºå¤æ‚è¡¨è¾¾å¼åˆ›å»ºä¸´æ—¶å˜é‡ï¼š
/// - ç¡®ä¿æ¯ä¸ªå­è¡¨è¾¾å¼éƒ½æœ‰å¯¹åº”çš„ Name
/// - é¿å…é‡å¤è®¡ç®—
/// - ä¿æŒ KNF çš„åŸå­æ€§
///
/// ### è¯­å¥åˆå¹¶
/// éœ€è¦æ­£ç¡®åˆå¹¶æ‰€æœ‰å­è¡¨è¾¾å¼äº§ç”Ÿçš„è¯­å¥ï¼š
/// - æŒ‰ç…§æ‰§è¡Œé¡ºåºåˆå¹¶è¯­å¥
/// - ç¡®ä¿ä¾èµ–å…³ç³»æ­£ç¡®
/// - é¿å…è¯­å¥é¡ºåºé”™è¯¯
///
/// ### ç±»å‹è½¬æ¢
/// éœ€è¦æ­£ç¡®è½¬æ¢è¡¨è¾¾å¼çš„ç±»å‹ï¼š
/// - ä½¿ç”¨ `typekind_to_knf` è½¬æ¢ç±»å‹
/// - ç¡®ä¿ç±»å‹ä¸€è‡´æ€§
/// - æ”¯æŒå¤æ‚ç±»å‹ï¼ˆæ•°ç»„ã€ç»“æ„ä½“ã€å‡½æ•°ï¼‰
///
/// ## ğŸ“ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼šæ•°ç»„è®¿é—®
/// arr[3]
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. æ•°ç»„è¡¨è¾¾å¼ `arr` æ˜¯åŸå­è¡¨è¾¾å¼ï¼Œç›´æ¥è½¬æ¢
/// 2. ç´¢å¼•è¡¨è¾¾å¼ `3` éœ€è¦åˆ›å»ºä¸´æ—¶å˜é‡
/// 3. è¿”å› `ArrayAccess(arr_name, tmp_name)`
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼šå˜é‡ç´¢å¼•
/// arr[x]
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. æ•°ç»„è¡¨è¾¾å¼ `arr` æ˜¯åŸå­è¡¨è¾¾å¼ï¼Œç›´æ¥è½¬æ¢
/// 2. ç´¢å¼•è¡¨è¾¾å¼ `x` æ˜¯åŸå­è¡¨è¾¾å¼ï¼Œç›´æ¥è½¬æ¢
/// 3. è¿”å› `ArrayAccess(arr_name, x_name)`
///
/// ### æµ‹è¯•ç”¨ä¾‹ 3ï¼šå­—æ®µè®¿é—®
/// point.x
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. ç»“æ„ä½“è¡¨è¾¾å¼ `point` æ˜¯åŸå­è¡¨è¾¾å¼ï¼Œç›´æ¥è½¬æ¢
/// 2. å­—æ®µå `x` ç›´æ¥ä½¿ç”¨
/// 3. è¿”å› `FieldAccess(point_name, "x")`
///
/// ### æµ‹è¯•ç”¨ä¾‹ 4ï¼šå‡½æ•°è°ƒç”¨
/// max(a + b, a - b)
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¢«è°ƒç”¨è¡¨è¾¾å¼ `max` æ˜¯åŸå­è¡¨è¾¾å¼ï¼Œç›´æ¥è½¬æ¢
/// 2. å‚æ•° `a + b` éœ€è¦åˆ›å»ºä¸´æ—¶å˜é‡
/// 3. å‚æ•° `a - b` éœ€è¦åˆ›å»ºä¸´æ—¶å˜é‡
/// 4. è¿”å› `Call(max_name, [tmp1, tmp2])`
///
/// ## ğŸ’¡ è®¾è®¡æ€æƒ³
///
/// ### é€’å½’å¤„ç†
/// Apply è¡¨è¾¾å¼æ”¯æŒé“¾å¼è®¿é—®ï¼Œéœ€è¦é€’å½’å¤„ç†æ¯ä¸ªå­è¡¨è¾¾å¼ã€‚
///
/// ### åŸå­åŒ–
/// å°†å¤æ‚è¡¨è¾¾å¼åˆ†è§£ä¸ºåŸå­æ“ä½œï¼Œä½¿ç”¨ä¸´æ—¶å˜é‡å­˜å‚¨ä¸­é—´ç»“æœã€‚
///
/// ### ç±»å‹å®‰å…¨
/// ç¡®ä¿æ¯ä¸ªè¡¨è¾¾å¼éƒ½æœ‰æ­£ç¡®çš„ç±»å‹ï¼Œæ”¯æŒå¤æ‚ç±»å‹ç³»ç»Ÿã€‚
///
/// ### è¯­å¥é¡ºåº
/// æŒ‰ç…§æ‰§è¡Œé¡ºåºåˆå¹¶è¯­å¥ï¼Œç¡®ä¿ä¾èµ–å…³ç³»æ­£ç¡®ã€‚
///
/// ## ğŸš€ å®ç°æŒ‘æˆ˜
///
/// ### é€’å½’å¤æ‚æ€§
/// Apply è¡¨è¾¾å¼å¯èƒ½åµŒå¥—å¾ˆæ·±ï¼Œéœ€è¦æ­£ç¡®å¤„ç†é€’å½’è°ƒç”¨ã€‚
///
/// ### è¯­å¥åˆå¹¶
/// éœ€è¦æ­£ç¡®åˆå¹¶å¤šä¸ªå­è¡¨è¾¾å¼äº§ç”Ÿçš„è¯­å¥ã€‚
///
/// ### ä¸´æ—¶å˜é‡ç®¡ç†
/// éœ€è¦ä¸ºå¤æ‚è¡¨è¾¾å¼åˆ›å»ºä¸´æ—¶å˜é‡ï¼Œé¿å…å‘½åå†²çªã€‚
///
/// ### ç±»å‹è½¬æ¢
/// éœ€è¦æ­£ç¡®è½¬æ¢å„ç§å¤æ‚ç±»å‹ã€‚
///
/// ## ğŸ¯ å®ç°ç›®æ ‡
///
/// å®Œæˆ `apply_expr.mbt` ä¸­çš„ `apply_expr_to_knf` å‡½æ•°ï¼Œå®ç° Apply è¡¨è¾¾å¼çš„ KNF è½¬æ¢ã€‚
/// å‡½æ•°åº”è¯¥ï¼š
/// 1. æ­£ç¡®å¤„ç†å››ç§ Apply è¡¨è¾¾å¼ç±»å‹
/// 2. é€’å½’å¤„ç†æ‰€æœ‰å­è¡¨è¾¾å¼
/// 3. æ­£ç¡®åˆ›å»ºä¸´æ—¶å˜é‡
/// 4. æ­£ç¡®åˆå¹¶è¯­å¥
/// 5. æ”¯æŒé“¾å¼è®¿é—®å’ŒåµŒå¥—è°ƒç”¨
///
/// ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹å®ç° Apply è¡¨è¾¾å¼çš„è½¬æ¢å§ï¼ğŸš€
///
/// ================================================================================

///|
test "Apply Expr Knf Transformation Test" {
  // Prelude Parts
  // set a, b, x, arr, point, max type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("a", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("b", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: false })
  let point_struct_def : @typecheck.StructDef = {
    name: "Point",
    fields: [
      { name: "x", ty: { kind: Int, mutable: false } },
      { name: "y", ty: { kind: Int, mutable: false } },
    ],
  }
  typecheck_ctx.struct_defs.set("Point", point_struct_def)
  typecheck_ctx.type_env.set("arr", { kind: Array(Int), mutable: false })
  typecheck_ctx.type_env.set("point", { kind: Struct("Point"), mutable: false })
  typecheck_ctx.type_env.set("max", {
    kind: Function([Int, Int], Int),
    mutable: false,
  })
  let knf_ctx = Context::new()
  knf_ctx.globals.set("max", Function([Int, Int], Int))
  let _ = knf_ctx.add_new_name("a", Int)
  let _ = knf_ctx.add_new_name("b", Int)
  let _ = knf_ctx.add_new_name("x", Int)
  let _ = knf_ctx.add_new_name("arr", Array(Int))
  let _ = knf_ctx.add_new_name("point", Struct("Point"))

  // Test Parts
  let code =
    #|arr[3]
    #|arr[x]
    #|point.x
    #|max(a + b, a - b)
  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)
  // Parse and transform `arr[3]`.
  let (e, tok_view) = @parser.parse_apply_expr(tokens)
  let e = typecheck_ctx.check_apply_expr(e)
  let (stmts, knf_expr) = knf_ctx.apply_expr_to_knf(e)
  assert_true(
    stmts is [s1] &&
    s1 is Let(n1, Int, Int(3)) &&
    knf_expr is ArrayAccess(arr_name, index_name) &&
    arr_name is { id: "arr", .. } &&
    index_name == n1,
  )
  // Parse and transform `arr[x]`.
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (stmts, knf_expr) = knf_ctx.apply_expr_to_knf(e)
  assert_true(
    stmts is [] &&
    knf_expr is ArrayAccess(arr_name, index_name) &&
    arr_name is { id: "arr", .. } &&
    index_name is { id: "x", .. },
  )
  // Parse and transform `point.x`.
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (stmts, knf_expr) = knf_ctx.apply_expr_to_knf(e)
  assert_true(
    stmts is [] &&
    knf_expr is FieldAccess(struct_name, field_name) &&
    struct_name is { id: "point", .. } &&
    field_name is "x",
  )
  // Parse and transform `max(a + b, a - b)`.
  let (e, _) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (stmts, knf_expr) = knf_ctx.apply_expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Int, Binary(Add, l1, r1)) &&
    l1.id is "a" &&
    r1.id is "b" &&
    s2 is Let(n2, Int, Binary(Sub, l2, r2)) &&
    l2.id is "a" &&
    r2.id is "b" &&
    knf_expr is Call(callee_name, arg_names) &&
    callee_name.id is "max" &&
    arg_names == [n1, n2],
  )
}
