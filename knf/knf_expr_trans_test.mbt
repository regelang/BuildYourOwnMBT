/// ================================================================================
/// # ğŸ¯ è¡¨è¾¾å¼ KNF å˜æ¢çš„ç»¼åˆæµ‹è¯•ï¼šä¼‘æ¯ä¸€ä¸‹
///
/// åœ¨å®Œæˆäº†å„ç§è¡¨è¾¾å¼çš„è½¬æ¢ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨è¦è¿›è¡Œä¸€ä¸ª**ç»¼åˆæµ‹è¯•**ã€‚
/// è¿™æ˜¯ä¸€ä¸ª"ä¼‘æ¯ä¸€ä¸‹"çš„æ—¶åˆ»ï¼Œè®©æˆ‘ä»¬æ¥éªŒè¯ä¹‹å‰å®ç°çš„æ‰€æœ‰è¡¨è¾¾å¼è½¬æ¢åŠŸèƒ½
/// æ˜¯å¦èƒ½å¤ŸååŒå·¥ä½œï¼Œå¤„ç†æ›´å¤æ‚çš„çœŸå®åœºæ™¯ã€‚
///
/// ## ğŸŒŸ æµ‹è¯•å†…å®¹
///
/// è¿™ä¸ªæµ‹è¯•åŒ…å«äº†å¤æ‚çš„è¡¨è¾¾å¼è½¬æ¢ï¼š
/// - `max(a, b) + min(a, b)`ï¼šå‡½æ•°è°ƒç”¨çš„ç»„åˆ
/// - `sum(arr) / arr.length()`ï¼šå¤æ‚è¡¨è¾¾å¼çš„åˆ†è§£
///
/// å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‡½æ•°è°ƒç”¨å¤„ç†ã€å‚æ•°ä¼ é€’ã€ä¸´æ—¶å˜é‡åˆ›å»ºç­‰å®ç°ã€‚
///
/// **å‡†å¤‡å¥½éªŒè¯ä½ çš„å®ç°äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹æµ‹è¯•ï¼**
/// ================================================================================

///|
test "Expr Knf Transformation Test" {
  // Prelucde Parts
  // set a, b, arr, sum, point, mat, sqrt type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  let point_struct_def : @typecheck.StructDef = {
    name: "Point",
    fields: [
      { name: "x", ty: { kind: Int, mutable: false } },
      { name: "y", ty: { kind: Int, mutable: false } },
    ],
  }
  typecheck_ctx.struct_defs.set("Point", point_struct_def)
  typecheck_ctx.type_env.set("a", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("b", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("arr", { kind: Array(Int), mutable: false })
  typecheck_ctx.type_env.set("point", { kind: Struct("Point"), mutable: false })
  typecheck_ctx.type_env.set("sum", {
    kind: Function([Array(Int)], Int),
    mutable: false,
  })
  typecheck_ctx.type_env.set("max", {
    kind: Function([Double, Double], Double),
    mutable: false,
  })
  typecheck_ctx.type_env.set("min", {
    kind: Function([Double, Double], Double),
    mutable: false,
  })
  let knf_ctx = @knf.Context::new()
  knf_ctx.globals.set("max", Function([Double, Double], Double))
  knf_ctx.globals.set("min", Function([Double, Double], Double))
  knf_ctx.globals.set("sum", Function([Array(Int)], Int))
  let _ = knf_ctx.add_new_name("a", Double)
  let _ = knf_ctx.add_new_name("b", Double)
  let _ = knf_ctx.add_new_name("arr", Array(Int))

  // Test Parts
  let code =
    #|max(a, b) + min(a, b) ;
    #|sum(arr) / arr.length() ;
  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)
  // Parse and transform `max(a, b) + min(a, b)`
  let (e, _) = @parser.parse_expr(tokens)
  let e = typecheck_ctx.check_expr(e)
  let (stmts, knf_expr) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Double, Call({ id: "max", .. }, [a1, a2])) &&
    s2 is Let(n2, Double, Call({ id: "min", .. }, [a3, a4])) &&
    a1 is { id: "a", .. } &&
    a2 is { id: "b", .. } &&
    a3 is { id: "a", .. } &&
    a4 is { id: "b", .. } &&
    knf_expr is Binary(Add, l, r) &&
    n1 == l &&
    n2 == r,
  )
}
