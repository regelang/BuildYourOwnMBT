/// ================================================================================
/// # ğŸ¯ åŸå­è¡¨è¾¾å¼çš„ KNF å˜æ¢ï¼šä»ç®€å•å¼€å§‹
///
/// åœ¨å®Œæˆäº†ç±»å‹å˜æ¢ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨è¦å¼€å§‹å¤„ç†è¡¨è¾¾å¼äº†ã€‚è¡¨è¾¾å¼æ˜¯ç¨‹åºä¸­æœ€åŸºæœ¬çš„è®¡ç®—å•å…ƒï¼Œ
/// è€Œ**åŸå­è¡¨è¾¾å¼ (Atom Expression)** åˆ™æ˜¯è¡¨è¾¾å¼ä¸­æœ€ç®€å•çš„å½¢å¼ã€‚
///
/// ## ğŸŒŸ ä»€ä¹ˆæ˜¯åŸå­è¡¨è¾¾å¼ï¼Ÿ
///
/// **åŸå­è¡¨è¾¾å¼**æ˜¯ä¸èƒ½å†è¿›ä¸€æ­¥åˆ†è§£çš„è¡¨è¾¾å¼ï¼Œå®ƒä»¬æ˜¯ç¨‹åºçš„åŸºæœ¬æ„å»ºå—ï¼š
///
/// - **å­—é¢é‡ (Literals)**ï¼š`42`ã€`3.14`ã€`true`ã€`"hello"`
/// - **æ ‡è¯†ç¬¦ (Identifiers)**ï¼š`x`ã€`y`ã€`z`ï¼ˆå˜é‡åï¼‰
/// - **æ‹¬å·è¡¨è¾¾å¼**ï¼š`(expr)`ï¼ˆè™½ç„¶åŒ…å«å­è¡¨è¾¾å¼ï¼Œä½†ä½œä¸ºæ•´ä½“å¤„ç†ï¼‰
/// - **æ•°ç»„å­—é¢é‡**ï¼š`[1, 2, 3]`
/// - **å…ƒç»„å­—é¢é‡**ï¼š`(a, b, c)`
/// - **ç»“æ„ä½“æ„é€ **ï¼š`Point::{ x: 1, y: 2 }`
///
/// åœ¨ KNF å˜æ¢ä¸­ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯å°†è¿™äº›åŸå­è¡¨è¾¾å¼è½¬æ¢ä¸º KNF å½¢å¼çš„è¡¨è¾¾å¼ã€‚
///
/// ## ğŸ” KNF ä¸­çš„è¡¨è¾¾å¼å½¢å¼
///
/// åœ¨ KNF ä¸­ï¼Œè¡¨è¾¾å¼è¢«ç®€åŒ–ä¸ºä»¥ä¸‹å‡ ç§åŸºæœ¬å½¢å¼ï¼š
///
/// ```moonbit
/// enum KnfExpr {
///   Unit                    // å•å…ƒç±»å‹
///   Int(Int)               // æ•´æ•°
///   Bool(Bool)             // å¸ƒå°”å€¼
///   Double(Double)         // æµ®ç‚¹æ•°
///   String(String)         // å­—ç¬¦ä¸²
///   Ident(Name)            // æ ‡è¯†ç¬¦ï¼ˆå˜é‡ï¼‰
///   // ... å…¶ä»–å¤æ‚è¡¨è¾¾å¼
/// }
/// ```
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç°ä¸¤ä¸ªå…³é”®å‡½æ•°
///
/// åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œä½ éœ€è¦å®Œæˆä¸¤ä¸ªé‡è¦çš„å‡½æ•°ï¼š
///
/// ### 1. `Context::lookup_name` å‡½æ•°
///
/// è¿™ä¸ªå‡½æ•°è´Ÿè´£åœ¨ KNF ä¸Šä¸‹æ–‡ä¸­æŸ¥æ‰¾å˜é‡åï¼Œå¹¶è¿”å›å¯¹åº”çš„ `Name` å’Œ `Type`ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
/// - é¦–å…ˆåœ¨å½“å‰ä½œç”¨åŸŸä¸­æŸ¥æ‰¾å˜é‡
/// - å¦‚æœæ‰¾ä¸åˆ°ï¼Œåˆ™åœ¨å…¨å±€å˜é‡ä¸­æŸ¥æ‰¾
/// - è¿”å›æ‰¾åˆ°çš„ `Name` å’Œ `Type`ï¼Œå¦‚æœæ‰¾ä¸åˆ°åˆ™è¿”å› `None`
///
/// **ä½œç”¨åŸŸå±‚æ¬¡ï¼š**
/// - **å±€éƒ¨ä½œç”¨åŸŸ**ï¼šå½“å‰å‡½æ•°å†…çš„å˜é‡
/// - **å…¨å±€ä½œç”¨åŸŸ**ï¼šé¡¶å±‚å®šä¹‰çš„å˜é‡å’Œå‡½æ•°
///
/// ### 2. `Context::atom_expr_to_knf` å‡½æ•°
///
/// è¿™ä¸ªå‡½æ•°è´Ÿè´£å°†ç±»å‹æ£€æŸ¥é˜¶æ®µçš„åŸå­è¡¨è¾¾å¼è½¬æ¢ä¸º KNF å½¢å¼çš„è¡¨è¾¾å¼ã€‚
///
/// **éœ€è¦å¤„ç†çš„åŸå­è¡¨è¾¾å¼ç±»å‹ï¼š**
/// - **å­—é¢é‡**ï¼šç›´æ¥è½¬æ¢ä¸ºå¯¹åº”çš„ KNF å­—é¢é‡
/// - **æ ‡è¯†ç¬¦**ï¼šé€šè¿‡ `lookup_name` æŸ¥æ‰¾ï¼Œè½¬æ¢ä¸º `KnfExpr::Ident`
/// - **æ‹¬å·è¡¨è¾¾å¼**ï¼šé€’å½’å¤„ç†å†…éƒ¨è¡¨è¾¾å¼
/// - **æ•°ç»„/å…ƒç»„/ç»“æ„ä½“**ï¼šå¤„ç†å¤åˆå­—é¢é‡
///
/// **è¿”å›å€¼ï¼š**
/// - `(Array[KnfStmt], KnfExpr)`ï¼šè¯­å¥åˆ—è¡¨å’Œ KNF è¡¨è¾¾å¼
/// - å¯¹äºç®€å•çš„åŸå­è¡¨è¾¾å¼ï¼Œè¯­å¥åˆ—è¡¨é€šå¸¸ä¸ºç©º
///
/// ## Questions : ä¸ºä»€ä¹ˆæ˜¯(Array[KnfStmt], KnfExpr)
///
/// å› ä¸ºä¸€ä¸ªè¡¨è¾¾å¼åœ¨ KNF å˜æ¢è¿‡ç¨‹ä¸­å¯èƒ½ä¼šç”Ÿæˆå¤šä¸ªè¯­å¥ï¼Œ
/// ä¾‹å¦‚`1 + 2 * 3`å¯èƒ½ä¼šè¢«æ‹†åˆ†æˆå¤šä¸ªä¸­é—´è®¡ç®—æ­¥éª¤ï¼Œ
///
/// ```
/// let temp1 = 2 * 3
/// let temp2 = 1
/// let result = temp2 + temp1
/// result
/// ```
///
/// è¿™é‡Œå‰é¢çš„ä¸‰ä¸ª`let`è¯­å¥å°±æ˜¯`Array[KnfStmt]`ï¼Œè€Œæœ€åçš„`result`å°±æ˜¯`KnfExpr`ã€‚
///
/// ## ğŸ› ï¸ ä¸Šä¸‹æ–‡ç®¡ç†è¯¦è§£
///
/// KNF é˜¶æ®µçš„ä¸Šä¸‹æ–‡ç®¡ç†ä¸ç±»å‹æ£€æŸ¥é˜¶æ®µæœ‰æ‰€ä¸åŒï¼š
///
/// ### ä½œç”¨åŸŸæ¨¡å‹
/// - **ç±»å‹æ£€æŸ¥é˜¶æ®µ**ï¼šæ¯ä¸ª Block æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ä½œç”¨åŸŸ
/// - **KNF é˜¶æ®µ**ï¼šæ•´ä¸ªå‡½æ•°ä½“æ˜¯ä¸€ä¸ªä½œç”¨åŸŸ
///
/// ### Name ç»“æ„
/// ```moonbit
/// struct Name {
///   id : String    // å˜é‡å
///   slot : Int     // ä½œç”¨åŸŸå±‚çº§ï¼ˆç”¨äºå¤„ç†å˜é‡é®è”½ï¼‰
/// }
/// ```
///
/// ### ç¯å¢ƒæŸ¥æ‰¾ç­–ç•¥
/// 1. **å±€éƒ¨æŸ¥æ‰¾**ï¼šåœ¨å½“å‰ä½œç”¨åŸŸä¸­æŸ¥æ‰¾
/// 2. **æ•è·æŸ¥æ‰¾**ï¼šå¦‚æœåœ¨å½“å‰ä½œç”¨åŸŸæ‰¾ä¸åˆ°ï¼Œå‘ä¸ŠæŸ¥æ‰¾çˆ¶ä½œç”¨åŸŸã€‚
/// 3. **å…¨å±€æŸ¥æ‰¾**ï¼šåœ¨å…¨å±€å˜é‡è¡¨ä¸­æŸ¥æ‰¾
///
/// ## ğŸš€ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// è¿™ä¸ªæµ‹è¯•æ–‡ä»¶åŒ…å«äº†å¤šç§åŸå­è¡¨è¾¾å¼çš„è½¬æ¢ï¼š
///
/// 1. **å­—é¢é‡è½¬æ¢**ï¼š`42` â†’ `Int(42)`ï¼Œ`3.14` â†’ `Double(3.14)`
/// 2. **æ ‡è¯†ç¬¦æŸ¥æ‰¾**ï¼š
///    - `x`ï¼šå…¨å±€å˜é‡ï¼Œslot = 0
///    - `y`ï¼šçˆ¶ä½œç”¨åŸŸå˜é‡ï¼Œslot = 0  
///    - `z`ï¼šå½“å‰ä½œç”¨åŸŸå˜é‡ï¼Œslot = 0
///
/// ## ğŸ’¡ å®ç°æç¤º
///
/// 1. **å­—é¢é‡å¤„ç†**ï¼šç›´æ¥æ˜ å°„åˆ°å¯¹åº”çš„ KNF å­—é¢é‡
/// 2. **æ ‡è¯†ç¬¦å¤„ç†**ï¼šä½¿ç”¨ `lookup_name` æŸ¥æ‰¾ï¼Œå¤„ç†æœªå®šä¹‰å˜é‡çš„é”™è¯¯
/// 3. **é”™è¯¯å¤„ç†**ï¼šå¯¹äºæœªå®šä¹‰çš„å˜é‡ï¼ŒæŠ›å‡º `KnfTransformError`
///
/// ## ğŸ¯ å¼€å§‹å®ç°å§ï¼
///
/// åŸå­è¡¨è¾¾å¼çš„è½¬æ¢æ˜¯ KNF å˜æ¢çš„åŸºç¡€ã€‚åªæœ‰æ­£ç¡®å®ç°äº†è¿™äº›ç®€å•çš„è½¬æ¢ï¼Œ
/// æˆ‘ä»¬æ‰èƒ½å¤„ç†æ›´å¤æ‚çš„è¡¨è¾¾å¼å’Œè¯­å¥ã€‚
///
/// **å‡†å¤‡å¥½å¼€å§‹ä½ çš„åŸå­è¡¨è¾¾å¼è½¬æ¢ä¹‹æ—…äº†å—ï¼Ÿè®©æˆ‘ä»¬ä¸€æ­¥æ­¥å®ç°è¿™äº›å‡½æ•°ï¼**
/// ================================================================================

///|
test "Simple Atom Expr Knf Transformation Test" {
  // set x, y, z type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("y", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("z", { kind: Bool, mutable: false })
  let knf_ctx = Context::new()
  knf_ctx.globals.set("x", Int)
  let _ = knf_ctx.add_new_name("y", Double)
  knf_ctx.enter_scope()
  let _ = knf_ctx.add_new_name("z", Bool)

  // Code parse, typecheck, knf transform
  let code =
    #|42 3.14 true "hello"
    #|x y z
  // Parse
  let tokens = @lexer.tokenize(code)
  let (e, tok_view) = @parser.parse_atom_expr(tokens)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Int(42))
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Double(3.14))
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Bool(true))
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is String("hello"))
  // find Global Ident `x`
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Ident({ id: "x", slot: 0 }))
  // find Parent Ident `y`
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Ident({ id: "y", slot: 0 }))
  // find Local Ident `z`
  let (e, _) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Ident({ id: "z", slot: 0 }))
}
