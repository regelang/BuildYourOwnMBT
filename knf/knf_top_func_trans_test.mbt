/// ================================================================================
/// # ðŸ”§ é¡¶å±‚å‡½æ•°çš„ KNF è½¬æ¢
///
/// ## ðŸŽ¯ ä»€ä¹ˆæ˜¯é¡¶å±‚å‡½æ•°ï¼Ÿ
///
/// é¡¶å±‚å‡½æ•°æ˜¯ç¨‹åºä¸­æœ€é¡¶å±‚çš„å‡½æ•°å®šä¹‰ï¼Œå®ƒä»¬å®šä¹‰å…¨å±€å¯è°ƒç”¨çš„å‡½æ•°ã€‚
/// é¡¶å±‚å‡½æ•°çš„åŸºæœ¬ç»“æž„æ˜¯ï¼š
/// fn function_name(param1: Type1, param2: Type2) -> ReturnType {
///   // å‡½æ•°ä½“
/// }
///
/// é¡¶å±‚å‡½æ•°çš„ç‰¹ç‚¹ï¼š
/// - å®šä¹‰äº†ä¸€ä¸ªæ–°çš„å‡½æ•°
/// - åŒ…å«å‚æ•°åˆ—è¡¨ã€è¿”å›žç±»åž‹å’Œå‡½æ•°ä½“
/// - å‡½æ•°ä½“æ˜¯ä¸€ä¸ª BlockExpr
/// - éœ€è¦åœ¨å…¨å±€ä½œç”¨åŸŸä¸­æ³¨å†Œå‡½æ•°ç­¾å
/// - å‡½æ•°å‚æ•°åœ¨å‡½æ•°ä½œç”¨åŸŸä¸­å®šä¹‰
///
/// ## ðŸ” ç»“æž„å·®å¼‚åˆ†æž
///
/// åœ¨è¯­æ³•æ ‘ä¸­ï¼Œé¡¶å±‚å‡½æ•°çš„ç»“æž„ç›¸å¯¹ç®€å•ï¼š
/// - `fname`: å‡½æ•°åç§°ï¼ˆStringï¼‰
/// - `param_list`: å‚æ•°åˆ—è¡¨ï¼ˆArray[Param]ï¼‰
/// - `ret_ty`: è¿”å›žç±»åž‹ï¼ˆTypeKindï¼‰
/// - `body`: å‡½æ•°ä½“ï¼ˆBlockExprï¼‰
///
/// åœ¨ KNF ä¸­ï¼Œé¡¶å±‚å‡½æ•°çš„ç»“æž„æ›´åŠ ç»Ÿä¸€ï¼š
/// - `KnfFunction`: åŒ…å« nameã€ret_tyã€paramsã€body çš„ç»“æž„ä½“
/// - `params`: å‚æ•°åˆ—è¡¨ï¼Œæ¯ä¸ªå‚æ•°åŒ…å«ï¼ˆNameï¼ŒTypeï¼‰
/// - `body`: å‡½æ•°ä½“ï¼ˆKnfBlockï¼‰
///
/// ## ðŸ› ï¸ å®žçŽ°æ€è·¯
///
/// å®žçŽ° `top_function_to_knf` å‡½æ•°éœ€è¦äº”ä¸ªä¸»è¦æ­¥éª¤ï¼š
///
/// ### 1. è¿›å…¥å‡½æ•°ä½œç”¨åŸŸ
/// - ä½¿ç”¨ `enter_scope()` åˆ›å»ºæ–°çš„ä½œç”¨åŸŸ
/// - ä¸ºå‡½æ•°å‚æ•°å’Œå±€éƒ¨å˜é‡æä¾›ç‹¬ç«‹çš„ä½œç”¨åŸŸ
///
/// ### 2. å‚æ•°å¤„ç†
/// - éåŽ†å‚æ•°åˆ—è¡¨ï¼Œä¸ºæ¯ä¸ªå‚æ•°åˆ›å»º Name
/// - ä½¿ç”¨ `typekind_to_knf` è½¬æ¢å‚æ•°ç±»åž‹
/// - å°†å‚æ•°æ³¨å†Œåˆ°å½“å‰ä½œç”¨åŸŸä¸­
/// - æ”¶é›†å‚æ•°ä¿¡æ¯ç”¨äºŽå‡½æ•°ç±»åž‹æž„é€ 
///
/// ### 3. è¿”å›žç±»åž‹è½¬æ¢
/// - ä½¿ç”¨ `typekind_to_knf` è½¬æ¢è¿”å›žç±»åž‹
/// - æž„é€ å‡½æ•°ç±»åž‹ `Function(param_types, ret_ty)`
///
/// ### 4. å‡½æ•°ä½“è½¬æ¢
/// - ä½¿ç”¨ `block_expr_to_knf` è½¬æ¢å‡½æ•°ä½“
/// - å‡½æ•°ä½“ä¸­çš„æ‰€æœ‰è¯­å¥éƒ½åœ¨å‡½æ•°ä½œç”¨åŸŸä¸­å¤„ç†
///
/// ### 5. é€€å‡ºä½œç”¨åŸŸå¹¶æ³¨å†Œ
/// - ä½¿ç”¨ `exit_scope()` é€€å‡ºå‡½æ•°ä½œç”¨åŸŸ
/// - å°†å‡½æ•°æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸä¸­
/// - è¿”å›ž `KnfFunction` ç»“æž„
///
/// ## ðŸ”§ å…³é”®å®žçŽ°ç»†èŠ‚
///
/// ### ä½œç”¨åŸŸç®¡ç†
/// é¡¶å±‚å‡½æ•°çš„è½¬æ¢éœ€è¦è°¨æ…Žç®¡ç†ä½œç”¨åŸŸï¼š
/// - åœ¨å¼€å§‹å¤„ç†å‚æ•°å‰è¿›å…¥ä½œç”¨åŸŸ
/// - åœ¨å‡½æ•°ä½“è½¬æ¢å®ŒæˆåŽé€€å‡ºä½œç”¨åŸŸ
/// - ç¡®ä¿å‚æ•°å’Œå±€éƒ¨å˜é‡åœ¨æ­£ç¡®çš„ä½œç”¨åŸŸä¸­
///
/// ### å‚æ•°å¤„ç†
/// ä¸ºæ¯ä¸ªå‚æ•°åˆ›å»º Name å¹¶æ³¨å†Œåˆ°ä½œç”¨åŸŸï¼š
/// fn add(x: Int, y: Int) -> Int { ... }
/// è½¬æ¢ä¸ºï¼š
/// - åˆ›å»º Name { id: "x", slot: 0 } å’Œ Name { id: "y", slot: 0 }
/// - æ³¨å†Œåˆ°å½“å‰ä½œç”¨åŸŸ
/// - æ”¶é›†å‚æ•°ç±»åž‹ç”¨äºŽå‡½æ•°ç±»åž‹æž„é€ 
///
/// ### å‡½æ•°ç±»åž‹æž„é€ 
/// æž„é€ å‡½æ•°ç±»åž‹ç”¨äºŽå…¨å±€æ³¨å†Œï¼š
/// - å‚æ•°ç±»åž‹åˆ—è¡¨ï¼š[Int, Int]
/// - è¿”å›žç±»åž‹ï¼šInt
/// - å‡½æ•°ç±»åž‹ï¼šFunction([Int, Int], Int)
///
/// ### å…¨å±€æ³¨å†Œ
/// å°†å‡½æ•°æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸï¼š
/// - ä½¿ç”¨å‡½æ•°åä½œä¸ºé”®
/// - ä½¿ç”¨å‡½æ•°ç±»åž‹ä½œä¸ºå€¼
/// - ç¡®ä¿å‡½æ•°å¯ä»¥è¢«å…¶ä»–ä»£ç è°ƒç”¨
///
/// ## ðŸ“ æµ‹è¯•ç”¨ä¾‹è§£æž
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼šç®€å•å‡½æ•°
/// fn add(x: Int, y: Int) -> Int {
///   return x + y;
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¿›å…¥ä½œç”¨åŸŸ
/// 2. å¤„ç†å‚æ•°ï¼šx, y
/// 3. è½¬æ¢å‡½æ•°ä½“ï¼šreturn x + y;
/// 4. é€€å‡ºä½œç”¨åŸŸ
/// 5. æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼šUnit è¿”å›žç±»åž‹
/// fn greet(name: String) -> Unit {
///   return ();
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¿›å…¥ä½œç”¨åŸŸ
/// 2. å¤„ç†å‚æ•°ï¼šname
/// 3. è½¬æ¢å‡½æ•°ä½“ï¼šreturn ();
/// 4. é€€å‡ºä½œç”¨åŸŸ
/// 5. æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 3ï¼šé€’å½’å‡½æ•°
/// fn fib(n: Int) -> Int {
///   if n <= 1 {
///     return n;
///   } else {
///     return fib(n - 1) + fib(n - 2);
///   }
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¿›å…¥ä½œç”¨åŸŸ
/// 2. å¤„ç†å‚æ•°ï¼šn
/// 3. è½¬æ¢å‡½æ•°ä½“ï¼šif è¡¨è¾¾å¼å’Œé€’å½’è°ƒç”¨
/// 4. é€€å‡ºä½œç”¨åŸŸ
/// 5. æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 4ï¼šå¤šè¯­å¥å‡½æ•°
/// fn compute(a: Int, b: Int, c: Int) -> Int {
///   let sum = a + b;
///   let result = sum * c;
///   return result;
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¿›å…¥ä½œç”¨åŸŸ
/// 2. å¤„ç†å‚æ•°ï¼ša, b, c
/// 3. è½¬æ¢å‡½æ•°ä½“ï¼šlet è¯­å¥å’Œ return è¯­å¥
/// 4. é€€å‡ºä½œç”¨åŸŸ
/// 5. æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
///
/// ## ðŸ’¡ è®¾è®¡æ€æƒ³
///
/// ### ä½œç”¨åŸŸéš”ç¦»
/// æ¯ä¸ªå‡½æ•°éƒ½æœ‰ç‹¬ç«‹çš„ä½œç”¨åŸŸï¼Œå‚æ•°å’Œå±€éƒ¨å˜é‡ä¸ä¼šç›¸äº’å¹²æ‰°ã€‚
///
/// ### å‚æ•°ç®¡ç†
/// å‚æ•°åœ¨å‡½æ•°ä½œç”¨åŸŸä¸­å®šä¹‰ï¼Œå¯ä»¥è¢«å‡½æ•°ä½“ä¸­çš„è¯­å¥ä½¿ç”¨ã€‚
///
/// ### å…¨å±€æ³¨å†Œ
/// å‡½æ•°å®šä¹‰åŽéœ€è¦æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä¾›å…¶ä»–ä»£ç è°ƒç”¨ã€‚
///
/// ### ç±»åž‹å®‰å…¨
/// ç¡®ä¿å‡½æ•°å‚æ•°å’Œè¿”å›žç±»åž‹çš„ç±»åž‹å®‰å…¨ã€‚
///
/// ## ðŸš€ å®žçŽ°æŒ‘æˆ˜
///
/// ### ä½œç”¨åŸŸæ—¶æœº
/// éœ€è¦è°¨æ…Žå†³ç­–è¿›å…¥ä½œç”¨åŸŸå’Œé€€å‡ºä½œç”¨åŸŸçš„æ—¶æœºï¼š
/// - åœ¨å‚æ•°å¤„ç†å‰è¿›å…¥ä½œç”¨åŸŸ
/// - åœ¨å‡½æ•°ä½“è½¬æ¢å®ŒæˆåŽé€€å‡ºä½œç”¨åŸŸ
/// - ç¡®ä¿å…¨å±€æ³¨å†Œåœ¨ä½œç”¨åŸŸå¤–è¿›è¡Œ
///
/// ### å‚æ•°å¤„ç†
/// éœ€è¦æ­£ç¡®å¤„ç†å‚æ•°åˆ—è¡¨ï¼Œä¸ºæ¯ä¸ªå‚æ•°åˆ›å»º Name å¹¶æ³¨å†Œåˆ°ä½œç”¨åŸŸã€‚
///
/// ### å‡½æ•°ç±»åž‹æž„é€ 
/// éœ€è¦æ­£ç¡®æž„é€ å‡½æ•°ç±»åž‹ï¼ŒåŒ…æ‹¬å‚æ•°ç±»åž‹åˆ—è¡¨å’Œè¿”å›žç±»åž‹ã€‚
///
/// ### å…¨å±€æ³¨å†Œ
/// éœ€è¦å°†å‡½æ•°æ­£ç¡®æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸï¼Œç¡®ä¿å‡½æ•°å¯ä»¥è¢«è°ƒç”¨ã€‚
///
/// ## ðŸŽ¯ å®žçŽ°ç›®æ ‡
///
/// å®Œæˆ `function.mbt` ä¸­çš„ `top_function_to_knf` å‡½æ•°ï¼Œå®žçŽ°é¡¶å±‚å‡½æ•°çš„ KNF è½¬æ¢ã€‚
/// å‡½æ•°åº”è¯¥ï¼š
/// 1. æ­£ç¡®ç®¡ç†å‡½æ•°ä½œç”¨åŸŸï¼ˆenter_scope å’Œ exit_scopeï¼‰
/// 2. æ­£ç¡®å¤„ç†å‚æ•°åˆ—è¡¨ï¼Œä¸ºæ¯ä¸ªå‚æ•°åˆ›å»º Name
/// 3. æ­£ç¡®è½¬æ¢å‚æ•°ç±»åž‹å’Œè¿”å›žç±»åž‹
/// 4. æ­£ç¡®è½¬æ¢å‡½æ•°ä½“ä¸º KNF
/// 5. å°†å‡½æ•°æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
/// 6. è¿”å›žç»Ÿä¸€çš„ KnfFunction ç»“æž„
///
/// çŽ°åœ¨è®©æˆ‘ä»¬å¼€å§‹å®žçŽ°é¡¶å±‚å‡½æ•°çš„è½¬æ¢å§ï¼ðŸš€
///
/// ================================================================================

///|
test "Top Function Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup builtin functions
  typecheck_ctx.func_types.set("print_int", Function([Int], Unit))
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })
  knf_ctx.globals.set("print_int", Function([Int], Unit))

  let code =
    #|fn add(x: Int, y: Int) -> Int {
    #|  return x + y;
    #|}
    #|fn greet(name: String) -> Unit {
    #|  return ();
    #|}
    #|fn fib(n: Int) -> Int {
    #|  if n <= 1 {
    #|    return n;
    #|  } else {
    #|    return fib(n - 1) + fib(n - 2);
    #|  }
    #|}
    #|fn compute(a: Int, b: Int, c: Int) -> Int {
    #|  let sum = a + b;
    #|  let result = sum * c;
    #|  return result;
    #|}

  // Register function signatures first
  typecheck_ctx.func_types.set("add", Function([Int, Int], Int))
  typecheck_ctx.type_env.set("add", {
    kind: Function([Int, Int], Int),
    mutable: false,
  })
  knf_ctx.globals.set("add", Function([Int, Int], Int))
  
  typecheck_ctx.func_types.set("greet", Function([String], Unit))
  typecheck_ctx.type_env.set("greet", {
    kind: Function([String], Unit),
    mutable: false,
  })
  knf_ctx.globals.set("greet", Function([String], Unit))
  
  typecheck_ctx.func_types.set("fib", Function([Int], Int))
  typecheck_ctx.type_env.set("fib", {
    kind: Function([Int], Int),
    mutable: false,
  })
  knf_ctx.globals.set("fib", Function([Int], Int))
  
  typecheck_ctx.func_types.set("compute", Function([Int, Int, Int], Int))
  typecheck_ctx.type_env.set("compute", {
    kind: Function([Int, Int, Int], Int),
    mutable: false,
  })
  knf_ctx.globals.set("compute", Function([Int, Int, Int], Int))
  let tokens = @lexer.tokenize(code)

  // Test 1: Simple function with two parameters and return
  let (top_func1, tok_view) = @parser.parse_top_function(tokens)
  let checked_func1 = typecheck_ctx.check_top_function(top_func1)
  let knf_func1 = knf_ctx.top_function_to_knf(checked_func1)
  assert_true(knf_func1.name == "add")
  assert_true(knf_func1.ret_ty is Int)
  assert_true(knf_func1.params.length() is 2)
  assert_true(
    knf_func1.params[0] is (param_name1, param_type1) &&
    param_name1 is { id: "x", slot: 0 } &&
    param_type1 is Int,
  )
  assert_true(
    knf_func1.params[1] is (param_name2, param_type2) &&
    param_name2 is { id: "y", slot: 0 } &&
    param_type2 is Int,
  )
  // Body should have: return x + y;
  assert_true(knf_func1.body.stmts.length() is 1)
  assert_true(
    knf_func1.body.stmts is [s] &&
    s is Return(Binary(Add, x_name, y_name)) &&
    x_name is { id: "x", .. } &&
    y_name is { id: "y", .. },
  )

  // Test 2: Function with String parameter returning Unit
  let (top_func2, tok_view) = @parser.parse_top_function(tok_view)
  let checked_func2 = typecheck_ctx.check_top_function(top_func2)
  let knf_func2 = knf_ctx.top_function_to_knf(checked_func2)
  assert_true(knf_func2.name == "greet")
  assert_true(knf_func2.ret_ty is Unit)
  assert_true(knf_func2.params.length() is 1)
  assert_true(
    knf_func2.params is [(param_name3, param_type3)] &&
    param_name3 is { id: "name", slot: 0 } &&
    param_type3 is String,
  )
  // Body should have: return ();
  assert_true(knf_func2.body.stmts.length() is 1)
  assert_true(knf_func2.body.stmts[0] is Return(Unit))

  // Test 3: Recursive function with if expression
  let (top_func3, tok_view) = @parser.parse_top_function(tok_view)
  let checked_func3 = typecheck_ctx.check_top_function(top_func3)
  let knf_func3 = knf_ctx.top_function_to_knf(checked_func3)
  assert_true(knf_func3.name == "fib")
  assert_true(knf_func3.ret_ty is Int)
  assert_true(knf_func3.params.length() is 1)
  assert_true(
    knf_func3.params[0] is (param_name4, param_type4) &&
    param_name4 is { id: "n", slot: 0 } &&
    param_type4 is Int,
  )
  // Body should contain if expression and recursive calls
  // We don't need to verify the exact structure, just that it's transformed
  assert_true(knf_func3.body.stmts.length() > 0)

  // Test 4: Function with multiple statements in body
  let (top_func4, _) = @parser.parse_top_function(tok_view)
  let checked_func4 = typecheck_ctx.check_top_function(top_func4)
  let knf_func4 = knf_ctx.top_function_to_knf(checked_func4)
  assert_true(knf_func4.name == "compute")
  assert_true(knf_func4.ret_ty is Int)
  assert_true(knf_func4.params.length() is 3)
  // Body should have: let sum = a + b; let result = sum * c; return result;
  assert_true(knf_func4.body.stmts.length() is 3)
  assert_true(
    knf_func4.body.stmts[0] is Let(sum_name, Int, Binary(Add, a_name, b_name)) &&
    sum_name is { id: "sum", .. } &&
    a_name is { id: "a", .. } &&
    b_name is { id: "b", .. },
  )
  assert_true(
    knf_func4.body.stmts[1]
    is Let(result_name, Int, Binary(Mul, sum_name2, c_name)) &&
    result_name is { id: "result", .. } &&
    sum_name2 is { id: "sum", .. } &&
    c_name is { id: "c", .. },
  )
  assert_true(
    knf_func4.body.stmts[2] is Return(Ident(result_name2)) &&
    result_name2 is { id: "result", .. },
  )
}
