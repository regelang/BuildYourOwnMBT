/// ================================================================================
/// # ğŸ¯ è¯­å¥çš„ KNF å˜æ¢ï¼šç»Ÿä¸€çš„åˆ†å‘ä¸­å¿ƒ
///
/// åœ¨å®Œæˆäº†å„ç§å…·ä½“è¯­å¥çš„è½¬æ¢ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨è¦å®ç°**è¯­å¥çš„ç»Ÿä¸€åˆ†å‘ä¸­å¿ƒ**ã€‚
/// è¿™æ˜¯ KNF å˜æ¢ä¸­çš„ä¸€ä¸ªé‡è¦é‡Œç¨‹ç¢‘ï¼Œå› ä¸ºå®ƒå°†æ‰€æœ‰çš„è¯­å¥ç±»å‹ç»Ÿä¸€åˆ°ä¸€ä¸ªå…¥å£ç‚¹ã€‚
///
/// ## ğŸŒŸ ä»€ä¹ˆæ˜¯è¯­å¥çš„ç»Ÿä¸€åˆ†å‘ï¼Ÿ
///
/// **è¯­å¥çš„ç»Ÿä¸€åˆ†å‘**æ˜¯å°†ä¸åŒç±»å‹çš„è¯­å¥è·¯ç”±åˆ°ç›¸åº”çš„å¤„ç†å‡½æ•°ï¼š
///
/// ```
/// let x = 10;           // LetStmt -> let_stmt_to_knf
/// let mut y = 20;       // LetMutStmt -> let_mut_stmt_to_knf
/// x = 30;               // AssignStmt -> assign_stmt_to_knf
/// print_int(x);         // ExprStmt -> expr_to_knf + ExprStmt
/// return x;             // ReturnStmt(Some) -> expr_to_knf + Return
/// return;               // ReturnStmt(None) -> ReturnUnit
/// ```
///
/// **ç»Ÿä¸€åˆ†å‘çš„ç‰¹ç‚¹**ï¼š
/// - **å•ä¸€å…¥å£**ï¼šæ‰€æœ‰è¯­å¥éƒ½é€šè¿‡ `stmt_to_knf` å¤„ç†
/// - **ç±»å‹åˆ†å‘**ï¼šæ ¹æ®è¯­å¥ç±»å‹è·¯ç”±åˆ°ç›¸åº”çš„å¤„ç†å‡½æ•°
/// - **ä¸€è‡´æ€§**ï¼šç¡®ä¿æ‰€æœ‰è¯­å¥éƒ½é‡‡ç”¨ç›¸åŒçš„å¤„ç†æ¨¡å¼
/// - **å¯æ‰©å±•æ€§**ï¼šä¾¿äºæ·»åŠ æ–°çš„è¯­å¥ç±»å‹
///
/// ## ğŸ” è¯­å¥ç±»å‹çš„å¤„ç†ç­–ç•¥
///
/// å¯¹äºä¸åŒçš„è¯­å¥ç±»å‹ï¼Œéœ€è¦é‡‡ç”¨ä¸åŒçš„å¤„ç†ç­–ç•¥ï¼š
///
/// ### 1. LetStmt å’Œ LetMutStmt
/// - **ç›´æ¥å§”æ‰˜**ï¼šç›´æ¥è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°
/// - **æ¨¡å¼åŒ¹é…**ï¼šå¤„ç†å¤æ‚çš„æ¨¡å¼åŒ¹é…
/// - **å˜é‡ç»‘å®š**ï¼šåˆ›å»ºå˜é‡ç»‘å®š
///
/// ### 2. AssignStmt
/// - **å·¦å€¼å¤„ç†**ï¼šå¤„ç†å¤æ‚çš„å·¦å€¼ç»“æ„
/// - **å¤åˆæ“ä½œ**ï¼šå¤„ç†å¤åˆèµ‹å€¼æ“ä½œ
/// - **å‰¯ä½œç”¨**ï¼šå¤„ç†çŠ¶æ€ä¿®æ”¹
///
/// ### 3. ExprStmt
/// - **è¡¨è¾¾å¼å¤„ç†**ï¼šä½¿ç”¨ `expr_to_knf` å¤„ç†è¡¨è¾¾å¼
/// - **å‰¯ä½œç”¨å¤„ç†**ï¼šå¤„ç†è¡¨è¾¾å¼çš„å‰¯ä½œç”¨
/// - **ExprStmt åŒ…è£…**ï¼šå°†ç»“æœåŒ…è£…ä¸º `ExprStmt`
///
/// ### 4. ReturnStmt
/// - **æœ‰å€¼è¿”å›**ï¼š`ReturnStmt(Some(expr))` -> `Return(expr)`
/// - **æ— å€¼è¿”å›**ï¼š`ReturnStmt(None)` -> `ReturnUnit`
/// - **è¡¨è¾¾å¼å¤„ç†**ï¼šå¯¹è¿”å›å€¼è¿›è¡Œ KNF è½¬æ¢
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `stmt_to_knf` å‡½æ•°
///
/// åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œä½ éœ€è¦å®ç° `Context::stmt_to_knf` å‡½æ•°ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// è¯­å¥çš„ç»Ÿä¸€åˆ†å‘é‡‡ç”¨**æ¨¡å¼åŒ¹é…**çš„ç­–ç•¥ï¼š
///
/// 1. **æ¨¡å¼åŒ¹é…**ï¼šæ ¹æ® `stmt.kind` çš„ç±»å‹è¿›è¡ŒåŒ¹é…
/// 2. **ç›´æ¥å§”æ‰˜**ï¼šå¯¹äºå·²å®ç°çš„è¯­å¥ç±»å‹ï¼Œç›´æ¥è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°
/// 3. **è¡¨è¾¾å¼å¤„ç†**ï¼šå¯¹äº `ExprStmt` å’Œ `ReturnStmt`ï¼Œéœ€è¦å¤„ç†è¡¨è¾¾å¼
/// 4. **ç‰¹æ®Šå¤„ç†**ï¼šå¯¹äº `ReturnStmt(None)`ï¼Œç›´æ¥è¿”å› `ReturnUnit`
///
/// ### ğŸ”§ å…³é”®å®ç°ç»†èŠ‚
///
/// #### ExprStmt çš„å¤„ç†
/// ```
/// ExprStmt(expr) => {
///   let (stmts, knf_expr) = self.expr_to_knf(expr)
///   stmts.append([KnfStmt::ExprStmt(knf_expr)])
///   stmts
/// }
/// ```
///
/// **å…³é”®ç‚¹**ï¼š
/// - ä½¿ç”¨ `expr_to_knf` å¤„ç†è¡¨è¾¾å¼
/// - å°†ç»“æœåŒ…è£…ä¸º `ExprStmt`
/// - åˆå¹¶è¡¨è¾¾å¼å¯èƒ½äº§ç”Ÿçš„è¯­å¥
///
/// #### ReturnStmt çš„å¤„ç†
/// ```
/// ReturnStmt(Some(expr)) => {
///   let (stmts, knf_expr) = self.expr_to_knf(expr)
///   stmts.append([KnfStmt::Return(knf_expr)])
///   stmts
/// }
/// ReturnStmt(None) => [KnfStmt::ReturnUnit]
/// ```
///
/// **å…³é”®ç‚¹**ï¼š
/// - æœ‰å€¼è¿”å›ï¼šå¤„ç†è¡¨è¾¾å¼å¹¶åŒ…è£…ä¸º `Return`
/// - æ— å€¼è¿”å›ï¼šç›´æ¥è¿”å› `ReturnUnit`
/// - æ³¨æ„ `ReturnUnit` æ˜¯å•ç‹¬çš„å˜ä½“ï¼Œä¸æ˜¯ `Return(Unit)`
///
/// ## ğŸš€ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// è¿™ä¸ªæµ‹è¯•æ–‡ä»¶åŒ…å«äº†å¤šç§è¯­å¥çš„ç»¼åˆè½¬æ¢ï¼š
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼š`let mut p = Point::{ x: 0, y: 0 };`
/// **è½¬æ¢ç»“æœ**ï¼šç»“æ„ä½“æ„é€ çš„ Let Mut è¯­å¥
/// **ç‰¹ç‚¹**ï¼šå¤æ‚çš„åˆå§‹åŒ–è¡¨è¾¾å¼
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼š`let mut a = 100;`
/// **è½¬æ¢ç»“æœ**ï¼š`LetMut(a, Int, Int(100))`
/// **ç‰¹ç‚¹**ï¼šç®€å•çš„ Let Mut è¯­å¥
///
/// ### æµ‹è¯•ç”¨ä¾‹ 3ï¼š`let (b, c) = (200, 300);`
/// **è½¬æ¢ç»“æœ**ï¼šå…ƒç»„è§£æ„çš„ Let è¯­å¥
/// **ç‰¹ç‚¹**ï¼šæ¨¡å¼åŒ¹é…å’Œä¼˜åŒ–
///
/// ### æµ‹è¯•ç”¨ä¾‹ 4ï¼š`let arr = [a, b, c];`
/// **è½¬æ¢ç»“æœ**ï¼šæ•°ç»„å­—é¢é‡çš„ Let è¯­å¥
/// **ç‰¹ç‚¹**ï¼šå¤æ‚è¡¨è¾¾å¼çš„å¤„ç†
///
/// ### æµ‹è¯•ç”¨ä¾‹ 5ï¼š`a *= 50;`
/// **è½¬æ¢ç»“æœ**ï¼šå¤åˆèµ‹å€¼è¯­å¥
/// **ç‰¹ç‚¹**ï¼šå¤åˆæ“ä½œçš„å¤„ç†
///
/// ### æµ‹è¯•ç”¨ä¾‹ 6ï¼š`p.x += b + c;`
/// **è½¬æ¢ç»“æœ**ï¼šå¤æ‚å·¦å€¼çš„å¤åˆèµ‹å€¼
/// **ç‰¹ç‚¹**ï¼šåµŒå¥—å·¦å€¼å’Œå¤åˆæ“ä½œ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 7ï¼š`arr[1] = a - 25;`
/// **è½¬æ¢ç»“æœ**ï¼šæ•°ç»„èµ‹å€¼çš„ Assign è¯­å¥
/// **ç‰¹ç‚¹**ï¼šæ•°ç»„è®¿é—®å’Œå¤æ‚è¡¨è¾¾å¼
///
/// ### æµ‹è¯•ç”¨ä¾‹ 8ï¼š`return p;`
/// **è½¬æ¢ç»“æœ**ï¼š`Return(Ident(p))`
/// **ç‰¹ç‚¹**ï¼šæœ‰å€¼è¿”å›è¯­å¥
///
/// ## ğŸ’¡ å®ç°æç¤º
///
/// 1. **æ¨¡å¼åŒ¹é…**ï¼šä½¿ç”¨ `match` è¯­å¥å¤„ç†ä¸åŒçš„è¯­å¥ç±»å‹
/// 2. **ç›´æ¥å§”æ‰˜**ï¼šå¯¹äºå·²å®ç°çš„è¯­å¥ç±»å‹ï¼Œç›´æ¥è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°
/// 3. **è¡¨è¾¾å¼å¤„ç†**ï¼šå¯¹äº `ExprStmt` å’Œ `ReturnStmt`ï¼Œä½¿ç”¨ `expr_to_knf`
/// 4. **è¯­å¥åˆå¹¶**ï¼šä½¿ç”¨ `append` åˆå¹¶è¡¨è¾¾å¼å¯èƒ½äº§ç”Ÿçš„è¯­å¥
/// 5. **ç‰¹æ®Šå¤„ç†**ï¼šæ³¨æ„ `ReturnUnit` æ˜¯å•ç‹¬çš„å˜ä½“
///
/// ## ğŸ”® è®¾è®¡æ€æƒ³
///
/// ç»Ÿä¸€åˆ†å‘çš„è®¾è®¡ä½“ç°äº†ä»¥ä¸‹æ€æƒ³ï¼š
///
/// - **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªå¤„ç†å‡½æ•°ä¸“æ³¨äºä¸€ç§è¯­å¥ç±»å‹
/// - **ä¸€è‡´æ€§**ï¼šæ‰€æœ‰è¯­å¥éƒ½é‡‡ç”¨ç›¸åŒçš„å¤„ç†æ¨¡å¼
/// - **å¯ç»´æŠ¤æ€§**ï¼šä¾¿äºæ·»åŠ æ–°çš„è¯­å¥ç±»å‹
/// - **å¯æµ‹è¯•æ€§**ï¼šæ¯ç§è¯­å¥ç±»å‹éƒ½å¯ä»¥ç‹¬ç«‹æµ‹è¯•
///
/// ## ğŸ¯ å¼€å§‹å®ç°å§ï¼
///
/// è¿™æ˜¯è¯­å¥å¤„ç†çš„ç»Ÿä¸€å…¥å£ï¼é€šè¿‡å®ç° `stmt_to_knf` å‡½æ•°ï¼Œ
/// æˆ‘ä»¬å°†å®Œæˆè¯­å¥å¤„ç†çš„æœ€åä¸€å—æ‹¼å›¾ï¼Œä¸ºåç»­çš„ç¨‹åºå¤„ç†å¥ å®šåŸºç¡€ã€‚
///
/// **å‡†å¤‡å¥½å®Œæˆè¯­å¥å¤„ç†çš„ç»Ÿä¸€åˆ†å‘äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å®ç°ï¼**
/// ================================================================================

///|
//test "Stmt Knf Transformation Test - 2" {
//  // Prelude Parts
//  let typecheck_ctx = @typecheck.Context::new()
//  let knf_ctx = @knf.Context::new()
//
//  // Setup struct definition for testing
//  let point_struct_def : @typecheck.StructDef = {
//    name: "Point",
//    fields: [
//      { name: "x", ty: { kind: Int, mutable: true } },
//      { name: "y", ty: { kind: Int, mutable: true } },
//    ],
//  }
//  typecheck_ctx.struct_defs.set("Point", point_struct_def)
//
//  // Setup type environment
//  typecheck_ctx.type_env.set("x", { kind: Int, mutable: true })
//  typecheck_ctx.type_env.set("arr", { kind: Array(Int), mutable: true })
//  typecheck_ctx.type_env.set("point", { kind: Struct("Point"), mutable: false })
//
//  // Set function context for return statement
//  typecheck_ctx.current_func_ret_ty = Some(Unit)
//
//  // Setup knf context
//  let _ = knf_ctx.add_new_name("x", Int)
//  let _ = knf_ctx.add_new_name("arr", Array(Int))
//  let _ = knf_ctx.add_new_name("point", Struct("Point"))
//
//  // Test Parts
//  let code =
//    #|let (a, b) = (10, 20);
//    #|x += 5;
//    #|arr[0] = 42;
//    #|point.x = 100;
//    #|return;
//
//  // Code parse, typecheck, knf transform
//  let tokens = @lexer.tokenize(code)
//
//  // Test 1: Parse and transform `let (a, b) = (10, 20);` (tuple pattern)
//  let (stmt, tok_view) = @parser.parse_stmt(tokens)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(
//    knf_stmts is [s1, s2, s3, s4] &&
//    s1 is Let(n1, Int, Int(10)) &&
//    s2 is Let(n2, Int, Int(20)) &&
//    s3 is Let(a, _, Ident(n1_)) &&
//    s4 is Let(b, _, Ident(n2_)) &&
//    n1 == n1_ &&
//    n2 == n2_ &&
//    a is { id: "a", .. } &&
//    b is { id: "b", .. },
//  )
//
//  // Test 2: Parse and transform `x += 5;` (compound assignment)
//  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(
//    knf_stmts is [s1, s2, s3] &&
//    s1 is Let(_, Int, Int(5)) &&
//    s2 is Let(_, Int, Binary(Add, _, _)) &&
//    s3 is Assign(name, Ident(_)) &&
//    name is { id: "x", .. },
//  )
//
//  // Test 3: Parse and transform `arr[0] = 42;` (array assignment)
//  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(
//    knf_stmts is [s1, s2] &&
//    s1 is Let(n1, Int, Int(0)) &&
//    s2 is ArrayPut(array_name, idx_name, Int(42)) &&
//    n1 == idx_name &&
//    array_name is { id: "arr", .. },
//  )
//
//  // Test 4: Parse and transform `point.x = 100;` (struct field assignment)
//  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(
//    knf_stmts is [s1, s2] &&
//    s1 is Let(n1, Int, Int(100)) &&
//    s2 is StructFieldSet(_, "x", value_name) &&
//    n1 == value_name,
//  )
//
//  // Test 5: Parse and transform `return;` (return without value)
//  let (stmt, _) = @parser.parse_stmt(tok_view)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(knf_stmts is [s] && s is ReturnUnit)
//}

test "Stmt Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup struct definition for testing
  let point_struct_def : @typecheck.StructDef = {
    name: "Point",
    fields: [
      { name: "x", ty: { kind: Int, mutable: true } },
      { name: "y", ty: { kind: Int, mutable: true } },
    ],
  }
  typecheck_ctx.struct_defs.set("Point", point_struct_def)

  // Set function context for return statement
  typecheck_ctx.current_func_ret_ty = Some(Struct("Point"))
  let code =
    #|let mut p = Point::{ x: 0, y: 0 };
    #|let mut a = 100;
    #|let (b, c) = (200, 300);
    #|let arr = [a, b, c];
    #|a *= 50;
    #|p.x += b + c;
    #|arr[1] = a - 25;
    #|return p;

  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)

  // Test 1: Parse and transform `let mut p = Point::{ mut x: 0, y: 0 };`
  let (stmt, tok_view) = @parser.parse_stmt(tokens)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3] &&
    s1 is Let(_, Int, Int(0)) &&
    s2 is Let(_, Int, Int(0)) &&
    s3 is LetMut(name, Struct("Point"), CreateStruct("Point", fields)) &&
    name is { id: "p", .. } &&
    fields is [field1, field2] &&
    field1 is ("x", _) &&
    field2 is ("y", _),
  )

  // Test 2: Parse and transform `let mut a = 100;`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is LetMut(name, Int, Int(100)) &&
    name is { id: "a", .. },
  )

  // Test 3: Parse and transform `let (b, c) = (200, 300);`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3, s4] &&
    s1 is Let(n1, Int, Int(200)) &&
    s2 is Let(n2, Int, Int(300)) &&
    s3 is Let(b, _, Ident(n1_)) &&
    s4 is Let(c, _, Ident(n2_)) &&
    n1 == n1_ &&
    n2 == n2_ &&
    b is { id: "b", .. } &&
    c is { id: "c", .. },
  )

  // Test 4: Parse and transform `let arr = [a, b, c];`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is Let(name, Array(Int), ArrayLiteral(_, elements)) &&
    name is { id: "arr", .. } &&
    elements is [elem1, elem2, elem3] &&
    elem1 is { id: "a", .. } &&
    elem2 is { id: "b", .. } &&
    elem3 is { id: "c", .. },
  )

  // Test 5: Parse and transform `a *= 50;`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3] &&
    s1 is Let(_, Int, Int(50)) &&
    s2 is Let(_, Int, Binary(Mul, _, _)) &&
    s3 is Assign(name, Ident(_)) &&
    name is { id: "a", .. },
  )

  // Test 6: Parse and transform `p.x += b + c;`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3, s4, s5] &&
    s1 is Let(n1, Int, FieldAccess(_, "x")) &&
    s2 is Let(n2, Int, Binary(Add, { id: "b", .. }, { id: "c", .. })) &&
    s3 is Let(n3, Int, Binary(Add, n1_, n2_)) &&
    s4 is Let(n4, Int, Ident(n3_)) &&
    s5 is StructFieldSet(_, "x", n4_) &&
    n1 == n1_ &&
    n2 == n2_ &&
    n3 == n3_ &&
    n4 == n4_,
  )

  // Test 7: Parse and transform `arr[1] = a - 25;`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3] &&
    s1 is Let(_, Int, Int(1)) &&
    s2 is Let(_, Int, Int(25)) &&
    s3 is ArrayPut(_),
  )

  // Test 8: Parse and transform `return p;`
  let (stmt, _) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is Return(return_expr) &&
    return_expr is Ident({ id: "p", .. }),
  )
}
