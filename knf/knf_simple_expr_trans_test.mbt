/// ================================================================================
/// # ğŸ¯ ç®€å•è¡¨è¾¾å¼çš„ KNF å˜æ¢ï¼šå¼•å…¥ Let è¯­å¥
///
/// åœ¨å®Œæˆäº†åº”ç”¨è¡¨è¾¾å¼çš„è½¬æ¢ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨è¦å¤„ç†**è¡¨è¾¾å¼ (Expression)** çš„è½¬æ¢ã€‚
/// è¿™æ˜¯ KNF å˜æ¢ä¸­ä¸€ä¸ªé‡è¦çš„é‡Œç¨‹ç¢‘ï¼Œå› ä¸ºæˆ‘ä»¬å°†é¦–æ¬¡å¼•å…¥ **Let è¯­å¥** çš„æ¦‚å¿µï¼
///
/// ## ğŸŒŸ ä»€ä¹ˆæ˜¯è¡¨è¾¾å¼ï¼Ÿ
///
/// **è¡¨è¾¾å¼**æ˜¯ç¨‹åºä¸­æœ€åŸºæœ¬çš„è®¡ç®—å•å…ƒï¼Œå®ƒä»¬åŒ…æ‹¬ï¼š
///
/// - **åº”ç”¨è¡¨è¾¾å¼**ï¼š`x`ã€`f(y)`ã€`arr[0]`ï¼ˆæˆ‘ä»¬å·²ç»å¤„ç†è¿‡çš„ï¼‰
/// - **ä¸€å…ƒè¡¨è¾¾å¼**ï¼š`-x`ã€`!flag`ï¼ˆå–è´Ÿã€é€»è¾‘éï¼‰
/// - **äºŒå…ƒè¡¨è¾¾å¼**ï¼š`a + b`ã€`x * y`ã€`p && q`ï¼ˆç®—æœ¯ã€é€»è¾‘è¿ç®—ï¼‰
/// - **å—è¡¨è¾¾å¼**ï¼š`{ stmt1; stmt2; expr }`
/// - **æ¡ä»¶è¡¨è¾¾å¼**ï¼š`if cond { expr1 } else { expr2 }`
///
/// åœ¨ KNF å˜æ¢ä¸­ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯å°†è¿™äº›è¡¨è¾¾å¼è½¬æ¢ä¸º**è§„èŒƒåŒ–çš„å½¢å¼**ï¼Œ
/// å…¶ä¸­å¤æ‚çš„åµŒå¥—è¡¨è¾¾å¼è¢«åˆ†è§£ä¸ºç®€å•çš„åŸå­æ“ä½œã€‚
///
/// ## ğŸ” KNF çš„æ ¸å¿ƒæ€æƒ³ï¼šLet è¯­å¥
///
/// **KNF çš„æ ¸å¿ƒæ€æƒ³**æ˜¯å°†å¤æ‚çš„è¡¨è¾¾å¼åˆ†è§£ä¸ºç®€å•çš„åŸå­æ“ä½œã€‚
/// ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¼•å…¥äº† **Let è¯­å¥**ï¼š
///
/// ```moonbit
/// enum KnfStmt {
///   Let(Name, Type, KnfExpr)  // let tmp : Int = 42;
///   // ... å…¶ä»–è¯­å¥ç±»å‹
/// }
/// ```
///
/// **Let è¯­å¥çš„ä½œç”¨**ï¼š
/// - å°†å¤æ‚è¡¨è¾¾å¼çš„è®¡ç®—ç»“æœå­˜å‚¨åˆ°ä¸´æ—¶å˜é‡ä¸­
/// - ç¡®ä¿æ¯ä¸ªæ“ä½œéƒ½æ˜¯"åŸå­"çš„
/// - ä¸ºåç»­çš„ä¼˜åŒ–å’Œä»£ç ç”Ÿæˆåšå‡†å¤‡
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `expr_to_knf` å‡½æ•°
///
/// åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œä½ éœ€è¦å®ç° `Context::expr_to_knf` å‡½æ•°ã€‚
/// è¿™ä¸ªå‡½æ•°éœ€è¦å¤„ç†å¤šç§è¡¨è¾¾å¼ç±»å‹ï¼Œä½†æˆ‘ä»¬å°†é‡ç‚¹å…³æ³¨**ç®€å•æƒ…å†µ**ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// #### 1. åº”ç”¨è¡¨è¾¾å¼ (ApplyExpr)
/// ```
/// ApplyExpr(apply_expr) => self.apply_expr_to_knf(apply_expr)
/// ```
/// ç›´æ¥å§”æ‰˜ç»™å·²ç»å®ç°çš„ `apply_expr_to_knf` å‡½æ•°ã€‚
///
/// #### 2. ä¸€å…ƒè¡¨è¾¾å¼ (UnaryExpr)
///
/// **å…³é”®æ­¥éª¤**ï¼š
/// 1. é€’å½’å¤„ç†å†…éƒ¨è¡¨è¾¾å¼
/// 2. åˆ›å»ºä¸´æ—¶å˜é‡å­˜å‚¨å†…éƒ¨è¡¨è¾¾å¼çš„ç»“æœ
/// 3. ç”Ÿæˆ Let è¯­å¥
/// 4. è¿”å›ä¸€å…ƒæ“ä½œçš„ç»“æœ
///
/// #### 3. äºŒå…ƒè¡¨è¾¾å¼ (BinaryExpr)
///
/// **å…³é”®æ­¥éª¤**ï¼š
/// 1. é€’å½’å¤„ç†å·¦å³æ“ä½œæ•°
/// 2. åˆå¹¶æ‰€æœ‰è¯­å¥
/// 3. ä¸ºå¤æ‚æ“ä½œæ•°åˆ›å»ºä¸´æ—¶å˜é‡ï¼ˆå¦‚æœä¸æ˜¯ç®€å•çš„æ ‡è¯†ç¬¦ï¼‰
/// 4. è¿”å›äºŒå…ƒæ“ä½œçš„ç»“æœ
///
/// ## ğŸ› ï¸ è¾…åŠ©å‡½æ•°ï¼š`expr_to_knf_name`
///
/// è¿™ä¸ªè¾…åŠ©å‡½æ•°ç”¨äºå°†è¡¨è¾¾å¼è½¬æ¢ä¸º `Name`ï¼š
/// ```moonbit
/// fn Context::expr_to_knf_name(
///   self : Context,
///   expr : KnfExpr,
///   ty : Type,
///   stmts : Array[KnfStmt],
/// ) -> Name
/// ```
///
/// **ä½œç”¨**ï¼š
/// - å¦‚æœè¡¨è¾¾å¼æ˜¯ç®€å•çš„ `Ident(name)`ï¼Œç›´æ¥è¿”å› `name`
/// - å¦åˆ™åˆ›å»ºä¸´æ—¶å˜é‡ï¼Œç”Ÿæˆ Let è¯­å¥ï¼Œè¿”å›ä¸´æ—¶å˜é‡å
///
/// ## ğŸš€ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// è¿™ä¸ªæµ‹è¯•æ–‡ä»¶åŒ…å«äº†å¤šç§è¡¨è¾¾å¼çš„è½¬æ¢ï¼š
///
/// 1. **ç®€å•å­—é¢é‡**ï¼š`42` â†’ `Int(42)`ï¼ˆæ—  Let è¯­å¥ï¼‰
/// 2. **ä¸€å…ƒè¡¨è¾¾å¼**ï¼š`-33` â†’ `Let(tmp, Int, Int(33)); Neg(tmp)`
/// 3. **ä¸€å…ƒè¡¨è¾¾å¼**ï¼š`!w` â†’ `Let(tmp, Bool, Ident(w)); Not(tmp)`
/// 4. **ç®€å•äºŒå…ƒè¡¨è¾¾å¼**ï¼š`x + y` â†’ `Binary(Add, x, y)`ï¼ˆæ—  Let è¯­å¥ï¼‰
/// 5. **å¤æ‚äºŒå…ƒè¡¨è¾¾å¼**ï¼š`2.0 * 3.14` â†’ `Let(tmp1, Double, Double(2.0)); Let(tmp2, Double, Double(3.14)); Binary(Mul, tmp1, tmp2)`
/// 6. **æ··åˆè¡¨è¾¾å¼**ï¼š`x + y * z` â†’ `Let(tmp, Int, Binary(Mul, y, z)); Binary(Add, x, tmp)`
///
/// ## ğŸ’¡ å®ç°æç¤º
///
/// 1. **é€’å½’å¤„ç†**ï¼šä½¿ç”¨é€’å½’å¤„ç†åµŒå¥—è¡¨è¾¾å¼
/// 2. **ä¸´æ—¶å˜é‡**ï¼šä½¿ç”¨ `add_temp` åˆ›å»ºä¸´æ—¶å˜é‡
/// 3. **Let è¯­å¥**ï¼šä½¿ç”¨ `KnfStmt::Let` åˆ›å»º Let è¯­å¥
/// 4. **è¯­å¥åˆå¹¶**ï¼šä½¿ç”¨ `append` åˆå¹¶è¯­å¥åˆ—è¡¨
/// 5. **ä¼˜åŒ–**ï¼šå¯¹äºç®€å•çš„ `Ident`ï¼Œä¸éœ€è¦åˆ›å»ºä¸´æ—¶å˜é‡
///
/// ## ğŸ”® KNF å˜æ¢çš„å¨åŠ›
///
/// é€šè¿‡å¼•å…¥ Let è¯­å¥ï¼Œæˆ‘ä»¬å®ç°äº†ï¼š
///
/// - **è¡¨è¾¾å¼åˆ†è§£**ï¼šå¤æ‚è¡¨è¾¾å¼è¢«åˆ†è§£ä¸ºç®€å•æ“ä½œ
/// - **å‰¯ä½œç”¨éš”ç¦»**ï¼šæ¯ä¸ªæ“ä½œçš„ç»“æœéƒ½è¢«æ˜ç¡®å­˜å‚¨
/// - **ä¼˜åŒ–å‹å¥½**ï¼šä¸ºåç»­çš„ä¼˜åŒ–æä¾›äº†æ¸…æ™°çš„ç»“æ„
/// - **ä»£ç ç”Ÿæˆ**ï¼šä¸º LLVM ä»£ç ç”Ÿæˆæä¾›äº†æ ‡å‡†åŒ–çš„å½¢å¼
///
/// ## æé†’
///
/// Contextç»“æ„ä½“å·²ç»ä¸ºä½ æä¾›äº†add_new_nameå’Œadd_tempæ–¹æ³•ï¼Œæ³¨æ„é˜…è¯»ä¸€ä¸‹å“¦ã€‚
///
/// ## ğŸ¯ å¼€å§‹å®ç°å§ï¼
///
/// è¿™æ˜¯ KNF å˜æ¢ä¸­ä¸€ä¸ªé‡è¦çš„é‡Œç¨‹ç¢‘ï¼é€šè¿‡å¼•å…¥ Let è¯­å¥ï¼Œ
/// æˆ‘ä»¬å°†å¤æ‚çš„è¡¨è¾¾å¼è½¬æ¢ä¸ºç®€å•ã€è§„èŒƒåŒ–çš„å½¢å¼ã€‚
///
/// **å‡†å¤‡å¥½ä½“éªŒ KNF å˜æ¢çš„æ ¸å¿ƒå¨åŠ›äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å®ç°ï¼**
/// ================================================================================

///|
test "Simple Expr Knf Transformation Test" {
  // set x, y, z type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("y", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("z", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("w", { kind: Bool, mutable: false })
  let knf_ctx = Context::new()
  knf_ctx.globals.set("x", Int)
  let _ = knf_ctx.add_new_name("y", Int)
  let _ = knf_ctx.add_new_name("w", Int)
  knf_ctx.enter_scope()
  let _ = knf_ctx.add_new_name("z", Bool)

  // Code parse, typecheck, knf transform
  let code =
    #|42;
    #|-33;
    #|!w;
    #|x + y;
    #|2.0 * 3.14;
    #|x + y * z ;
  let tokens = @lexer.tokenize(code)
  // Parse and transform `42` 
  let (e, tok_view) = @parser.parse_expr(tokens)
  let e = typecheck_ctx.check_expr(e)
  let (_, e) = knf_ctx.expr_to_knf(e)
  assert_true(e is Int(42))
  // Parse and transform `-33`
  let (e, tok_view) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s] && s is Let(n1, Int, Int(33)) && e is Neg(n2) && n1 == n2,
  )
  // Parse and transform `!z`
  let (e, tok_view) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s] &&
    s is Let(n1, Bool, Ident(i)) &&
    i is { id: "w", .. } &&
    e is Not(n2) &&
    n1 == n2,
  )
  // Parse and transform `x + 10`
  let (e, tok_view) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [] &&
    e is Binary(Add, n1, n2) &&
    n1 is { id: "x", .. } &&
    n2 is { id: "y", .. },
  )
  // Parse and transform `2.0 * 3.14`
  let (e, tok_view) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Double, Double(2.0)) &&
    s2 is Let(n2, Double, Double(3.14)) &&
    e is Binary(Mul, n3, n4) &&
    n1 == n3 &&
    n2 == n4,
  )
  // Parse and transform `x + y * z`
  let (e, _) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s] &&
    s is Let(n1, Int, Binary(Mul, n2, n3)) &&
    e is Binary(Add, n4, n5) &&
    n1 is { id: "tmp", .. } &&
    n2 is { id: "y", .. } &&
    n3 is { id: "z", .. } &&
    n4 is { id: "x", .. } &&
    n5 == n1,
  )
}
