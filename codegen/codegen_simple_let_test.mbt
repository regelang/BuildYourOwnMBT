/// ================================================================================
/// # LLVM Codegen: let å’Œ let mut
/// ================================================================================
///
/// æˆ‘ä»¬å·²ç»èƒ½ä¸ºç®€å•çš„è¿”å›žå€¼ç”Ÿæˆä»£ç äº†ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬æ¥å¤„ç†å˜é‡ç»‘å®šï¼š`let` å’Œ `let mut` è¯­å¥ã€‚
/// è¿™ä¸¤ç§è¯­å¥åœ¨ä»£ç ç”Ÿæˆé˜¶æ®µçš„å¤„ç†æ–¹å¼æœ‰ç€æœ¬è´¨çš„åŒºåˆ«ã€‚
///
/// ## `let` è¯­å¥ï¼ˆä¸å¯å˜ç»‘å®šï¼‰
///
/// `let z = x;`
///
/// åœ¨ KNF å’Œ SSA çš„ä¸–ç•Œé‡Œï¼Œ`let` è¯­å¥é€šå¸¸ä¸äº§ç”Ÿæ–°çš„ LLVM æŒ‡ä»¤ã€‚
/// å› ä¸º `x` å·²ç»æ˜¯ä¸€ä¸ªè®¡ç®—å¥½çš„ LLVM å€¼ï¼ˆå¯ä»¥çœ‹ä½œä¸€ä¸ªâ€œå¯„å­˜å™¨â€é‡Œçš„å€¼ï¼‰ï¼Œ
/// æˆ‘ä»¬è¦åšçš„ä»…ä»…æ˜¯åœ¨æˆ‘ä»¬çš„ `Context` ä¸­å»ºç«‹ä¸€ä¸ªæ–°çš„æ˜ å°„ï¼Œå°† `z` è¿™ä¸ªåå­—æŒ‡å‘ `x` å¯¹åº”çš„é‚£ä¸ª LLVM å€¼ã€‚
///
/// ``` skip
/// In let_stmt_codegen:
/// let value = self.expr_codegen(expr).unwrap();
/// self.name_values.set(name, value); // å°†æ–°åå­—æ˜ å°„åˆ°å·²æœ‰çš„ LLVM å€¼
/// ```
///
/// ## `let mut` è¯­å¥ï¼ˆå¯å˜ç»‘å®šï¼‰
///
/// `let mut z = x;`
///
/// å¯å˜å˜é‡éœ€è¦ä¸€ä¸ªå¯ä»¥è¢«åå¤è¯»å†™çš„å†…å­˜åœ°å€ã€‚åœ¨å‡½æ•°ä¸­ï¼Œè¿™é€šå¸¸æ˜¯åœ¨æ ˆï¼ˆStackï¼‰ä¸Šåˆ†é…çš„ã€‚
///
/// 1.  **åˆ†é…å†…å­˜ (`alloca`)**: æˆ‘ä»¬éœ€è¦ä½¿ç”¨ `builder.createAlloca(type)` æŒ‡ä»¤åœ¨å‡½æ•°æ ˆä¸Šä¸ºå˜é‡ `z` åˆ†é…ä¸€å—å†…å­˜ã€‚
/// 2.  **å­˜å‚¨åˆå§‹å€¼ (`store`)**: æŽ¥ç€ï¼Œä½¿ç”¨ `builder.createStore(value, ptr)` æŒ‡ä»¤å°† `x` çš„å€¼å­˜å…¥åˆšåˆšåˆ†é…çš„å†…å­˜åœ°å€ä¸­ã€‚
/// 3.  **æ›´æ–°æ˜ å°„**: åœ¨ `Context` ä¸­ï¼Œæˆ‘ä»¬å°†åå­— `z` æ˜ å°„åˆ° `alloca` æŒ‡ä»¤è¿”å›žçš„**æŒ‡é’ˆ**ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„æ ¸å¿ƒæ˜¯å®žçŽ° `let_stmt_codegen` å’Œ `let_mut_stmt_codegen`ï¼Œå¹¶ä¿®æ”¹ `expr_codegen` ä»¥æ­£ç¡®å¤„ç†å˜é‡çš„åŠ è½½ã€‚
///
/// ### 1. å®žçŽ° `let_stmt_codegen` å’Œ `let_mut_stmt_codegen`
///
/// åœ¨ `codegen/top_function.mbt` ä¸­å®žçŽ°è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œéµå¾ªä¸Šé¢æè¿°çš„é€»è¾‘ã€‚
///
/// ### 2. ä¿®æ”¹ `expr_codegen` ä¸­å¯¹ `Ident` çš„å¤„ç†
///
/// **âš ï¸ è¿™æ˜¯æœ¬æ¬¡æŒ‘æˆ˜çš„å…³é”®ï¼Œä¹Ÿæ˜¯éœ€è¦ç‰¹åˆ«å½“å¿ƒçš„åœ°æ–¹ï¼**
///
/// å½“ `expr_codegen` é‡åˆ°ä¸€ä¸ªå˜é‡ï¼ˆ`Ident(name)`ï¼‰æ—¶ï¼Œå®ƒéœ€è¦ä»Ž `name_values` ä¸­æŸ¥æ‰¾å¯¹åº”çš„ LLVM å€¼ã€‚ä½†çŽ°åœ¨å­˜åœ¨ä¸¤ç§å¯èƒ½ï¼š
///   - è¿™ä¸ªå€¼æ˜¯ä¸€ä¸ªæ™®é€šçš„ SSA å€¼ï¼ˆæ¥è‡ª `let` ç»‘å®šæˆ–è®¡ç®—ç»“æžœï¼‰ã€‚
///   - è¿™ä¸ªå€¼æ˜¯ä¸€ä¸ªæŒ‡å‘æ ˆå†…å­˜çš„æŒ‡é’ˆï¼ˆæ¥è‡ª `let mut` çš„ `alloca`ï¼‰ã€‚
///
/// ä½ éœ€è¦åŒºåˆ†è¿™ä¸¤ç§æƒ…å†µã€‚å¦‚æžœå€¼æ˜¯ä¸€ä¸ª `alloca` æŒ‡é’ˆï¼Œä½ å¿…é¡»åœ¨ä½¿ç”¨å®ƒä¹‹å‰ï¼Œå…ˆç”¨ `builder.createLoad(type, ptr)` æŒ‡ä»¤ä»Žå†…å­˜ä¸­æŠŠçœŸå®žçš„å€¼åŠ è½½å‡ºæ¥ã€‚
///
/// **æç¤º**: ä½ å¯ä»¥é€šè¿‡ `value.asValueEnum() is AllocaInst(_)` æ¥åˆ¤æ–­ä¸€ä¸ª `@llvm.Value` æ˜¯å¦æ˜¯ `alloca` æŒ‡ä»¤çš„ç»“æžœã€‚
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_simple_let_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½ä¸º `let` å’Œ `let mut` æ­£ç¡®ç”Ÿæˆä»£ç ã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚

test "Codegen for Simple Let and LetMut Test" {

  let code = 
    #|fn foo(x: Int) -> Int {
    #|  let z = x;
    #|  z
    #|}
    #|
    #|fn bar(x: Int) -> Int {
    #|  let mut z = x;
    #|  z
    #|}

  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // foo
  let add = knf_prog.functions.get("foo").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(add)
  inspect(llvm_func, content=(
    
    #|define i32 @foo(ptr %0, i32 %1) {
    #|entry:
    #|  ret i32 %1
    #|}
    #|
  ))

  // bar
  let bar = knf_prog.functions.get("bar").unwrap()
  let llvm_func2 = codegen_ctx.top_function_codegen(bar)
  inspect(llvm_func2, content=(
    #|define i32 @bar(ptr %0, i32 %1) {
    #|entry:
    #|  %2 = alloca i32, align 4
    #|  store i32 %1, ptr %2, align 4
    #|  %4 = load i32, ptr %2, align 4
    #|  ret i32 %4
    #|}
    #|
  ))

}
