/// ================================================================================
/// # LLVM Codegen: ä¸€å…ƒè¿ç®—
/// ================================================================================
///
/// åœ¨å¤„ç†å®ŒäºŒå…ƒè¿ç®—åŽï¼Œæˆ‘ä»¬æ¥å¤„ç†æ›´ç®€å•çš„ä¸€å…ƒè¿ç®—ï¼ˆUnary Operationsï¼‰ã€‚
/// åœ¨ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦å…³å¿ƒä¸¤ç§ä¸€å…ƒè¿ç®—ï¼šå–è´Ÿ (`-`) å’Œé€»è¾‘éž (`!`)ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯ç»§ç»­æ‰©å±• `expr_codegen` å‡½æ•°ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç† `KnfExpr::Neg` å’Œ `KnfExpr::Not` è¡¨è¾¾å¼ã€‚
///
/// ## ðŸ’¡ å®žçŽ°æŒ‡å—
///
/// ### é€»è¾‘éž `!`
///
/// å¯¹äºŽå¸ƒå°”ç±»åž‹çš„ `!b` æ“ä½œï¼Œä¸€ä¸ªæ ‡å‡†ä¸”é«˜æ•ˆçš„å®žçŽ°æ–¹å¼æ˜¯ä½¿ç”¨â€œå¼‚æˆ–â€ï¼ˆXORï¼‰è¿ç®—ï¼š
///
/// `!b` ç­‰ä»·äºŽ `b XOR true`
///
/// - **LLVM Builder æŽ¥å£**: `builder.createXor(value, llvm_ctx.getConstTrue())`
///
/// ### å–è´Ÿ `-`
///
/// å–è´Ÿæ“ä½œæ ¹æ®æ“ä½œæ•°çš„ç±»åž‹æœ‰ä¸åŒçš„å®žçŽ°æ–¹å¼ï¼Œè¿™ä¸€ç‚¹éœ€è¦ç‰¹åˆ«æ³¨æ„ã€‚
///
/// #### æ•´æ•°å–è´Ÿ
///
/// å¯¹äºŽæ•´æ•° `-x`ï¼ŒLLVM æ²¡æœ‰æä¾›ä¸€ä¸ªä¸“é—¨çš„ `neg` æŒ‡ä»¤ã€‚æ ‡å‡†çš„å®žçŽ°æ–¹å¼æ˜¯å°†å…¶è½¬æ¢ä¸ºå‡æ³•ï¼š
///
/// `-x` ç­‰ä»·äºŽ `0 - x`
///
/// - **LLVM Builder æŽ¥å£**: `builder.createSub(zero, value)`
///
/// #### æµ®ç‚¹æ•°å–è´Ÿ
///
/// **âš ï¸ è¯·æ³¨æ„**: å¯¹äºŽæµ®ç‚¹æ•° `-x`ï¼Œä½ åº”è¯¥ä½¿ç”¨ä¸“é—¨çš„ `fneg` æŒ‡ä»¤ã€‚
///
/// - **LLVM Builder æŽ¥å£**: `builder.createFNeg(value)`
///
/// **ä¸ºä»€ä¹ˆä¸èƒ½ç”¨ `0.0 - x`ï¼Ÿ**
///
/// è¿™æ˜¯å› ä¸º IEEE 754 æµ®ç‚¹æ•°æ ‡å‡†ä¸­å­˜åœ¨ä¸¤ç§é›¶ï¼š`+0.0` å’Œ `-0.0`ã€‚
/// `fneg` æŒ‡ä»¤ä¿è¯äº†å®ƒä»…ä»…æ˜¯ç¿»è½¬æ“ä½œæ•°çš„ç¬¦å·ä½ï¼Œè¿™æ˜¯æœ€ç²¾ç¡®å’Œé«˜æ•ˆçš„æ–¹å¼ã€‚
/// è€Œ `0.0 - x` ä½œä¸ºä¸€ä¸ªå‡æ³•è¿ç®—ï¼Œåœ¨æŸäº›æ¶‰åŠ `NaN` æˆ–æ— ç©·å¤§çš„è¾¹ç•Œæƒ…å†µä¸‹ï¼Œå…¶è¡Œä¸ºå¯èƒ½ä¸Ž `fneg` ä¸åŒã€‚
///
/// ---
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_unary_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½ä¸ºè¿™å‡ ç§ä¸€å…ƒè¿ç®—æ­£ç¡®ç”Ÿæˆ LLVM IRã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚

test "Codegen for Simple Unary Test" {

  let code = 
    #|fn neg_int(x: Int) -> Int {
    #|  let z = -x;
    #|  z
    #|}
    #|
    #|fn neg_double(x: Double) -> Double {
    #|  let z = -x;
    #|  z
    #|}
    #|
    #|fn not_bool(b: Bool) -> Bool {
    #|  let z = !b;
    #|  z
    #|}

  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // neg_int
  let neg_int = knf_prog.functions.get("neg_int").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(neg_int)
  inspect(llvm_func, content=(
    
    #|define i32 @neg_int(ptr %0, i32 %1) {
    #|entry:
    #|  %2 = sub i32 0, %1
    #|  ret i32 %2
    #|}
    #|
  ))

  // neg_double
  let neg_double = knf_prog.functions.get("neg_double").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(neg_double)
  inspect(llvm_func, content=(
    
    #|define double @neg_double(ptr %0, double %1) {
    #|entry:
    #|  %2 = fneg double %1
    #|  ret double %2
    #|}
    #|

  ))

  // not_bool
  let not_bool = knf_prog.functions.get("not_bool").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(not_bool)
  inspect(llvm_func, content=(
    
    #|define i1 @not_bool(ptr %0, i1 %1) {
    #|entry:
    #|  %2 = xor i1 true, %1
    #|  ret i1 %2
    #|}
    #|

  ))
}