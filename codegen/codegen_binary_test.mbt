/// ================================================================================
/// # LLVM Codegen: äºŒå…ƒè¿ç®—
/// ================================================================================
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥å¤„ç†ç®€å•çš„å˜é‡å’Œå¸¸é‡äº†ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬æ¥ä¸ºä»£ç ç”Ÿæˆæ·»åŠ â€œè®¡ç®—â€èƒ½åŠ›ï¼Œ
/// ä»Žå¤„ç†äºŒå…ƒè¿ç®—ï¼ˆBinary Operationsï¼‰å¼€å§‹ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯æ‰©å±• `expr_codegen` å‡½æ•°ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç† `KnfExpr::Binary` è¡¨è¾¾å¼ã€‚
/// ä½ éœ€è¦æ ¹æ®æ“ä½œç¬¦çš„ç±»åž‹ä»¥åŠæ“ä½œæ•°çš„ç±»åž‹ï¼ˆæ•´æ•°æˆ–æµ®ç‚¹æ•°ï¼‰ï¼Œè°ƒç”¨æ­£ç¡®çš„ LLVM IR Builder æŽ¥å£ã€‚
///
/// ## ðŸ’¡ LLVM Builder API æŽ¥å£æŒ‡å—
///
/// LLVM å¯¹æ•´æ•°å’Œæµ®ç‚¹æ•°æœ‰ä¸åŒçš„æŒ‡ä»¤é›†ã€‚ä½ éœ€è¦é€šè¿‡æ£€æŸ¥æ“ä½œæ•°çš„ç±»åž‹ï¼ˆä¾‹å¦‚ï¼Œ`value.getType().isIEEELikeFPTy()`ï¼‰
/// æ¥å†³å®šä½¿ç”¨å“ªä¸ªç³»åˆ—çš„æŽ¥å£ã€‚
///
/// ### æ•´æ•°ç®—æœ¯è¿ç®—
///
/// | è¿ç®—ç¬¦ | LLVM Builder æŽ¥å£ |
/// | :---: | :--- |
/// | `+`   | `createAdd`         |
/// | `-`   | `createSub`         |
/// | `*`   | `createMul`         |
/// | `/`   | `createSDiv`        | (æœ‰ç¬¦å·é™¤æ³•)
/// | `%`   | `createSRem`        | (æœ‰ç¬¦å·å–ä½™)
///
/// ### æµ®ç‚¹æ•°ç®—æœ¯è¿ç®—
///
/// | è¿ç®—ç¬¦ | LLVM Builder æŽ¥å£ |
/// | :---: | :--- |
/// | `+`   | `createFAdd`        |
/// | `-`   | `createFSub`        |
/// | `*`   | `createFMul`        |
/// | `/`   | `createFDiv`        |
///
/// ### æ¯”è¾ƒè¿ç®—
///
/// æ¯”è¾ƒè¿ç®—ä¼šç”Ÿæˆä¸€ä¸ª `i1`ï¼ˆå³å¸ƒå°”ï¼‰ç±»åž‹çš„ç»“æžœã€‚
///
/// #### æ•´æ•°æ¯”è¾ƒ (`icmp`)
///
/// MoonBit çš„ LLVM API æä¾›äº†å¯¹ LLVM `icmp` æŒ‡ä»¤çš„ç›´æŽ¥å°è£…ã€‚
///
/// | è¿ç®—ç¬¦ | MoonBit LLVM æŽ¥å£ |
/// | :---: | :--- |
/// | `==`  | `createICmpEQ` |
/// | `!=`  | `createICmpNE` |
/// | `>`   | `createICmpSGT`| (Signed Greater Than)
/// | `>=`  | `createICmpSGE`|
/// | `<`   | `createICmpSLT`|
/// | `<=`  | `createICmpSLE`|
///
/// #### æµ®ç‚¹æ•°æ¯”è¾ƒ (`fcmp`)
///
/// ç±»ä¼¼åœ°ï¼Œæµ®ç‚¹æ•°æ¯”è¾ƒä½¿ç”¨ `fcmp` ç³»åˆ—æŽ¥å£ã€‚
///
/// | è¿ç®—ç¬¦ | MoonBit LLVM æŽ¥å£ |
/// | :---: | :--- |
/// | `==`  | `createFCmpOEQ` | (Ordered Equal)
/// | `!=`  | `createFCmpONE` |
/// | `>`   | `createFCmpOGT` |
/// | `>=`  | `createFCmpOGE` |
/// | `<`   | `createFCmpOLT` |
/// | `<=`  | `createFCmpOLE` |
///
/// ---
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_binary_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½ä¸ºè¿™äº›äºŒå…ƒè¿ç®—æ­£ç¡®ç”Ÿæˆ LLVM IRã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚

test "Codegen for Simple Binary Test" {

  let code = 
    #|fn arith_int(x: Int, y: Int) -> Int {
    #|  let z = x + y;
    #|  let z = x - y;
    #|  let z = x * y;
    #|  let z = x / y;
    #|  let z = x % y;
    #|  z
    #|}
    #|
    #|fn arith_double(x: Double, y: Double) -> Double {
    #|  let z = x + y;
    #|  let z = x - y;
    #|  let z = x * y;
    #|  let z = x / y;
    #|  z
    #|}
    #|
    #|fn int_cmp(x: Int, y: Int) -> Bool {
    #|  let a = x == y;
    #|  let b = x != y;
    #|  let c = x < y;
    #|  let d = x <= y;
    #|  let e = x > y;
    #|  let f = x >= y;
    #|  f
    #|}
    #|
    #|fn double_cmp(x: Double, y: Double) -> Bool {
    #|  let a = x == y;
    #|  let b = x != y;
    #|  let c = x < y;
    #|  let d = x <= y;
    #|  let e = x > y;
    #|  let f = x >= y;
    #|  f
    #|}
   


  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // arith_int
  let arith_int = knf_prog.functions.get("arith_int").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(arith_int)
  inspect(llvm_func, content=(
    
    #|define i32 @arith_int(ptr %0, i32 %1, i32 %2) {
    #|entry:
    #|  %3 = add i32 %1, %2
    #|  %4 = sub i32 %1, %2
    #|  %5 = mul i32 %1, %2
    #|  %6 = sdiv i32 %1, %2
    #|  %7 = srem i32 %1, %2
    #|  ret i32 %7
    #|}
    #|
  ))

  // arith_double
  let arith_double = knf_prog.functions.get("arith_double").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(arith_double)
  inspect(llvm_func, content=(
    
    #|define double @arith_double(ptr %0, double %1, double %2) {
    #|entry:
    #|  %3 = fadd double %1, %2
    #|  %4 = fsub double %1, %2
    #|  %5 = fmul double %1, %2
    #|  %6 = fdiv double %1, %2
    #|  ret double %6
    #|}
    #|

  ))

  // int_cmp
  let int_cmp = knf_prog.functions.get("int_cmp").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(int_cmp)
  inspect(llvm_func, content=(
    
    #|define i1 @int_cmp(ptr %0, i32 %1, i32 %2) {
    #|entry:
    #|  %3 = icmp eq i32 %1, %2
    #|  %4 = icmp ne i32 %1, %2
    #|  %5 = icmp slt i32 %1, %2
    #|  %6 = icmp sle i32 %1, %2
    #|  %7 = icmp sgt i32 %1, %2
    #|  %8 = icmp sge i32 %1, %2
    #|  ret i1 %8
    #|}
    #|
  ))

  // double_cmp
  let double_cmp = knf_prog.functions.get("double_cmp").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(double_cmp)
  inspect(llvm_func, content=(
    
    #|define i1 @double_cmp(ptr %0, double %1, double %2) {
    #|entry:
    #|  %3 = fcmp oeq double %1, %2
    #|  %4 = fcmp one double %1, %2
    #|  %5 = fcmp olt double %1, %2
    #|  %6 = fcmp ole double %1, %2
    #|  %7 = fcmp ogt double %1, %2
    #|  %8 = fcmp oge double %1, %2
    #|  ret i1 %8
    #|}
    #|
  ))
}