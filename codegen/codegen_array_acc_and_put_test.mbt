/// ================================================================================
/// # LLVM Codegen: æ•°ç»„çš„è®¿é—®ä¸Žæ›´æ–°
/// ================================================================================
///
/// æˆ‘ä»¬å·²ç»å­¦ä¼šäº†å¦‚ä½•åˆ›å»ºæ•°ç»„ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬æ¥å­¦ä¹ å¦‚ä½•ä¸Žæ•°ç»„è¿›è¡Œäº¤äº’ï¼š
/// è¯»å–æ•°ç»„ä¸­çš„å…ƒç´ ï¼ˆ`get`ï¼‰å’Œæ›´æ–°æ•°ç»„ä¸­çš„å…ƒç´ ï¼ˆ`put`ï¼‰ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯æ‰©å±• `expr_codegen` å’Œ `stmt_codegen`ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†ï¼š
/// 1.  **æ•°ç»„è®¿é—®è¡¨è¾¾å¼** (`KnfExpr::ArrayAccess`)
/// 2.  **æ•°ç»„æ›´æ–°è¯­å¥** (`KnfStmt::ArrayPut`)
///
/// ## ðŸ’¡ å®žçŽ°æŒ‡å—ï¼šè°ƒç”¨å†…å»ºå‡½æ•°
///
/// ä¸Žæ•°ç»„åˆ›å»ºä¸€æ ·ï¼Œå¯¹æ•°ç»„çš„è®¿é—®å’Œæ›´æ–°ä¹Ÿæ˜¯é€šè¿‡è°ƒç”¨ `Context` ä¸­é¢„å…ˆå®šä¹‰å¥½çš„å†…å»ºå‡½æ•°æ¥å®Œæˆçš„ã€‚
/// ä½ éœ€è¦åšçš„å°±æ˜¯æ ¹æ®æ•°ç»„çš„å…ƒç´ ç±»åž‹ï¼Œé€‰æ‹©æ­£ç¡®çš„å‡½æ•°å¹¶ä½¿ç”¨ `builder.createCall` æ¥è°ƒç”¨å®ƒã€‚
///
/// ### æ•°ç»„å…ƒç´ è®¿é—® (Get)
///
/// åœ¨ `expr_codegen` ä¸­å¤„ç† `ArrayAccess(array_name, index_name)` æ—¶ï¼š
///
/// 1.  **ç¡®å®šç±»åž‹**: æ£€æŸ¥ `array_name` çš„ KNF ç±»åž‹ï¼Œç¡®å®šå…¶å…ƒç´ ç±»åž‹ï¼ˆå¦‚ `Int`, `Double` ç­‰ï¼‰ã€‚
/// 2.  **é€‰æ‹©å‡½æ•°**: æ ¹æ®å…ƒç´ ç±»åž‹ï¼Œä»Ž `builtin_funcs` ä¸­èŽ·å–å¯¹åº”çš„ `get` å‡½æ•°ï¼ˆå¦‚ `"array_int_get"`ï¼‰ã€‚
/// 3.  **ç”Ÿæˆè°ƒç”¨**: ä½¿ç”¨ `createCall` ç”Ÿæˆå¯¹è¯¥å‡½æ•°çš„è°ƒç”¨ï¼Œå‚æ•°ä¸ºæ•°ç»„çš„æŒ‡é’ˆå’Œç´¢å¼•å€¼ã€‚
///
/// ### æ•°ç»„å…ƒç´ æ›´æ–° (Put)
///
/// åœ¨ `stmt_codegen` ä¸­æ·»åŠ ä¸€ä¸ªæ–°çš„åˆ†æ”¯æ¥å¤„ç† `ArrayPut(array_name, index_name, value_expr)` è¯­å¥ï¼š
///
/// 1.  **è®¡ç®—å³å€¼**: é¦–å…ˆï¼Œè°ƒç”¨ `expr_codegen` è®¡ç®—å‡º `value_expr` çš„ LLVM å€¼ã€‚
/// 2.  **ç¡®å®šç±»åž‹**: æ£€æŸ¥ `array_name` çš„ KNF ç±»åž‹ä»¥ç¡®å®šå…ƒç´ ç±»åž‹ã€‚
/// 3.  **é€‰æ‹©å‡½æ•°**: æ ¹æ®å…ƒç´ ç±»åž‹ï¼Œä»Ž `builtin_funcs` ä¸­èŽ·å–å¯¹åº”çš„ `put` å‡½æ•°ï¼ˆå¦‚ `"array_int_put"`ï¼‰ã€‚
/// 4.  **ç”Ÿæˆè°ƒç”¨**: ä½¿ç”¨ `createCall` ç”Ÿæˆè°ƒç”¨ï¼Œå‚æ•°ä¸ºæ•°ç»„æŒ‡é’ˆã€ç´¢å¼•å€¼å’Œè¦å­˜å…¥çš„æ–°å€¼ã€‚
///
/// ---
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_array_acc_and_put_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½æ­£ç¡®ç”Ÿæˆå¯¹ `get` å’Œ `put` å†…å»ºå‡½æ•°çš„è°ƒç”¨ã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚

test "Codegen for Array Make Test" {

  let code = 
    #|fn swap_head_two(arr: Array[Int]) -> Unit {
    #|  let t = arr[0];
    #|  arr[0] = arr[1];
    #|  arr[1] = t;
    #|}

  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // make_arr
  let swap_head_two = knf_prog.functions.get("swap_head_two").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(swap_head_two)
  inspect(llvm_func, content=(
    #|define void @swap_head_two(ptr %0, ptr %1) {
    #|entry:
    #|  %2 = getelementptr i32, ptr %1, i32 0
    #|  %3 = load i32, ptr %2, align 4
    #|  %4 = getelementptr i32, ptr %1, i32 1
    #|  %5 = load i32, ptr %4, align 4
    #|  %6 = getelementptr i32, ptr %1, i32 0
    #|  store i32 %5, ptr %6, align 4
    #|  %8 = getelementptr i32, ptr %1, i32 1
    #|  store i32 %3, ptr %8, align 4
    #|  ret void
    #|}
    #|


  ))
}