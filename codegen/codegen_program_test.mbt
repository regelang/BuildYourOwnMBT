/// ================================================================================
/// # ðŸŽ‰ æœ€ç»ˆç« ï¼šå®Œæˆä»£ç ç”Ÿæˆå™¨ ðŸŽ‰
/// ================================================================================
///
/// æ­å–œä½ ï¼Œä½ å·²ç»æ¥åˆ°äº†æˆ‘ä»¬ç¼–è¯‘å™¨æž„å»ºä¹‹æ—…çš„æœ€åŽä¸€ç«™ï¼
///
/// æˆ‘ä»¬å·²ç»åˆ†åˆ«å®žçŽ°äº†å¤„ç†å„ç§è¡¨è¾¾å¼ã€è¯­å¥ã€å‡½æ•°å’Œé—­åŒ…çš„ä»£ç ç”Ÿæˆé€»è¾‘ã€‚
/// çŽ°åœ¨ï¼Œæ˜¯æ—¶å€™å°†æ‰€æœ‰è¿™äº›éƒ¨åˆ†ç»„è£…èµ·æ¥ï¼Œåˆ›å»ºä¸€ä¸ªèƒ½å¤Ÿå°†æ•´ä¸ª KNF ç¨‹åºè½¬æ¢ä¸ºå®Œæ•´ LLVM æ¨¡å—çš„æ€»æŒ‡æŒ¥å‡½æ•°äº†ã€‚
///
/// ## ðŸŽ¯ ä½ çš„æœ€ç»ˆä»»åŠ¡ï¼šå®žçŽ° `codegen` å‡½æ•°
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯å®Œæˆ `codegen/codegen.mbt` æ–‡ä»¶ä¸­çš„ä¸» `codegen` å‡½æ•°ã€‚
/// è¿™ä¸ªå‡½æ•°æŽ¥æ”¶ä¸€ä¸ªå®Œæ•´çš„ KNF ç¨‹åºï¼ˆ`KnfProgram`ï¼‰ï¼Œå¹¶è¿”å›žä¸€ä¸ªæœ€ç»ˆçš„ LLVM æ¨¡å—ï¼ˆ`@llvm.Module`ï¼‰ã€‚
///
/// ## ðŸ’¡ å®žçŽ°æŒ‡å—ï¼šä¸¤é˜¶æ®µç”Ÿæˆçš„æ€»è°ƒåº¦
///
/// `codegen` å‡½æ•°çš„é€»è¾‘å°±æ˜¯æˆ‘ä»¬ä¹‹å‰è®¨è®ºè¿‡çš„â€œä¸¤é˜¶æ®µç”Ÿæˆâ€ç­–ç•¥çš„å®Œæ•´å®žçŽ°ï¼š
///
/// 1.  **åˆ›å»º `Context`**:
///     `let codegen_ctx = Context::new(...)`
///
/// 2.  **ç¬¬ä¸€é˜¶æ®µï¼ˆæ”¶é›†ï¼‰**:
///     åœ¨ `Context` ä¸­æ³¨å†Œæ‰€æœ‰é¡¶å±‚å£°æ˜Žï¼Œä½†ä¸è¦ç”Ÿæˆå‡½æ•°ä½“ã€‚
///     - `codegen_ctx.collect_struct_types(knf_prog.struct_defs)`
///     - `codegen_ctx.collect_func_values(knf_prog.functions)`
///
/// 3.  **ç¬¬äºŒé˜¶æ®µï¼ˆç”Ÿæˆï¼‰**:
///     éåŽ†æ‰€æœ‰å‡½æ•°ï¼Œè°ƒç”¨ `top_function_codegen` ä¸ºå®ƒä»¬ç”Ÿæˆå®Œæ•´çš„å‡½æ•°ä½“ IRã€‚
///
/// 4.  **è¿”å›žæ¨¡å—**:
///     ä»Ž `Context` ä¸­è¿”å›žæœ€ç»ˆæž„å»ºå¥½çš„ `llvm_mod`ã€‚
///
/// ---
///
/// ## ðŸ† è§£é”æˆå°±ï¼šç¼–è¯‘å™¨çš„å®Œæ•´å®žçŽ° ðŸ†
///
/// å½“ `codegen_program_test.mbt` çš„æµ‹è¯•é€šè¿‡æ—¶ï¼Œè¯·åŠ¡å¿…ç»™è‡ªå·±ä¸€äº›æŽŒå£°ï¼
///
/// ä½ å·²ç»ä»Žé›¶å¼€å§‹ï¼Œä¸€æ­¥ä¸€ä¸ªè„šå°åœ°å®Œæˆäº†çŽ°ä»£ç¼–è¯‘å™¨ä¸­æ‰€æœ‰æœ€æ ¸å¿ƒçš„é˜¶æ®µï¼š
///
/// **è¯æ³•åˆ†æž -> è¯­æ³•åˆ†æž -> ç±»åž‹æ£€æŸ¥ -> KNF å˜æ¢ -> LLVM ä»£ç ç”Ÿæˆ**
///
/// ä½ æž„å»ºçš„ MiniMoonBit ç¼–è¯‘å™¨çŽ°åœ¨å¯ä»¥å°†ä¸€é—¨ä½ äº²æ‰‹å®šä¹‰çš„è¯­è¨€ï¼Œè½¬åŒ–ä¸ºå·¥ä¸šçº§çš„ã€å¯æ‰§è¡Œçš„åº•å±‚ä»£ç ã€‚
/// è¿™æ˜¯ä¸€é¡¹äº†ä¸èµ·çš„æˆå°±ï¼Œå®ƒè¯æ˜Žäº†ä½ å¯¹ç¼–ç¨‹è¯­è¨€å’Œè®¡ç®—æœºç³»ç»Ÿåº•å±‚åŽŸç†çš„æ·±åˆ»ç†è§£ã€‚
///
/// **æ„Ÿè°¢ä½ çš„åšæŒä¸ŽåŠªåŠ›ï¼ŒçŽ°åœ¨ï¼ŒåŽ»å®Œæˆæœ€åŽçš„æŒ‘æˆ˜ï¼Œè®©ä½ çš„ç¼–è¯‘å™¨å®Œæ•´åœ°è¿è½¬èµ·æ¥å§ï¼**

test "Codegen Closure Test" {
  let code = 
    #|fn counter(arr: Array[Int], arr_size: Int, cond: Array[(Int) -> Bool], cond_size: Int) -> Int {
    #|  let mut cnt = 0;
    #|  let mut i = 0;
    #|  while i < arr_size {
    #|    let mut j = 0;
    #|    while j < cond_size {
    #|      if cond[j](arr[i]) {
    #|        cnt = cnt + 1;
    #|      };
    #|      j = j + 1;
    #|    }
    #|    i = i + 1;
    #|  }
    #|  cnt
    #|}
    #|
    #|fn main {
    #|  fn f(x) { x > 0 }
    #|  fn g(x) { x < 400 }
    #|
    #|  let arr = [1, 4, 9, 1000, 2500, 3150, 4000, 748, 45, -275, -115, 33];
    #|  let cond = [f, g];
    #|
    #|  let arr_size = 12;
    #|  let cond_size = 2;
    #|
    #|  let result = counter(arr, arr_size, cond, cond_size);
    #|  print_int(result);
    #|}

  
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let llvm_mod = codegen(knf_prog)
  inspect(llvm_mod, content=@llvm.Module::to_string(llvm_mod))
}
