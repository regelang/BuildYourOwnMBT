/// ================================================================================
/// # LLVM Codegen: åˆ›å»ºæ•°ç»„
/// ================================================================================
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥å¤„ç†åŸºæœ¬ç±»åž‹å’Œå˜é‡äº†ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬æ¥å¤„ç†ç¬¬ä¸€ä¸ªå¤åˆç±»åž‹ï¼š**æ•°ç»„ï¼ˆArrayï¼‰**ã€‚
/// æˆ‘ä»¬ä»Žæ•°ç»„çš„åˆ›å»º `Array::make(size, init)` å¼€å§‹ã€‚
///
/// ## å †åˆ†é… vs. æ ˆåˆ†é…
///
/// **âš ï¸ é‡è¦æ¦‚å¿µæé†’**:
///
/// - **æ ˆï¼ˆStackï¼‰**: ç”¨äºŽå­˜æ”¾å‡½æ•°è°ƒç”¨æœŸé—´çš„å±€éƒ¨å˜é‡ï¼ˆæ¯”å¦‚æˆ‘ä»¬ç”¨ `let mut` åˆ›å»ºçš„å˜é‡ï¼‰ã€‚å†…å­˜ç”±ç¼–è¯‘å™¨è‡ªåŠ¨ç®¡ç†ï¼Œå‡½æ•°è¿”å›žæ—¶è‡ªåŠ¨é‡Šæ”¾ã€‚æˆ‘ä»¬ä½¿ç”¨ `alloca` æŒ‡ä»¤åœ¨æ ˆä¸Šåˆ†é…å†…å­˜ã€‚
/// - **å †ï¼ˆHeapï¼‰**: ç”¨äºŽå­˜æ”¾ç”Ÿå‘½å‘¨æœŸæ›´é•¿ã€å¤§å°å¯èƒ½åœ¨è¿è¡Œæ—¶æ‰ç¡®å®šçš„æ•°æ®ï¼ˆæ¯”å¦‚æ•°ç»„ã€ç»“æž„ä½“å®žä¾‹ï¼‰ã€‚å†…å­˜éœ€è¦æ‰‹åŠ¨ç®¡ç†ï¼ˆåœ¨æˆ‘ä»¬çš„ç¼–è¯‘å™¨ä¸­ï¼Œé€šè¿‡è°ƒç”¨ä¸€ä¸ªç®€å•çš„è¿è¡Œæ—¶åº“æ¥æ¨¡æ‹Ÿ `malloc`ï¼‰ã€‚
///
/// åœ¨æˆ‘ä»¬çš„ MiniMoonBit è¯­è¨€ä¸­ï¼Œ**æ•°ç»„å’Œç»“æž„ä½“éƒ½å­˜æ”¾åœ¨å †ä¸Š**ã€‚å› æ­¤ï¼Œæˆ‘ä»¬**ä¸åº”è¯¥**ä½¿ç”¨ `alloca` æ¥ä¸ºæ•°ç»„åˆ†é…ç©ºé—´ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯æ‰©å±• `expr_codegen` å‡½æ•°ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç† `KnfExpr::ArrayMake` è¡¨è¾¾å¼ã€‚
///
/// ## ðŸ’¡ å®žçŽ°æŒ‡å—
///
/// ä½ éœ€è¦è°ƒç”¨ä¸€ä¸ªå®šä¹‰åœ¨ `runtime.c` ä¸­ã€å¹¶é€šè¿‡ `Context` é¢„å…ˆå£°æ˜Žå¥½çš„**å†…å»ºå‡½æ•°ï¼ˆBuiltin Functionï¼‰**æ¥åœ¨å †ä¸Šåˆ›å»ºæ•°ç»„ã€‚
///
/// 1.  **æŸ¥æ‰¾å†…å»ºå‡½æ•°**:
///     åœ¨ `codegen/context.mbt` ä¸­ï¼Œæˆ‘ä»¬å·²ç»ä¸ºä½ å£°æ˜Žäº†ä¸€ç³»åˆ—ç”¨äºŽåˆ›å»ºæ•°ç»„çš„å†…å»ºå‡½æ•°ï¼Œä¾‹å¦‚ `make_int_array`, `make_double_array` ç­‰ï¼Œå¹¶å°†å®ƒä»¬å­˜å‚¨åœ¨äº† `builtin_funcs` è¿™ä¸ª `Map` ä¸­ã€‚
///
/// 2.  **æ ¹æ®ç±»åž‹é€‰æ‹©**:
///     åœ¨ `expr_codegen` ä¸­å¤„ç† `ArrayMake(size_name, init_name)` æ—¶ï¼Œä½ éœ€è¦ï¼š
///     a. æ£€æŸ¥ `init_name` å¯¹åº”çš„ KNF ç±»åž‹ã€‚
///     b. æ ¹æ®è¿™ä¸ªç±»åž‹ï¼Œä»Ž `builtin_funcs` ä¸­é€‰æ‹©æ­£ç¡®çš„åˆ›å»ºå‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœç±»åž‹æ˜¯ `Int`ï¼Œä½ å°±éœ€è¦æŸ¥æ‰¾åä¸º `"make_int_array"` çš„å‡½æ•°ã€‚
///
/// 3.  **ç”Ÿæˆè°ƒç”¨æŒ‡ä»¤**:
///     a. èŽ·å– `size` å’Œ `init` å¯¹åº”çš„ LLVM å€¼ã€‚
///     b. ä½¿ç”¨ `builder.createCall(make_array_func, [size_value, init_value])` æ¥ç”Ÿæˆè°ƒç”¨æŒ‡ä»¤ã€‚
///
/// ---
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_array_make_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½ä¸ºä¸€ä¸ª `Array::make` è¡¨è¾¾å¼æ­£ç¡®ç”Ÿæˆå¯¹å†…å»ºå‡½æ•°çš„è°ƒç”¨ã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚

test "Codegen for Array Make Test" {

  let code = 
    #|fn make_arr(x: Int) -> Array[Int] {
    #|  let arr = Array::make(x, 0);
    #|  arr
    #|}

  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // make_arr
  let make_arr = knf_prog.functions.get("make_arr").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(make_arr)
  inspect(llvm_func, content=(
    
    #|define ptr @make_arr(ptr %0, i32 %1) {
    #|entry:
    #|  %2 = call ptr @minimbt_create_array(i32 %1, i32 0)
    #|  ret ptr %2
    #|}
    #|
  ))
}