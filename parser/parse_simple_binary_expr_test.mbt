/// ================================================================================
/// # ç»ˆææŒ‘æˆ˜ï¼šè§£æäºŒå…ƒè¡¨è¾¾å¼ä¸è¿ç®—ç¬¦ä¼˜å…ˆçº§
///
/// æ¬¢è¿æ¥åˆ° `Expr` è§£æçš„ç»ˆææŒ‘æˆ˜ï¼æˆ‘ä»¬å³å°†è¦æ”»å…‹çš„ï¼Œæ˜¯ç¼–è¯‘å™¨ä¸­æœ€ç»å…¸ã€ä¹Ÿæœ€å…·æŒ‘æˆ˜æ€§çš„é—®é¢˜ä¹‹ä¸€ï¼š
/// **å¸¦æœ‰ä¼˜å…ˆçº§çš„äºŒå…ƒè¡¨è¾¾å¼è§£æï¼ˆBinary Expression Parsing with Precedenceï¼‰**ã€‚
///
/// âš ï¸ **é«˜èƒ½é¢„è­¦ï¼š** è¿™éƒ¨åˆ†å†…å®¹çš„å®ç°éš¾åº¦è¾ƒé«˜ï¼Œå…¶ç®—æ³•å¤æ‚åº¦ä¸äºšäºä¸€é“ LeetCode çš„ä¸­ç­‰åä¸Šéš¾åº¦çš„é¢˜ç›®ã€‚
/// è¯·åšå¥½å……åˆ†çš„å¿ƒç†å‡†å¤‡ï¼Œè¿™å°†æ˜¯ä¸€æ¬¡ç»ä½³çš„ç®—æ³•æ€ç»´é”»ç‚¼ï¼
///
/// ## ğŸ¤” æŒ‘æˆ˜çš„æ ¸å¿ƒï¼šè¿ç®—ç¬¦ä¼˜å…ˆçº§
///
/// ä¸ºä»€ä¹ˆè¿™å¾ˆéš¾ï¼Ÿæ€è€ƒä¸€ä¸‹è¡¨è¾¾å¼ `1 + 2 * 3`ã€‚
///
/// æˆ‘ä»¬äººç±»çŸ¥é“åº”è¯¥å…ˆç®— `2 * 3`ï¼Œå› ä¸º `*` çš„ä¼˜å…ˆçº§é«˜äº `+`ã€‚
/// ä½†æˆ‘ä»¬çš„è§£æå™¨æ˜¯è‡ªå·¦å‘å³è¯»å– Token çš„ã€‚å½“å®ƒçœ‹åˆ° `1 + 2` æ—¶ï¼Œå®ƒå¦‚ä½•çŸ¥é“ä¸èƒ½ç«‹åˆ»å°†å®ƒä»¬ç»„åˆï¼Œ
/// è€Œæ˜¯è¦â€œç­‰å¾…â€åé¢çš„ `*` è¿ç®—å…ˆå®Œæˆå‘¢ï¼Ÿ
///
/// è¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦è§£å†³çš„æ ¸å¿ƒé—®é¢˜ï¼šå®ç°ä¸€ä¸ªèƒ½å¤Ÿç†è§£å¹¶æ­£ç¡®å¤„ç†ä¸åŒè¿ç®—ç¬¦ä¼˜å…ˆçº§çš„è§£æç®—æ³•ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_expr` ä¸­å®ç°å®Œæ•´çš„äºŒå…ƒè¡¨è¾¾å¼è§£æ
///
/// ç°åœ¨ï¼Œè¯·å†æ¬¡å›åˆ° `parser/expr.mbt`ï¼Œå‡†å¤‡å¯¹ `parse_expr` å‡½æ•°è¿›è¡Œä¸€æ¬¡â€œå¤§æ‰‹æœ¯â€ã€‚
///
/// **ğŸ’¡ æ ¸å¿ƒæ€è·¯æç¤ºï¼šåŒæ ˆ
///
/// 1.  **ä¸¤ä¸ªæ ˆï¼š** ä½ å¯ä»¥è€ƒè™‘ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼šä¸€ä¸ªç”¨äºå­˜æ”¾**å¾…å¤„ç†çš„è¿ç®—ç¬¦ï¼ˆOperator Stackï¼‰**ï¼Œå¦ä¸€ä¸ªç”¨äºå­˜æ”¾**å·²ç»è§£æå‡ºçš„è¡¨è¾¾å¼ï¼ˆExpression Stackï¼‰**ã€‚
///
/// 2.  **å¤„ç†æµç¨‹ï¼š**
///     *   å½“ä½ è§£æå‡ºä¸€ä¸ª `ApplyExpr`ï¼ˆæˆ‘ä»¬ç§°ä¹‹ä¸ºä¸€ä¸ªæ“ä½œæ•°ï¼‰æ—¶ï¼Œå°†å®ƒå‹å…¥è¡¨è¾¾å¼æ ˆã€‚
///     *   å½“ä½ é‡åˆ°ä¸€ä¸ªè¿ç®—ç¬¦æ—¶ï¼Œä½ éœ€è¦å°†å®ƒä¸è¿ç®—ç¬¦æ ˆé¡¶çš„è¿ç®—ç¬¦è¿›è¡Œ**ä¼˜å…ˆçº§æ¯”è¾ƒ**ã€‚
///         *   å¦‚æœå½“å‰è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§**é«˜äº**æ ˆé¡¶è¿ç®—ç¬¦ï¼Œè¯´æ˜å®ƒå¯ä»¥â€œæŠ¢å…ˆâ€æ‰§è¡Œï¼Œå°†å®ƒå‹å…¥è¿ç®—ç¬¦æ ˆã€‚
///         *   å¦‚æœå½“å‰è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§**ä½äºæˆ–ç­‰äº**æ ˆé¡¶è¿ç®—ç¬¦ï¼Œè¯´æ˜æ ˆé¡¶çš„è¿ç®—éœ€è¦å…ˆè¿›è¡Œã€‚
///             æ­¤æ—¶ï¼Œä»è¿ç®—ç¬¦æ ˆå¼¹å‡ºä¸€ä¸ªè¿ç®—ç¬¦ï¼Œä»è¡¨è¾¾å¼æ ˆå¼¹å‡ºä¸¤ä¸ªè¡¨è¾¾å¼ï¼Œå°†å®ƒä»¬ç»„åˆæˆä¸€ä¸ªæ–°çš„ `BinaryExpr`ï¼Œ
///             ç„¶åå°†ç»“æœå‹å›è¡¨è¾¾å¼æ ˆã€‚é‡å¤æ­¤è¿‡ç¨‹ï¼Œç›´åˆ°å½“å‰è¿ç®—ç¬¦å¯ä»¥è¢«å‹å…¥æ ˆä¸­ã€‚
///
/// 3.  **æ”¶å°¾å·¥ä½œï¼š** å½“æ‰€æœ‰ Token éƒ½å¤„ç†å®Œæ¯•åï¼Œæ¸…ç©ºè¿ç®—ç¬¦æ ˆä¸­çš„æ‰€æœ‰å‰©ä½™è¿ç®—ç¬¦ï¼Œå®Œæˆæœ€åçš„ç»„åˆã€‚
///
/// è¿™åªæ˜¯ä¸€ä¸ªé«˜å±‚æ¬¡çš„æ€è·¯æ¦‚è¿°ã€‚ä½ éœ€è¦ä»”ç»†æ€è€ƒå…¶ä¸­çš„ç»†èŠ‚ï¼Œä¾‹å¦‚å¾ªç¯æ¡ä»¶ã€æ ˆçš„æ¸…ç©ºæ—¶æœºä»¥åŠå¦‚ä½•å¤„ç†æ‹¬å·ï¼ˆå°½ç®¡æœ¬æµ‹è¯•æš‚ä¸æ¶‰åŠï¼‰ã€‚
///
/// **precedence å‡½æ•°ï¼š**
///
/// ä¸ºäº†å¸®åŠ©ä½ ï¼Œ`parser/expr.mbt` ä¸­å·²ç»ä¸ºä½ æä¾›äº†ä¸€ä¸ª `precedence(op: BinaryOp) -> Int` çš„è¾…åŠ©å‡½æ•°ï¼Œä½ å¯ä»¥ç›´æ¥ä½¿ç”¨å®ƒæ¥è·å–è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆè¿™ä¸ªè‰°å·¨çš„ä»»åŠ¡åï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„æˆæœï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_binary_expr_test.mbt
/// ```
///
/// **ç¥ä½ æŒ‘æˆ˜æˆåŠŸï¼æ”»å…‹äº†å®ƒï¼Œä½ å¯¹è¡¨è¾¾å¼è§£æçš„ç†è§£å°†è¾¾åˆ°ä¸€ä¸ªæ–°çš„é«˜åº¦ï¼**
/// ================================================================================

///|
test "Binary Expr Parsing Test" {
  let code =
    #|1 + 2 * 3 ;
    #|4 * 5 - 6 / 2 ;
    #|a && b || c && d ;
    #|x << 2 + y >> 3 ;
    #|p > q != r < s
  let tokens = @lexer.tokenize(code)
  let (e, tok_view) = parse_expr(tokens[:])
  assert_true(
    e.kind is BinaryExpr(Add, left, right) &&
    left.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(1) &&
    right.kind is BinaryExpr(Mul, left, right) &&
    left.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(2) &&
    right.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(3),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is BinaryExpr(Sub, left1, right1) &&
    left1.kind is BinaryExpr(Mul, left2, right2) &&
    left2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(4) &&
    right2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(5) &&
    right1.kind is BinaryExpr(Div, left3, right3) &&
    left3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(6) &&
    right3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(2),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is BinaryExpr(Or, left1, right1) &&
    left1.kind is BinaryExpr(And, left2, right2) &&
    left2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("a") &&
    right2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("b") &&
    right1.kind is BinaryExpr(And, left3, right3) &&
    left3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("c") &&
    right3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("d"),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is BinaryExpr(ShiftRight, left1, right1) &&
    left1.kind is BinaryExpr(ShiftLeft, left2, right2) &&
    left2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("x") &&
    right2.kind is BinaryExpr(Add, left3, right3) &&
    left3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(2) &&
    right3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("y") &&
    right1.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(3),
  )
  let (e, _) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is BinaryExpr(NE, left1, right1) &&
    left1.kind is BinaryExpr(GT, left2, right2) &&
    left2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("p") &&
    right2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("q") &&
    right1.kind is BinaryExpr(LT, left3, right3) &&
    left3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("r") &&
    right3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("s"),
  )
}
