/// ================================================================================
/// # ç¨‹åºçš„é¡¶å±‚ç»“æž„ï¼šè§£æžé¡¶å±‚å‡½æ•°
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿè§£æžè¯­å¥å’Œå—å†…çš„å±€éƒ¨å‡½æ•°äº†ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬ç»ˆäºŽæ¥åˆ°äº†æž„æˆä¸€ä¸ªå®Œæ•´ç¨‹åºçš„
/// åŸºæœ¬å•å…ƒï¼š**é¡¶å±‚å‡½æ•°ï¼ˆTop-level Functionï¼‰**ã€‚
///
/// ## é¡¶å±‚å‡½æ•° vs. å±€éƒ¨å‡½æ•°
///
/// é¡¶å±‚å‡½æ•°ä¸Žæˆ‘ä»¬ä¹‹å‰è§£æžçš„å±€éƒ¨å‡½æ•°éžå¸¸ç›¸ä¼¼ï¼Œä½†æœ‰å‡ ä¸ªå…³é”®çš„ã€æ›´ä¸¥æ ¼çš„çº¦æŸï¼š
///
/// 1.  **ç±»åž‹æ³¨è§£ï¼š** é¡¶å±‚å‡½æ•°çš„æ‰€æœ‰å‚æ•°éƒ½**å¿…é¡»**æœ‰æ˜Žç¡®çš„ç±»åž‹æ³¨è§£ã€‚
/// 2.  **è¿”å›žç±»åž‹ï¼š** é¡¶å±‚å‡½æ•°**å¿…é¡»**æœ‰æ˜Žç¡®çš„è¿”å›žç±»åž‹æ³¨è§£ã€‚
/// 3.  **main å‡½æ•°ç‰¹ä¾‹ï¼š** `fn main { ... }` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„é¡¶å±‚å‡½æ•°ï¼Œå®ƒæ²¡æœ‰å‚æ•°ï¼Œè¿”å›žç±»åž‹é»˜è®¤ä¸º `Unit`ã€‚
///
/// ## é¡¶å±‚å‡½æ•°çš„ EBNF èŒƒå¼
///
/// ```
/// top_fn ::= "fn" ident "(" (param ("," param)*)? ")" "->" type block_expr
/// param  ::= ident ":" type
/// ```
///
/// **æ³¨æ„ï¼š** è¿™ä¸ª EBNF æè¿°çš„æ˜¯ä¸€èˆ¬æƒ…å†µã€‚ä½ éœ€è¦ç‰¹æ®Šå¤„ç† `fn main`ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `parse_top_function`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/top_function.mbt` ä¸­å®žçŽ° `parse_top_function` å‡½æ•°ã€‚
///
/// **å®žçŽ°æ€è·¯ï¼š**
///
/// è¿™ä¸ªå‡½æ•°çš„è§£æžé€»è¾‘ä¸Ž `parse_local_function` é«˜åº¦é‡åˆï¼Œä½ ç”šè‡³å¯ä»¥å¤ç”¨ä¸€äº›è¾…åŠ©å‡½æ•°ï¼ˆä¾‹å¦‚è§£æžå‚æ•°åˆ—è¡¨ï¼‰ã€‚
/// ä¸»è¦çš„åŒºåˆ«åœ¨äºŽä½ éœ€è¦æ›´ä¸¥æ ¼åœ°æ£€æŸ¥ç±»åž‹æ³¨è§£æ˜¯å¦å­˜åœ¨ã€‚
///
/// 1.  è§£æž `fn` å…³é”®å­—å’Œå‡½æ•°åã€‚
/// 2.  **æ£€æŸ¥æ˜¯å¦ä¸º `main` å‡½æ•°**ï¼Œå¦‚æžœæ˜¯ï¼Œåˆ™å‚æ•°åˆ—è¡¨ä¸ºç©ºï¼Œè¿”å›žç±»åž‹ä¸º `Unit`ï¼Œç„¶åŽç›´æŽ¥è§£æžå‡½æ•°ä½“ã€‚
/// 3.  å¦‚æžœä¸æ˜¯ `main`ï¼Œåˆ™ä¸¥æ ¼æŒ‰ç…§ EBNF è§£æžå¸¦ç±»åž‹æ³¨è§£çš„å‚æ•°åˆ—è¡¨å’Œè¿”å›žç±»åž‹ã€‚
/// 4.  è°ƒç”¨ `parse_block_expr` è§£æžå‡½æ•°ä½“ã€‚
///
/// ç›¸ä¿¡è¿™å¯¹ä½ æ¥è¯´åªæ˜¯å°è¯•ç‰›åˆ€ã€‚åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_top_function_test.mbt
/// ```
/// ================================================================================

///|
test "Top Function Parsing Test - 1" {
  let code =
    #|fn add(x: Int, y: Int) -> Int {
    #|  x + y;
    #|}
  let tokens = @lexer.tokenize(code)
  let (func, _) = parse_top_function(tokens)
  assert_true(func.fname is "add")
  assert_true(func.param_list.length() is 2)
  assert_true(func.param_list[0] is { name: "x", ty: { kind: Int } })
  assert_true(func.param_list[1] is { name: "y", ty: { kind: Int } })
  assert_true(func.ret_ty is { kind: Int })
  assert_true(func.body.stmts.length() is 1)
  assert_true(func.body.stmts[0].kind is ExprStmt(_))
}

///|
test "Main Function Parsing Test - 2 (main)" {
  let code =
    #|fn main {
    #|  let x = 10;
    #|  let y = 20;
    #|  // println(x + y);  // Commented out to avoid unnecessary output during testing
    #|}
  let tokens = @lexer.tokenize(code)
  let (func, _) = parse_top_function(tokens)
  assert_true(func.fname is "main")
  assert_true(func.param_list.length() is 0)
  assert_true(func.ret_ty is { kind: Unit })
  assert_true(func.body.stmts.length() is 2)  // Updated to 2 since println line is commented
  assert_true(func.body.stmts[0].kind is LetStmt(_))
  assert_true(func.body.stmts[1].kind is LetStmt(_))
  // assert_true(func.body.stmts[2].kind is ExprStmt(_))  // Removed since println is commented
}
