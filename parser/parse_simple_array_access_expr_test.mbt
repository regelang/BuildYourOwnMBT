/// ================================================================================
/// # ApplyExpr çš„æ‰©å±•ï¼šæ•°ç»„ç´¢å¼•
///
/// æˆ‘ä»¬å·²ç»ä¸º `ApplyExpr` å®ç°äº†ä¸€ä¸ªæœ€åŸºç¡€çš„åŠŸèƒ½ï¼šåŒ…è£…ä¸€ä¸ª `AtomExpr`ã€‚
/// ç°åœ¨ï¼Œæ˜¯æ—¶å€™ä¸ºå®ƒæ·»åŠ çœŸæ­£çš„â€œåº”ç”¨â€èƒ½åŠ›äº†ï¼Œæˆ‘ä»¬ä»**æ•°ç»„ç´¢å¼•ï¼ˆArray Accessï¼‰**å¼€å§‹ã€‚
///
/// ## æ•°ç»„ç´¢å¼•è¯­æ³•
///
/// æ•°ç»„ç´¢å¼•çš„è¯­æ³•éå¸¸ç›´è§‚ï¼š`array_variable[index_expression]`ã€‚
/// è¿™é‡Œçš„ `array_variable` æ˜¯ä¸€ä¸ª `ApplyExpr`ï¼ˆåœ¨æœ€ç®€å•çš„æƒ…å†µä¸‹ï¼Œæ˜¯ä¸€ä¸ª `AtomExpr`ï¼‰ï¼Œ
/// è€Œ `index_expression` æ˜¯ä¸€ä¸ªå®Œæ•´çš„ `Expr`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_apply_expr` ä¸­å¤„ç† `[...]`
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ‰©å±• `parser/apply_expr.mbt` ä¸­çš„ `parse_apply_expr` å‡½æ•°ï¼Œ
/// ä½¿å…¶èƒ½å¤Ÿåœ¨è§£æå®Œä¸€ä¸ª `AtomExpr` åï¼Œç»§ç»­æ£€æŸ¥å¹¶è§£æç´§éšå…¶åçš„æ•°ç»„ç´¢å¼•æ“ä½œã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  **è§£æåŸºç¡€ï¼š** å‡½æ•°é¦–å…ˆåƒä¹‹å‰ä¸€æ ·ï¼Œè°ƒç”¨ `parse_atom_expr` è§£æå‡ºä¸€ä¸ªåŸºç¡€çš„ `AtomExpr`ï¼Œå¹¶å°†å…¶åŒ…è£…æˆä¸€ä¸ª `ApplyExpr`ã€‚
///
/// 2.  **å‘åçœ‹ï¼š** è§£æå®ŒåŸºç¡€è¡¨è¾¾å¼åï¼Œä¸è¦ç«‹å³è¿”å›ï¼ä½ éœ€è¦æ£€æŸ¥**ä¸‹ä¸€ä¸ª** Tokenã€‚
///
/// 3.  **åŒ¹é… `[`ï¼š**
///     *   å¦‚æœä¸‹ä¸€ä¸ª Token æ˜¯ `[`ï¼Œé‚£ä¹ˆè¯´æ˜ä¸€ä¸ªæ•°ç»„ç´¢å¼•æ“ä½œå¼€å§‹äº†ã€‚
///     *   è·³è¿‡ `[`ã€‚
///     *   è°ƒç”¨æˆ‘ä»¬å¼ºå¤§çš„ `parse_expr` å‡½æ•°æ¥è§£ææ‹¬å·å†…çš„ç´¢å¼•è¡¨è¾¾å¼ã€‚
///     *   ç¡®ä¿ç´¢å¼•è¡¨è¾¾å¼åé¢ç´§è·Ÿç€ä¸€ä¸ª `]`ï¼Œå¹¶è·³è¿‡å®ƒã€‚
///     *   ç°åœ¨ï¼Œä½ æ‹¥æœ‰äº†â€œè¢«ç´¢å¼•çš„æ•°ç»„â€ï¼ˆå°±æ˜¯ä½ ç¬¬ä¸€æ­¥è§£æå‡ºçš„é‚£ä¸ª `ApplyExpr`ï¼‰å’Œâ€œç´¢å¼•å€¼â€ï¼ˆä½ åˆšåˆšè§£æå‡ºçš„ `Expr`ï¼‰ã€‚
///       ç”¨å®ƒä»¬æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ã€ç±»å‹ä¸º `ArrayAccess` çš„ `ApplyExpr`ã€‚è¿™ä¸ªæ–°çš„ `ApplyExpr` ä¼šå°†æ—§çš„ `ApplyExpr` åŒ…è£¹åœ¨å†…ã€‚
///
/// 4.  **ä¸åŒ¹é…ï¼š** å¦‚æœä¸‹ä¸€ä¸ª Token ä¸æ˜¯ `[`ï¼Œé‚£ä¹ˆè¯´æ˜æ²¡æœ‰æ•°ç»„ç´¢å¼•æ“ä½œï¼Œç›´æ¥è¿”å›ç¬¬ä¸€æ­¥è§£æå‡ºçš„ `ApplyExpr` å³å¯ã€‚
///
/// ## ğŸ¤” æ·±å…¥æ€è€ƒï¼šé“¾å¼è°ƒç”¨ `arr[1][2]`
///
/// è¿™ä¸ªæŒ‘æˆ˜çš„æµ‹è¯•ç”¨ä¾‹åŒ…å« `matrix[3][4]` è¿™æ ·çš„é“¾å¼ç´¢å¼•ã€‚
/// å¦‚æœä½ çš„å®ç°æ˜¯æ­£ç¡®çš„ï¼Œå®ƒåº”è¯¥èƒ½è‡ªç„¶åœ°å¤„ç†è¿™ç§æƒ…å†µã€‚
///
/// æ€è€ƒä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆä¸€ä¸ªå¾ªç¯ç»“æ„ï¼ˆ`loop` æˆ– `while`ï¼‰ä¼šæ˜¯å¤„ç†è¿™ç§é“¾å¼è°ƒç”¨çš„ä¼˜é›…æ–¹å¼ï¼Ÿ
/// å½“ä½ è§£æå®Œ `arr[1]` åï¼Œä½ åº”è¯¥å¦‚ä½•å¤„ç†ä¸‹ä¸€ä¸ª `[2]`ï¼Ÿ
/// æ–°ç”Ÿæˆçš„ `ApplyExpr` å’Œä¸Šä¸€è½®çš„ `ApplyExpr` ä¹‹é—´æ˜¯ä»€ä¹ˆå…³ç³»ï¼Ÿ
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_array_access_expr_test.mbt
/// ```
///
/// **ç¥ä½ é¡ºåˆ©ï¼ä½ æ­£åœ¨æ„å»ºä¸€ä¸ªèƒ½å¤Ÿç†è§£è¡¨è¾¾å¼ç»„åˆçš„è§£æå™¨ï¼**
/// ================================================================================

///|
test "Simple Array Access Parsing Test" {
  let code =
    #|arr[42]
    #|matrix[3][4]
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_apply_expr(tokens[:])
  assert_true(
    a.kind is ApplyExprKind::ArrayAccess(arr_access, index_expr) &&
    index_expr.kind is ApplyExpr(app_index) &&
    app_index.kind is AtomExpr(atom_index) &&
    atom_index.kind is Int(42) &&
    arr_access.kind is ApplyExprKind::AtomExpr(atom_arr) &&
    atom_arr.kind is AtomExprKind::Ident("arr"),
  )
  let (a, _) = parse_apply_expr(tok_view)
  assert_true(
    a.kind is ApplyExprKind::ArrayAccess(arr_access2, index_expr2) &&
    index_expr2.kind is ApplyExpr(app_index2) &&
    app_index2.kind is AtomExpr(atom_index2) &&
    atom_index2.kind is Int(4) &&
    arr_access2.kind is ApplyExprKind::ArrayAccess(arr_access1, index_expr1) &&
    index_expr1.kind is ApplyExpr(app_index1) &&
    app_index1.kind is AtomExpr(atom_index1) &&
    atom_index1.kind is Int(3) &&
    arr_access1.kind is ApplyExprKind::AtomExpr(atom_arr) &&
    atom_arr.kind is AtomExprKind::Ident("matrix"),
  )
}
