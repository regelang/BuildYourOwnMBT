/// ================================================================================
/// # ApplyExpr çš„å†æ‰©å±•ï¼šå‡½æ•°è°ƒç”¨
///
/// æˆ‘ä»¬å·²ç»æˆåŠŸåœ°ä¸º `ApplyExpr` æ·»åŠ äº†æ•°ç»„ç´¢å¼•çš„åŠŸèƒ½ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å®Œæˆå®ƒçš„æœ€åä¸€å—æ‹¼å›¾ï¼š
/// **å‡½æ•°è°ƒç”¨ï¼ˆFunction Callsï¼‰**ã€‚
///
/// ## å‡½æ•°è°ƒç”¨è¯­æ³•
///
/// å‡½æ•°è°ƒç”¨çš„è¯­æ³•æ˜¯ `function_name(argument1, argument2, ...)`ã€‚
/// è¿™é‡Œçš„ `function_name` æ˜¯ä¸€ä¸ª `ApplyExpr`ï¼Œè€Œæ‹¬å·å†…çš„å‚æ•°åˆ—è¡¨æ˜¯ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„ `Expr` åˆ—è¡¨ã€‚
///
/// ä½ ä¼šå‘ç°ï¼Œè¿™ä¸ªå‚æ•°åˆ—è¡¨çš„ç»“æ„ä¸æˆ‘ä»¬ä¹‹å‰è§£æè¿‡çš„å…ƒç»„ï¼ˆTupleï¼‰å’Œæ•°ç»„å­—é¢é‡ï¼ˆArray Literalï¼‰å‡ ä¹å®Œå…¨ä¸€æ ·ï¼
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_apply_expr` ä¸­å¤„ç† `(...)`
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ç»§ç»­æ‰©å±• `parser/apply_expr.mbt` ä¸­çš„ `parse_apply_expr` å‡½æ•°ï¼Œ
/// ä½¿å…¶åœ¨è§£æå®Œä¸€ä¸ªåŸºç¡€è¡¨è¾¾å¼åï¼Œèƒ½å¤Ÿç»§ç»­æ£€æŸ¥å¹¶è§£æå‡½æ•°è°ƒç”¨ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// è¿™éƒ¨åˆ†é€»è¾‘ä¸è§£ææ•°ç»„ç´¢å¼•éå¸¸ç›¸ä¼¼ï¼Œå¯ä»¥æ”¾åœ¨åŒä¸€ä¸ªå¾ªç¯ä¸­å¤„ç†ã€‚
///
/// 1.  **è§£æåŸºç¡€ï¼š** å‡½æ•°é¦–å…ˆè§£æå‡ºä¸€ä¸ªåŸºç¡€çš„ `ApplyExpr`ã€‚
///
/// 2.  **å¾ªç¯å‘åçœ‹ï¼š** è¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œæ£€æŸ¥åŸºç¡€è¡¨è¾¾å¼åé¢çš„ Tokenã€‚
///
/// 3.  **åŒ¹é… `(`ï¼š**
///     *   å¦‚æœä¸‹ä¸€ä¸ª Token æ˜¯ `(`ï¼Œé‚£ä¹ˆè¯´æ˜ä¸€ä¸ªå‡½æ•°è°ƒç”¨å¼€å§‹äº†ã€‚
///     *   è·³è¿‡ `(`ã€‚
///     *   æ¥ä¸‹æ¥ï¼Œä½ éœ€è¦è§£ææ‹¬å·å†…çš„å‚æ•°åˆ—è¡¨ã€‚è¿™æ˜¯ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„ `Expr` åˆ—è¡¨ã€‚
///       è¿™ä¸ªé€»è¾‘å’Œè§£æå…ƒç»„/æ•°ç»„çš„å†…éƒ¨éå¸¸ç›¸ä¼¼ï¼Œä½ å¯ä»¥è€ƒè™‘å°†è¿™éƒ¨åˆ†é€»è¾‘æŠ½è±¡æˆä¸€ä¸ªå¯å¤ç”¨çš„è¾…åŠ©å‡½æ•°ï¼Œ
///       ä¾‹å¦‚ `parse_expr_list`ï¼Œå®ƒæ¥æ”¶ Tokenï¼Œè¿”å›ä¸€ä¸ª `Array[Expr]` å’Œå‰©ä½™çš„ Tokenã€‚
///     *   ç¡®ä¿å‚æ•°åˆ—è¡¨åé¢ç´§è·Ÿç€ä¸€ä¸ª `)`ï¼Œå¹¶è·³è¿‡å®ƒã€‚
///     *   ç°åœ¨ï¼Œä½ æ‹¥æœ‰äº†â€œè¢«è°ƒç”¨çš„å‡½æ•°â€ï¼ˆ`callee`ï¼‰å’Œâ€œå‚æ•°åˆ—è¡¨â€ï¼ˆ`args`ï¼‰ã€‚
///       ç”¨å®ƒä»¬æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ã€ç±»å‹ä¸º `Call` çš„ `ApplyExpr`ã€‚
///
/// 4.  **ç»“åˆä¸å¾ªç¯ï¼š**
///     *   è¿™ä¸ªæ–°çš„ `Call` è¡¨è¾¾å¼ä¼šåŒ…è£¹ä½æ—§çš„ `ApplyExpr`ã€‚åœ¨ä¸‹ä¸€æ¬¡å¾ªç¯ä¸­ï¼Œè¿™ä¸ªæ–°çš„ `ApplyExpr`
///       åˆå¯ä»¥ä½œä¸ºæ›´å¤–å±‚è°ƒç”¨ï¼ˆä¾‹å¦‚ `foo(1)(2)`ï¼‰æˆ–è€…æ•°ç»„ç´¢å¼•ï¼ˆä¾‹å¦‚ `foo(1)[2]`ï¼‰çš„åŸºç¡€ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_call_expr_test.mbt
/// ```
///
/// **ç¥è´ºä½ ï¼å®Œæˆè¿™ä¸€æ­¥åï¼Œä½ çš„ `ApplyExpr` è§£æå™¨å°±åŠŸèƒ½å®Œå¤‡äº†ï¼Œèƒ½å¤Ÿå¤„ç†å¤æ‚çš„è¡¨è¾¾å¼ç»„åˆï¼**
/// ================================================================================

///|
test "Simple Call Expr Parsing Test" {
  let code =
    #|foo()
    #|bar(42, true)
    #|qux(1 + 3)
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_apply_expr(tokens[:])
  assert_true(
    a.kind is ApplyExprKind::Call(callee, args) &&
    args is [] &&
    callee.kind is AtomExpr(callee_atom) &&
    callee_atom.kind is AtomExprKind::Ident("foo"),
  )
  let (a, tok_view) = parse_apply_expr(tok_view)
  assert_true(
    a.kind is ApplyExprKind::Call(callee, args) &&
    args is [arg1, arg2] &&
    arg1.kind is ApplyExpr(arg1_app) &&
    arg1_app.kind is AtomExpr(arg1_atom) &&
    arg1_atom.kind is AtomExprKind::Int(42) &&
    arg2.kind is ApplyExpr(arg2_app) &&
    arg2_app.kind is AtomExpr(arg2_atom) &&
    arg2_atom.kind is AtomExprKind::Bool(true) &&
    callee.kind is AtomExpr(callee_atom) &&
    callee_atom.kind is AtomExprKind::Ident("bar"),
  )
  let (a, _) = parse_apply_expr(tok_view)
  assert_true(
    a.kind is ApplyExprKind::Call(callee, args) &&
    args is [arg1] &&
    arg1.kind is BinaryExpr(Add, left, right) &&
    left.kind is ApplyExpr(left_app) &&
    left_app.kind is AtomExpr(left_atom) &&
    left_atom.kind is AtomExprKind::Int(1) &&
    right.kind is ApplyExpr(right_app) &&
    right_app.kind is AtomExpr(right_atom) &&
    right_atom.kind is AtomExprKind::Int(3) &&
    callee.kind is AtomExpr(callee_atom) &&
    callee_atom.kind is AtomExprKind::Ident("qux"),
  )
}
