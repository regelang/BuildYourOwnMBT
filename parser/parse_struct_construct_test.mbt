/// ================================================================================
/// # åˆ›å»ºå®ä¾‹ï¼šè§£æç»“æ„ä½“æ„é€ è¡¨è¾¾å¼
///
/// æˆ‘ä»¬å·²ç»å®šä¹‰äº†ç»“æ„ä½“ï¼ˆStructï¼‰ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥åˆ›å»ºå®ƒçš„å®ä¾‹ã€‚
/// è¿™å°±æ˜¯**ç»“æ„ä½“æ„é€ è¡¨è¾¾å¼ï¼ˆStruct Construction Expressionï¼‰**çš„ä½œç”¨ã€‚
///
/// ## ç»“æ„ä½“æ„é€ çš„ EBNF èŒƒå¼
///
/// ```
/// struct_construct ::= Upper "::" "{" (field_init ("," field_init)* ","? )? "}"
/// field_init       ::= ident ":" expr
/// ```
///
/// è¿™æ®µèŒƒå¼æè¿°äº†å¦‚ä½•åˆ›å»ºä¸€ä¸ªç»“æ„ä½“å®ä¾‹ï¼š
/// 1.  ä»¥ç»“æ„ä½“ç±»å‹åï¼ˆ`Upper` Tokenï¼‰å’Œ `::` å¼€å§‹ã€‚
/// 2.  `{}` å†…éƒ¨æ˜¯å­—æ®µçš„åˆå§‹åŒ–åˆ—è¡¨ã€‚
/// 3.  æ¯ä¸ª `field_init` åŒ…å«ä¸€ä¸ªå­—æ®µå `ident`ã€ä¸€ä¸ªå†’å· `:` å’Œä¸€ä¸ªåˆå§‹åŒ– `expr`ã€‚
/// 4.  å­—æ®µä¹‹é—´ç”¨é€—å· `,` åˆ†éš”ï¼Œå¹¶ä¸”å…è®¸æœ‰ä¸€ä¸ªå°¾éšçš„é€—å·ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_struct_construct`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/struct_construct_expr.mbt` ä¸­å®ç° `parse_struct_construct` å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// è¿™ä¸ªè§£æé€»è¾‘ä¸æˆ‘ä»¬ä¹‹å‰è§£æå…ƒç»„ã€æ•°ç»„å’Œå‡½æ•°å‚æ•°åˆ—è¡¨çš„é€»è¾‘éå¸¸ç›¸ä¼¼ã€‚
///
/// 1.  åŒ¹é…ç»“æ„ä½“åç§°ï¼ˆ`Upper`ï¼‰å’Œ `::{`ã€‚
/// 2.  è¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œè§£æç”±é€—å·åˆ†éš”çš„ `ident: expr` é”®å€¼å¯¹ã€‚
/// 3.  å¾ªç¯ç›´åˆ°é‡åˆ° `}`ã€‚
/// 4.  å°†è§£æå‡ºçš„å­—æ®µå’Œå€¼å­˜å…¥ä¸€ä¸ª `Array`ï¼Œå¹¶åˆ›å»ºä¸€ä¸ª `StructConstructExpr` èŠ‚ç‚¹ã€‚
///
/// ### âš ï¸ ä¸è¦å¿˜è®°ï¼
///
/// å®Œæˆ `parse_struct_construct` åï¼Œä½ è¿˜éœ€è¦å›åˆ° `parser/atom_expr.mbt` ä¸­çš„ `parse_atom_expr` å‡½æ•°ï¼Œ
/// å°†è¿™ä¸ªæ–°çš„è§£æå™¨æ•´åˆè¿›å»ã€‚å½“ `parse_atom_expr` é‡åˆ°ä¸€ä¸ªå¤§å†™å­—æ¯å¼€å¤´çš„æ ‡è¯†ç¬¦ï¼ˆ`Upper` Tokenï¼‰æ—¶ï¼Œ
/// å®ƒéœ€è¦èƒ½å¤Ÿåˆ¤æ–­è¿™ç©¶ç«Ÿæ˜¯ä¸€ä¸ª `Array::make` è¿˜æ˜¯ä¸€ä¸ªç»“æ„ä½“æ„é€ ã€‚
///
/// ç›¸ä¿¡è¿™å¯¹ä½ æ¥è¯´å·²ç»ä¸éš¾äº†ã€‚åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_struct_construct_test.mbt
/// ```
/// ================================================================================

///|
test "Parse Struct Construct Expr" {
  let code =
    #|Data::{ x: [1, 2, 3], y: (4, 5, 6) }
  let tokens = @lexer.tokenize(code)
  let (e, _) = parse_struct_construct(tokens[:])
  assert_true(
    e.kind is StructConstruct(s) &&
    s.name == "Data" &&
    s.fields is [f1, f2] &&
    f1 is ("x", expr1) &&
    f2 is ("y", expr2) &&
    expr1.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(atom1) &&
    atom1.kind is Array([_, _, _]) &&
    expr2.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(atom2) &&
    atom2.kind is Tuple([_, _, _]),
  )
}
