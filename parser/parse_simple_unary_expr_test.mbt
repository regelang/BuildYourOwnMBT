/// ================================================================================
/// # è¡¨è¾¾å¼çš„æ‰©å±•ï¼šä¸€å…ƒæ“ä½œ
///
/// æ­å–œä½ ï¼æˆ‘ä»¬å·²ç»å®ç°äº† `parse_expr` çš„åŸºç¡€ç‰ˆæœ¬ï¼Œå®ƒç°åœ¨èƒ½å¤Ÿå¤„ç†æœ€ç®€å•çš„è¡¨è¾¾å¼äº†ã€‚
/// æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä¸ºå®ƒæ·»åŠ æ–°çš„èƒ½åŠ›ï¼š**è§£æä¸€å…ƒæ“ä½œï¼ˆUnary Expressionsï¼‰**ã€‚
///
/// ## ä»€ä¹ˆæ˜¯ä¸€å…ƒæ“ä½œï¼Ÿ
///
/// ä¸€å…ƒæ“ä½œæ˜¯æŒ‡åªä½œç”¨äºä¸€ä¸ªæ“ä½œæ•°çš„è¡¨è¾¾å¼ã€‚åœ¨ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬æ”¯æŒä¸¤ç§ä¸€å…ƒæ“ä½œï¼š
///
/// 1.  **é€»è¾‘éï¼š** `!true`
/// 2.  **å–åï¼š** `-42`
///
/// è¿™äº›æ“ä½œç¬¦ä½äºå®ƒä»¬æ‰€ä½œç”¨çš„è¡¨è¾¾å¼ä¹‹å‰ï¼Œè¿™ä¸ºæˆ‘ä»¬çš„é€’å½’ä¸‹é™è§£æå™¨æä¾›äº†ä¸€ä¸ªæ¸…æ™°çš„ä¿¡å·ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_expr` ä¸­æ”¯æŒä¸€å…ƒæ“ä½œ
///
/// ç°åœ¨ï¼Œè¯·å†æ¬¡ä¿®æ”¹ `parser/expr.mbt` æ–‡ä»¶ä¸­çš„ `parse_expr` å‡½æ•°ï¼Œä¸ºå…¶å¢åŠ è§£æä¸€å…ƒæ“ä½œçš„åŠŸèƒ½ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// åœ¨ `parse_expr` å‡½æ•°çš„å¼€å¤´ï¼Œæˆ‘ä»¬éœ€è¦â€œå‘å‰çœ‹â€ä¸€ä¸ª Tokenï¼š
///
/// 1.  **æ£€æŸ¥ Token ç±»å‹ï¼š**
///     *   å¦‚æœå½“å‰çš„ Token æ˜¯ `!` (å³ `TokenKind::Not`)ï¼Œæˆ‘ä»¬å°±çŸ¥é“è¿™æ˜¯ä¸€ä¸ªé€»è¾‘éè¡¨è¾¾å¼ã€‚
///     *   å¦‚æœå½“å‰çš„ Token æ˜¯ `-` (å³ `TokenKind::BinaryOp(Sub)`)ï¼Œæˆ‘ä»¬å°±çŸ¥é“è¿™æ˜¯ä¸€ä¸ªå–åè¡¨è¾¾å¼ã€‚
///
/// 2.  **é€’å½’è°ƒç”¨ `parse_expr`ï¼š**
///     *   å¦‚æœåŒ¹é…åˆ°ä¸€å…ƒæ“ä½œç¬¦ï¼Œæˆ‘ä»¬éœ€è¦**è·³è¿‡è¿™ä¸ªæ“ä½œç¬¦ Token**ï¼Œç„¶å**é€’å½’åœ°è°ƒç”¨ `parse_expr`** æ¥è§£æåé¢çš„è¡¨è¾¾å¼éƒ¨åˆ†ã€‚
///
/// 3.  **æ„é€  `Expr` èŠ‚ç‚¹ï¼š**
///     *   åœ¨é€’å½’è°ƒç”¨è¿”å›åï¼Œæˆ‘ä»¬å°†å¾—åˆ°çš„å­è¡¨è¾¾å¼åŒ…è£…åœ¨ä¸€ä¸ªæ–°çš„ä¸€å…ƒè¡¨è¾¾å¼èŠ‚ç‚¹ä¸­ï¼ˆ`NotExpr` æˆ– `NegExpr`ï¼‰ã€‚
///
/// 4.  **é»˜è®¤æƒ…å†µï¼š**
///     *   å¦‚æœå¼€å¤´çš„ Token ä¸æ˜¯ä¸€å…ƒæ“ä½œç¬¦ï¼Œé‚£ä¹ˆå°±æ‰§è¡Œæˆ‘ä»¬ä¹‹å‰å®ç°çš„é€»è¾‘â€”â€”è°ƒç”¨ `parse_apply_expr`ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_unary_expr_test.mbt
/// ```
///
/// è¿™ä¸ªæµ‹è¯•å°†éªŒè¯ä½ çš„ `parse_expr` æ˜¯å¦èƒ½æ­£ç¡®å¤„ç† `!` å’Œ `-` æ“ä½œã€‚
///
/// **ç¥ä½ é¡ºåˆ©ï¼é€šè¿‡é€’å½’ï¼Œæˆ‘ä»¬çš„è§£æå™¨æ­£åœ¨å˜å¾—è¶Šæ¥è¶Šå¼ºå¤§ï¼**
/// ================================================================================

///|
test "Unary Expr Parsing Test" {
  let code =
    #|-42 ;
    #|!true ;
    #|-res ;
    #|!cond ;
  let tokens = @lexer.tokenize(code)
  let (e, tok_view) = parse_expr(tokens[:])
  assert_true(
    e.kind is NegExpr(inner) &&
    inner.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(42),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is NotExpr(inner) &&
    inner.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Bool(true),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is NegExpr(inner) &&
    inner.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("res"),
  )
  let (e, _) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is NotExpr(inner) &&
    inner.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("cond"),
  )
}
