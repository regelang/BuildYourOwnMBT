/// ================================================================================
/// # è¯­å¥çš„åŸºçŸ³ï¼šè§£æ let è¯­å¥
///
/// æˆ‘ä»¬å·²ç»æŒæ¡äº† MiniMoonBit ä¸­æ‰€æœ‰è¡¨è¾¾å¼ã€ç±»å‹å’Œæ¨¡å¼çš„è§£ææ–¹æ³•ã€‚
/// ç°åœ¨ï¼Œæ˜¯æ—¶å€™å°†å®ƒä»¬ç»„åˆèµ·æ¥ï¼Œå¼€å§‹è§£æ**è¯­å¥ï¼ˆStatementsï¼‰**äº†ï¼
///
/// `let` è¯­å¥æ˜¯ MiniMoonBit ä¸­æœ€æ ¸å¿ƒçš„è¯­å¥ï¼Œç”¨äºå°†ä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ç»‘å®šåˆ°ä¸€ä¸ªæ¨¡å¼ä¸Šã€‚
///
/// ## `let` è¯­å¥çš„ EBNF èŒƒå¼
///
/// `let` è¯­å¥çš„ç»“æ„å¯ä»¥ç”¨ EBNFï¼ˆæ‰©å±•å·´ç§‘æ–¯-ç‘™å°”èŒƒå¼ï¼‰æ¸…æ™°åœ°æè¿°ï¼š
///
/// ```
/// let_stmt ::= "let" pattern (":" type)? "=" expr ";"
/// ```
///
/// è¿™æ®µèŒƒå¼å‘Šè¯‰æˆ‘ä»¬ï¼š
/// 1.  ä¸€ä¸ª `let` è¯­å¥ä»¥ `let` å…³é”®å­—å¼€å¤´ã€‚
/// 2.  åé¢è·Ÿç€ä¸€ä¸ªæˆ‘ä»¬å·²ç»ä¼šè§£æçš„ `pattern`ã€‚
/// 3.  å¯é€‰åœ°ï¼ˆ`?` è¡¨ç¤º 0 æ¬¡æˆ– 1 æ¬¡ï¼‰ï¼Œå¯ä»¥æœ‰ä¸€ä¸ªå†’å· `:` å’Œä¸€ä¸ª `type`ã€‚
/// 4.  æ¥ç€æ˜¯ä¸€ä¸ªå¿…é¡»æœ‰çš„ç­‰å· `=` å’Œä¸€ä¸ª `expr`ã€‚
/// 5.  æœ€åå¿…é¡»ä»¥åˆ†å· `;` ç»“å°¾ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_let_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/let_stmt.mbt` ä¸­å®ç° `parse_let_stmt` å‡½æ•°ã€‚
///
/// ç›¸ä¿¡å¯¹äºå·²ç»èº«ç»ç™¾æˆ˜çš„ä½ æ¥è¯´ï¼Œè¿™ä¸ªä»»åŠ¡å·²ç»æ²¡æœ‰ä»€ä¹ˆéš¾åº¦äº†ã€‚
/// ä½ åªéœ€è¦ä¸¥æ ¼æŒ‰ç…§ EBNF èŒƒå¼æè¿°çš„é¡ºåºï¼Œä¾æ¬¡è°ƒç”¨æˆ‘ä»¬å·²ç»å†™å¥½çš„
/// `parse_pattern`, `parse_type`, å’Œ `parse_expr` å‡½æ•°ï¼Œå¹¶æ­£ç¡®å¤„ç†åˆ†éš”ç¬¦ï¼ˆ`:`ã€`=`ã€`;`ï¼‰å³å¯ã€‚
///
/// åŠ æ²¹ï¼Œè¿™æ˜¯æˆ‘ä»¬é€šå‘å®Œæ•´ç¨‹åºè§£æçš„å€’æ•°ç¬¬äºŒæ­¥ï¼ğŸ‰
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_let_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "Let Stmt Parsing Test" {
  let code =
    #|let x : Int = 42;
    #|let (a, b) = (1, 2);
    #|let _ = println();
    #|let (_, (p, q)) = (r, s);
  let tokens = @lexer.tokenize(code)
  let (s, tok_view) = parse_let_stmt(tokens)
  assert_true(
    s.pattern.kind is Ident("x") &&
    s.ty is Some(ty) &&
    ty.kind is Int &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(42),
  )
  let (s, tok_view) = parse_let_stmt(tok_view)
  assert_true(
    s.pattern.kind is Tuple(ps) &&
    ps is [p1, p2] &&
    p1.kind is Ident("a") &&
    p2.kind is Ident("b") &&
    s.ty is None &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Tuple(es) &&
    es is [e1, e2] &&
    e1.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(1) &&
    e2.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(atom2) &&
    atom2.kind is Int(2),
  )
  let (s, tok_view) = parse_let_stmt(tok_view)
  assert_true(
    s.pattern.kind is Wildcard &&
    s.ty is None &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is Call(callee, []) &&
    callee.kind is AtomExpr(atom) &&
    atom.kind is Ident("println"),
  )
  let (s, _) = parse_let_stmt(tok_view)
  assert_true(
    s.pattern.kind is Tuple(ps) &&
    ps is [p1, p2] &&
    p1.kind is Wildcard &&
    p2.kind is Tuple(ps2) &&
    ps2 is [p21, p22] &&
    p21.kind is Ident("p") &&
    p22.kind is Ident("q") &&
    s.ty is None &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Tuple(es) &&
    es is [e1, e2] &&
    e1.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(atom1) &&
    atom1.kind is Ident("r") &&
    e2.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(atom2) &&
    atom2.kind is Ident("s"),
  )
}
