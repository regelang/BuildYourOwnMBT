/// ================================================================================
/// # ç¨‹åºçš„é¡¶å±‚ç»“æ„ï¼šè§£æé¡¶å±‚ let ç»‘å®š
///
/// é™¤äº†é¡¶å±‚å‡½æ•°ï¼Œä¸€ä¸ª MiniMoonBit ç¨‹åºè¿˜å¯ä»¥åŒ…å«é¡¶å±‚çš„ `let` ç»‘å®šï¼Œ
/// ç”¨äºå®šä¹‰å…¨å±€å¸¸é‡ã€‚
///
/// ## é¡¶å±‚ `let` vs. è¯­å¥ `let`
///
/// é¡¶å±‚ `let` ä¸æˆ‘ä»¬åœ¨å‡½æ•°ä½“å†…è§£æçš„ `let` è¯­å¥éå¸¸ç›¸ä¼¼ï¼Œä½†æœ‰ä¸€ä¸ªæ ¸å¿ƒåŒºåˆ«ï¼š
///
/// **é¡¶å±‚ `let` çš„å·¦è¾¹åªèƒ½æ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œä¸èƒ½æ˜¯å¤æ‚çš„æ¨¡å¼ã€‚**
///
/// ## é¡¶å±‚ `let` çš„ EBNF èŒƒå¼
///
/// ```
/// top_let ::= "let" ident (":" type)? "=" expr ";"
/// ```
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_top_let`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/top_let.mbt` ä¸­å®ç° `parse_top_let` å‡½æ•°ã€‚
///
/// è¿™ä¸ªå‡½æ•°çš„é€»è¾‘ä¸æˆ‘ä»¬ä¹‹å‰å®ç°çš„ `parse_let_mut_stmt` å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œ
/// åªæ˜¯å°† `let mut` æ¢æˆäº† `let`ã€‚
///
/// ç›¸ä¿¡è¿™ä¸ªä»»åŠ¡å¯¹ä½ æ¥è¯´å·²ç»éå¸¸è½»æ¾äº†ã€‚
///
/// åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_top_let_test.mbt
/// ```
/// ================================================================================

///|
test "Top Let Parsing Test" {
  let code =
    #|let x: Int = 42;
    #|let y: Bool = true;
    #|let z: Array[Int] = [1, 2, 3];
  let tokens = @lexer.tokenize(code)
  let (s, tok_view) = parse_top_let(tokens)
  assert_true(
    s.name is "x" &&
    s.ty is Some(ty) &&
    ty.kind is Int &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(42),
  )
  let (s, tok_view) = parse_top_let(tok_view)
  assert_true(
    s.name is "y" &&
    s.ty is Some(ty) &&
    ty.kind is Bool &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Bool(true),
  )
  let (s, _) = parse_top_let(tok_view)
  assert_true(
    s.name is "z" &&
    s.ty is Some(ty) &&
    ty.kind is Array(Int) &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Array([e1, e2, e3]) &&
    e1.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(1) &&
    e2.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(atom2) &&
    atom2.kind is Int(2) &&
    e3.kind is ApplyExpr(a3) &&
    a3.kind is AtomExpr(atom3) &&
    atom3.kind is Int(3),
  )
}
