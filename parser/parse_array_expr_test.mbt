/// ================================================================================
/// # æ–¹æ‹¬å·çš„é›†ç»“ï¼šè§£ææ•°ç»„å­—é¢é‡
///
/// æˆ‘ä»¬å·²ç»æˆåŠŸå¤„ç†äº†åœ†æ‹¬å· `()` çš„å¤šç§æƒ…å†µã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥æŒ‘æˆ˜å¦ä¸€ç§å¸¸è§çš„æ‹¬å·ï¼š
/// æ–¹æ‹¬å· `[]`ï¼Œå®ƒåœ¨ MiniMoonBit ä¸­ç”¨äºå®šä¹‰**æ•°ç»„å­—é¢é‡ï¼ˆArray Literalsï¼‰**ã€‚
///
/// ## æ•°ç»„å­—é¢é‡
///
/// æ•°ç»„å­—é¢é‡å…è®¸æˆ‘ä»¬ç›´æ¥åœ¨ä»£ç ä¸­å®šä¹‰ä¸€ä¸ªåŒ…å«å¤šä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œä¾‹å¦‚ï¼š
/// `[1, 2, 3]` æˆ– `["hello", "world"]`ã€‚
///
/// å®ƒçš„ç»“æ„ä¸æˆ‘ä»¬ä¹‹å‰è§£æçš„å…ƒç»„ï¼ˆTupleï¼‰éå¸¸ç›¸ä¼¼ï¼šç”±ä¸€å¯¹æ‹¬å·åŒ…è£¹ï¼Œå†…éƒ¨æ˜¯é€—å·åˆ†éš”çš„è¡¨è¾¾å¼åˆ—è¡¨ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_atom_expr` ä¸­å¤„ç† `[]`
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨ `atom_expr.mbt` ä¸­ï¼Œé€šè¿‡ä¸€ä¸ªæ–°çš„è¾…åŠ©å‡½æ•° `parse_array_expr`
/// æ¥å®ç°å¯¹æ•°ç»„å­—é¢é‡çš„è§£æã€‚`parse_atom_expr` å°†åœ¨é‡åˆ° `[` æ—¶è°ƒç”¨è¿™ä¸ªæ–°å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// å¥½æ¶ˆæ¯æ˜¯ï¼Œè¿™éƒ¨åˆ†é€»è¾‘ä¸æˆ‘ä»¬ä¹‹å‰å®ç°çš„ `parse_paren_expr` é«˜åº¦ç›¸ä¼¼ï¼
///
/// 1.  **å…¥å£ï¼š** å½“ `parse_atom_expr` é‡åˆ° `[` æ—¶ï¼Œå®ƒåº”è¯¥å°†è§£æå·¥ä½œå§”æ‰˜ç»™ `parse_array_expr`ã€‚
///
/// 2.  **`parse_array_expr` çš„é€»è¾‘ï¼š**
///     *   é¦–å…ˆï¼Œè·³è¿‡å¼€å¤´çš„ `[`ã€‚
///     *   è¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œç”¨ `parse_expr` è§£æç”±é€—å·åˆ†éš”çš„è¡¨è¾¾å¼åˆ—è¡¨ã€‚
///     *   å¾ªç¯ç›´åˆ°é‡åˆ°ç»“å°¾çš„ `]`ã€‚
///     *   å°†æ‰€æœ‰è§£æå‡ºçš„ `Expr` æ”¶é›†åˆ°ä¸€ä¸ª `Array` ä¸­ã€‚
///     *   ä½¿ç”¨è¿™ä¸ª `Array[Expr]` æ¥æ„é€ ä¸€ä¸ª `AtomExprKind::Array` èŠ‚ç‚¹ã€‚
///
/// ## ğŸ¤” æ·±å…¥æ€è€ƒï¼šé€—å·çš„è‰ºæœ¯
///
/// æ—¢ç„¶æ•°ç»„å’Œå…ƒç»„çš„è§£æå¦‚æ­¤ç›¸ä¼¼ï¼Œé‚£ä¹ˆå…³äºé€—å·çš„è¾¹ç•Œæƒ…å†µä¹Ÿå€¼å¾—æˆ‘ä»¬å†æ¬¡æ€è€ƒã€‚
/// å¯¹äºä¸€ä¸ªå¥å£®ä¸”ç”¨æˆ·å‹å¥½çš„è¯­è¨€æ¥è¯´ï¼Œä»¥ä¸‹æƒ…å†µæ˜¯å¦åº”è¯¥è¢«æ¥å—ï¼Ÿ
///
/// *   **å°¾éšé€—å·ï¼š** `[1, 2, 3,]`
/// *   **å¼€å¤´é€—å·ï¼š** `[, 1, 2, 3]`
/// *   **è¿ç»­é€—å·ï¼š** `[1, , 2, 3]`
/// *   **å¤šä¸ªå°¾éšé€—å·ï¼š** `[1, 2, 3, ,]`
///
/// ä½ çš„ `parse_paren_expr` çš„å®ç°å¯èƒ½å·²ç»å¤„ç†äº†å…¶ä¸­ä¸€éƒ¨åˆ†æƒ…å†µã€‚
/// åœ¨å®ç° `parse_array_expr` æ—¶ï¼Œä½ å¯ä»¥è€ƒè™‘æ˜¯å¦éœ€è¦ä¸€ä¸ªæ›´é€šç”¨çš„ã€å¯ä»¥è¢«ä¸¤è€…å¤ç”¨çš„åˆ—è¡¨è§£æå‡½æ•°ï¼Œ
/// ä»¥ç¡®ä¿è¯­è¨€åœ¨ä¸åŒè¯­æ³•ç»“æ„ä¸­è¡Œä¸ºçš„ä¸€è‡´æ€§ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_array_expr_test.mbt
/// ```
///
/// **ç¥ä½ é¡ºåˆ©ï¼é€šè¿‡ä»£ç å¤ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥è®©ç¼–è¯‘å™¨å˜å¾—æ›´åŠ ä¼˜é›…å’Œå¥å£®ã€‚**
/// ================================================================================

///|
test "Array Expr Parsing Test" {
  let code =
    #|[42, 3.14, true]
    #|[foo, bar, baz]
    #|[ 1 + 3]
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_atom_expr(tokens[:])
  assert_true(
    a.kind is AtomExprKind::Array(exprs) &&
    exprs is [e1, e2, e3] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(42) &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Double(3.14) &&
    e3.kind is ApplyExpr(app3) &&
    app3.kind is AtomExpr(atom3) &&
    atom3.kind is Bool(true),
  )
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is AtomExprKind::Array(exprs) &&
    exprs is [e1, e2, e3] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Ident("foo") &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Ident("bar") &&
    e3.kind is ApplyExpr(app3) &&
    app3.kind is AtomExpr(atom3) &&
    atom3.kind is Ident("baz"),
  )
  let (a, _) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is AtomExprKind::Array(exprs) &&
    exprs is [e1] &&
    e1.kind is BinaryExpr(Add, left, right) &&
    left.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(1) &&
    right.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Int(3),
  )
}
