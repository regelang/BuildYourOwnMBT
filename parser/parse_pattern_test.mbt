/// ================================================================================
/// # è§£æ„çš„åŠ›é‡ï¼šè§£ææ¨¡å¼
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥è§£æç±»å‹å’Œå¤æ‚çš„è¡¨è¾¾å¼äº†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æ¥å¤„ç†ä¸€ä¸ªä¸å®ƒä»¬ç´§å¯†ç›¸å…³ï¼Œ
/// ä½†åˆæœ‰æ‰€ä¸åŒçš„æ¦‚å¿µï¼š**æ¨¡å¼ï¼ˆPatternï¼‰**ã€‚
///
/// ## ä»€ä¹ˆæ˜¯æ¨¡å¼ï¼Ÿ
///
/// æ¨¡å¼æ˜¯ä¸€ç§ç”¨äºâ€œè§£æ„â€å’Œâ€œç»‘å®šâ€å€¼çš„è¯­æ³•ã€‚ä½ å…¶å®å·²ç»è§è¿‡å®ƒæœ€ç®€å•çš„å½¢å¼äº†ã€‚
/// åœ¨ `let x = ...` ä¸­ï¼Œ`x` å°±æ˜¯ä¸€ä¸ªæœ€ç®€å•çš„æ ‡è¯†ç¬¦æ¨¡å¼ï¼ˆIdentifier Patternï¼‰ï¼Œå®ƒå°† `=` å³ä¾§çš„å€¼ç»‘å®šåˆ°å˜é‡ `x` ä¸Šã€‚
///
/// åœ¨æ›´å®Œå¤‡çš„è¯­è¨€ä¸­ï¼ˆåŒ…æ‹¬ MoonBitï¼Œä½† MiniMoonBit æœªå®ç°ï¼‰ï¼Œæ¨¡å¼ä¼šå¤§æ”¾å¼‚å½©çš„åœ°æ–¹æ˜¯ `match` è¡¨è¾¾å¼ï¼š
///
/// ```moonbit
/// match my_tuple {
///   (x, 0) => // å½“å…ƒç»„ç¬¬äºŒä¸ªå…ƒç´ ä¸º 0 æ—¶ï¼Œå°†ç¬¬ä¸€ä¸ªå…ƒç´ ç»‘å®šåˆ° x
///   (_, y) => // å¿½ç•¥ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå°†ç¬¬äºŒä¸ªå…ƒç´ ç»‘å®šåˆ° y
/// }
/// ```
///
/// åœ¨ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦åœ¨ `let` è¯­å¥ä¸­ä½¿ç”¨æ¨¡å¼ï¼Œä¾‹å¦‚ `let (a, b) = (1, 2)` æ¥åŒæ—¶ç»‘å®šå¤šä¸ªå˜é‡ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_pattern`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/pattern.mbt` ä¸­å®ç° `parse_pattern` å‡½æ•°ã€‚
///
/// MiniMoonBit æ”¯æŒçš„æ¨¡å¼éå¸¸ç®€å•ï¼š
/// 1.  **é€šé…ç¬¦ï¼š** `_`
/// 2.  **æ ‡è¯†ç¬¦ï¼š** `x`
/// 3.  **å…ƒç»„ï¼š** `(p1, p2, ...)`ï¼Œå…¶ä¸­ `p1`, `p2` ç­‰æœ¬èº«ä¹Ÿæ˜¯æ¨¡å¼ã€‚
///
/// ç›¸ä¿¡èªæ˜çš„ä½ å·²ç»å‘ç°ï¼Œè§£ææ¨¡å¼çš„é€»è¾‘ä¸è§£æå…ƒç»„ç±»å‹ã€å…ƒç»„è¡¨è¾¾å¼çš„é€»è¾‘éå¸¸ç›¸ä¼¼ï¼Œ
/// åªæ˜¯æ„æˆå®ƒçš„åŸºæœ¬å…ƒç´ æ›´å°‘ï¼ˆåªæœ‰ `_`, `ident` å’Œ `(...)`ï¼‰ã€‚
///
/// é‰´äºä½ å·²ç»æ˜¯æˆ‘ä»¬è§£æå™¨å¼€å‘çš„â€œè€å…µâ€äº†ï¼Œè¿™é‡Œçš„æ•™ç¨‹å°±ä¸å†èµ˜è¿°ã€‚æ”¾æ‰‹å»å®ç°å§ï¼
///
/// åŠ æ²¹ï¼ğŸš€
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_pattern_test.mbt
/// ```
/// ================================================================================

///|
test "Pattern Parsing Test" {
  let code =
    #|_ 
    #|a
    #|(a, b, _)
    #|(a, (b, c), _)
    #|((a, b), (c, d))
  let tokens = @lexer.tokenize(code)
  let (p, tok_view) = parse_pattern(tokens[:])
  assert_true(p.kind is Wildcard)
  let (p, tok_view) = parse_pattern(tok_view)
  assert_true(p.kind is Ident("a"))
  let (p, tok_view) = parse_pattern(tok_view)
  assert_true(
    p.kind is Tuple(ps) &&
    ps is [p1, p2, p3] &&
    p1.kind is Ident("a") &&
    p2.kind is Ident("b") &&
    p3.kind is Wildcard,
  )
  let (p, tok_view) = parse_pattern(tok_view)
  assert_true(
    p.kind is Tuple(ps) &&
    ps is [p1, p2, p3] &&
    p1.kind is Ident("a") &&
    p2.kind is Tuple(ps2) &&
    ps2 is [p21, p22] &&
    p21.kind is Ident("b") &&
    p22.kind is Ident("c") &&
    p3.kind is Wildcard,
  )
  let (p, _) = parse_pattern(tok_view)
  assert_true(
    p.kind is Tuple(ps) &&
    ps is [p1, p2] &&
    p1.kind is Tuple(ps1) &&
    ps1 is [p11, p12] &&
    p11.kind is Ident("a") &&
    p12.kind is Ident("b") &&
    p2.kind is Tuple(ps2) &&
    ps2 is [p21, p22] &&
    p21.kind is Ident("c") &&
    p22.kind is Ident("d"),
  )
}
