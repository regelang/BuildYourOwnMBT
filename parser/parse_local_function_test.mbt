/// ================================================================================
/// # å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘ï¼šè§£æžå±€éƒ¨å‡½æ•°ä¸Žé—­åŒ…
///
/// åœ¨çŽ°ä»£ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå‡½æ•°ä¸ä»…ä»…æ˜¯é¡¶å±‚çš„ä»£ç ç»„ç»‡å•å…ƒï¼Œå®ƒä»¬è¿˜å¯ä»¥è¢«å®šä¹‰åœ¨å…¶ä»–å‡½æ•°å†…éƒ¨ï¼Œ
/// ç”šè‡³å¯ä»¥ä½œä¸ºå€¼è¢«ä¼ é€’å’Œè¿”å›žã€‚è¿™ç§å¯ä»¥â€œæ•èŽ·â€å…¶å®šä¹‰æ—¶æ‰€åœ¨çŽ¯å¢ƒï¼ˆå³è®¿é—®å¤–éƒ¨å˜é‡ï¼‰çš„å†…éƒ¨å‡½æ•°ï¼Œ
/// å°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„**é—­åŒ…ï¼ˆClosureï¼‰**ã€‚
///
/// MiniMoonBit æ”¯æŒåœ¨ä»£ç å—ä¸­å®šä¹‰**å±€éƒ¨å‡½æ•°ï¼ˆLocal Functionï¼‰**ï¼Œè¿™æ˜¯å®žçŽ°é—­åŒ…çš„ç¬¬ä¸€æ­¥ã€‚
///
/// ## å±€éƒ¨å‡½æ•°çš„ EBNF èŒƒå¼
///
/// ```
/// fn_decl ::= "fn" ident "(" (param ("," param)*)? ")" ("->" type)? block_expr
/// param   ::= ident (":" type)?
/// ```
///
/// è¿™æ®µèŒƒå¼æè¿°äº†å‡½æ•°å£°æ˜Žçš„å„ä¸ªéƒ¨åˆ†ï¼š
/// 1.  `fn` å…³é”®å­—å’Œå‡½æ•°å `ident`ã€‚
/// 2.  `()` åŒ…è£¹çš„å‚æ•°åˆ—è¡¨ï¼Œå‚æ•°ä¹‹é—´ç”¨ `,` åˆ†éš”ã€‚
/// 3.  æ¯ä¸ªå‚æ•° `param` åŒ…å«ä¸€ä¸ªåå­— `ident` å’Œä¸€ä¸ªå¯é€‰çš„ç±»åž‹æ³¨è§£ã€‚
/// 4.  ä¸€ä¸ªå¯é€‰çš„ `->` å’Œè¿”å›žç±»åž‹ `type`ã€‚
/// 5.  ä¸€ä¸ªå‡½æ•°ä½“ `block_expr`ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `parse_local_function`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/local_function.mbt` ä¸­å®žçŽ° `parse_local_function` å‡½æ•°ã€‚
///
/// **å®žçŽ°æ€è·¯ï¼š**
///
/// è§£æžå‡½æ•°çš„ç»“æž„éžå¸¸æ¸…æ™°ï¼Œä½ å¯ä»¥ä¸¥æ ¼æŒ‰ç…§ EBNF çš„é¡ºåºè¿›è¡Œï¼š
/// 1.  è§£æž `fn` å…³é”®å­—å’Œå‡½æ•°åã€‚
/// 2.  è§£æž `()` åŒ…è£¹çš„å‚æ•°åˆ—è¡¨ã€‚è¿™éƒ¨åˆ†æ˜¯ä¸€ä¸ªå¾ªçŽ¯ï¼Œä½ éœ€è¦è§£æžé€—å·åˆ†éš”çš„ `ident` å’Œå¯é€‰çš„ç±»åž‹ã€‚
/// 3.  è§£æžå¯é€‰çš„è¿”å›žç±»åž‹ã€‚
/// 4.  è°ƒç”¨ `parse_block_expr` è§£æžå‡½æ•°ä½“ã€‚
///
/// ç»è¿‡äº†å‰é¢ä¸€ç³»åˆ—çš„è®­ç»ƒï¼Œè¿™ä¸ªä»»åŠ¡å¯¹ä½ æ¥è¯´åº”è¯¥å·²ç»é©¾è½»å°±ç†Ÿäº†ã€‚
///
/// åŠ æ²¹ï¼Œè¿™æ˜¯æˆ‘ä»¬å‘ç€ä¸€ä¸ªåŠŸèƒ½æ›´å®Œå¤‡çš„è¯­è¨€è¿ˆå‡ºçš„é‡è¦ä¸€æ­¥ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_local_function_test.mbt
/// ```
/// ================================================================================

///|
test "Local Function Parsing Test - 1" {
  let code =
    #|fn add(x, y) -> Int {
    #|  x + y;
    #|}
  let tokens = @lexer.tokenize(code)
  let (func, _) = parse_local_function(tokens)
  assert_true(func.fname is "add")
  assert_true(func.param_list.length() is 2)
  assert_true(func.param_list[0] is ("x", None))
  assert_true(func.param_list[1] is ("y", None))
  assert_true(func.ret_ty is Some({ kind: Int }))
  assert_true(func.body.stmts.length() is 1)
  assert_true(func.body.stmts[0].kind is ExprStmt(_))
}

///|
test "Local Function Parsing Test - 2" {
  let code =
    #|fn sin_max(x: Double, y) {
    #|  let sinx = sin(x);
    #|  let siny = sin(y);
    #|  if sinx > siny {
    #|    sinx;
    #|  } else {
    #|    siny;
    #|  };
    #|}
  let tokens = @lexer.tokenize(code)
  let (func, _) = parse_local_function(tokens)
  assert_true(func.fname is "sin_max")
  assert_true(func.param_list.length() is 2)
  assert_true(func.param_list[0] is ("x", Some({ kind: Double })))
  assert_true(func.param_list[1] is ("y", None))
  assert_true(func.ret_ty is None)
  assert_true(func.body.stmts.length() is 3)
  assert_true(func.body.stmts[0].kind is LetStmt(_))
  assert_true(func.body.stmts[1].kind is LetStmt(_))
  assert_true(func.body.stmts[2].kind is ExprStmt(_))
}
