/// ================================================================================
/// # ç¼–è¯‘å™¨â€œå¼€æ´â€ï¼šè§£æç‰¹æ®Šçš„ `Array::make` è¯­æ³•
///
/// åœ¨è®¾è®¡ä¸€é—¨è¯­è¨€æ—¶ï¼Œæœ‰æ—¶æˆ‘ä»¬ä¼šé‡åˆ°ä¸€äº›æ— æ³•é€šè¿‡é€šç”¨è¯­æ³•è§„åˆ™ä¼˜é›…è¡¨è¾¾çš„ç»“æ„ã€‚
/// è¿™æ—¶ï¼Œç¼–è¯‘å™¨å¼€å‘è€…ä¼šé€‰æ‹©â€œå¼€ä¸€ä¸ªæ´â€ï¼Œä¸ºè¿™ç§ç‰¹æ®Šæƒ…å†µç¼–å†™ä¸“é—¨çš„è§£æé€»è¾‘ã€‚
///
/// `Array::make(size, init)` å°±æ˜¯ MiniMoonBit ä¸­çš„ä¸€ä¸ªå…¸å‹ä¾‹å­ã€‚
/// å®ƒçœ‹èµ·æ¥åƒä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œä½†å®é™…ä¸Šæ˜¯ä¸€ç§ç‰¹æ®Šçš„ã€å†…ç½®äºè¯­è¨€æ ¸å¿ƒçš„æ•°ç»„åˆ›å»ºè¯­æ³•ã€‚
/// ä½ å¯ä»¥æŠŠå®ƒç±»æ¯”äº C è¯­è¨€ä¸­çš„ `int arr[n];`ï¼Œè¿™åŒæ ·ä¸æ˜¯ä¸€ä¸ªæ™®é€šçš„å‡½æ•°è°ƒç”¨ï¼Œ
/// è€Œæ˜¯éœ€è¦ç¼–è¯‘å™¨ç‰¹æ®Šå¤„ç†çš„è¯­æ³•ç»“æ„ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_atom_expr` ä¸­å¤„ç† `Array::make`
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨ `atom_expr.mbt` ä¸­ï¼Œé€šè¿‡ä¸€ä¸ªæ–°çš„è¾…åŠ©å‡½æ•° `parse_array_make_expr`
/// æ¥å®ç°å¯¹è¿™ä¸ªç‰¹æ®Šè¯­æ³•çš„è§£æã€‚`parse_atom_expr` å°†åœ¨é‡åˆ° `Array` å…³é”®å­—æ—¶è°ƒç”¨è¿™ä¸ªæ–°å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  **å…¥å£ï¼š** å½“ `parse_atom_expr` é‡åˆ° `Array` è¿™ä¸ª `Upper` ç±»å‹çš„ Token æ—¶ï¼Œ
///     å®ƒåº”è¯¥å°†è§£æå·¥ä½œå§”æ‰˜ç»™ `parse_array_make_expr`ã€‚
///
/// 2.  **`parse_array_make_expr` çš„é€»è¾‘ï¼š**
///     *   è¿™ä¸ªå‡½æ•°éœ€è¦è¿›è¡Œä¸€æ¬¡ç²¾ç¡®çš„â€œæ¨¡å¼åŒ¹é…â€ï¼Œç¡®ä¿æ¥ä¸‹æ¥çš„ Token åºåˆ—æ˜¯ `::`ï¼Œ`make`ï¼Œå’Œ `(`ã€‚
///       å¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆè¿™å¯èƒ½æ˜¯ä¸€ä¸ªæ™®é€šçš„ä»¥ `Array` å¼€å¤´çš„ç±»å‹åï¼Œåº”è¯¥ç«‹å³æŠ¥é”™æˆ–äº¤ç”±å…¶ä»–é€»è¾‘å¤„ç†ï¼ˆåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œç›´æ¥æŠ¥é”™ï¼‰ã€‚
///     *   è·³è¿‡ `Array::make(` è¿™ä¸€å›ºå®šåºåˆ—ã€‚
///     *   è°ƒç”¨ `parse_expr` æ¥è§£ææ•°ç»„çš„**å¤§å°ï¼ˆsizeï¼‰**ã€‚
///     *   ç¡®ä¿ä¸‹ä¸€ä¸ª Token æ˜¯ä¸€ä¸ªé€—å· `,`ï¼Œå¹¶è·³è¿‡å®ƒã€‚
///     *   å†æ¬¡è°ƒç”¨ `parse_expr` æ¥è§£ææ•°ç»„çš„**åˆå§‹å€¼ï¼ˆinitï¼‰**ã€‚
///     *   ç¡®ä¿æœ€åä¸€ä¸ª Token æ˜¯ä¸€ä¸ªå³æ‹¬å· `)`ï¼Œå¹¶è·³è¿‡å®ƒã€‚
///     *   æœ€åï¼Œå°†è§£æå‡ºçš„ `size` å’Œ `init` ä¸¤ä¸ªè¡¨è¾¾å¼ç»„è£…æˆä¸€ä¸ª `ArrayMake` èŠ‚ç‚¹ã€‚
///
/// è¿™ç§ä¸ºç‰¹å®šè¯­æ³•â€œå¼€æ´â€çš„åšæ³•ï¼Œåœ¨çœŸå®çš„ç¼–è¯‘å™¨ä¸­éå¸¸å¸¸è§ï¼Œå®ƒä½“ç°äº†è¯­è¨€è®¾è®¡åœ¨ä¸€è‡´æ€§ä¸å®ç”¨æ€§ä¹‹é—´çš„æƒè¡¡ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_array_make_test.mbt
/// ```
///
/// **ç¥ä½ é¡ºåˆ©ï¼ä½ æ­£åœ¨å­¦ä¹ ç¼–è¯‘å™¨å¼€å‘ä¸­éå¸¸å®ç”¨çš„ä¸€ä¸ªæŠ€å·§ï¼**
/// ================================================================================

///|
test "Array Make Expr Parsing Test" {
  let code =
    #|Array::make(10, 0)
    #|Array::make(5, true)
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_atom_expr(tokens[:])
  assert_true(
    a.kind is AtomExprKind::ArrayMake(size_expr, init_expr) &&
    size_expr.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(10) &&
    init_expr.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Int(0),
  )
  let (a, _) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is AtomExprKind::ArrayMake(size_expr, init_expr) &&
    size_expr.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(5) &&
    init_expr.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Bool(true),
  )
}
