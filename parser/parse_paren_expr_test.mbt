/// ================================================================================
/// # æ‹¬å·çš„é­”æ³•ï¼šåˆ†ç»„ã€å…ƒç»„å’Œå•å…ƒç±»å‹
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿè§£æå¤æ‚çš„äºŒå…ƒè¡¨è¾¾å¼äº†ï¼Œä½†è¿˜æœ‰ä¸€ä¸ªå…³é”®çš„è¯­æ³•ç»“æ„æ²¡æœ‰å¤„ç†ï¼š**æ‹¬å· `()`**ã€‚
/// åœ¨ MiniMoonBitï¼ˆä»¥åŠè®¸å¤šå…¶ä»–è¯­è¨€ï¼‰ä¸­ï¼Œæ‹¬å·æ‰®æ¼”ç€å¤šç§è§’è‰²ï¼Œæˆ‘ä»¬çš„è§£æå™¨å¿…é¡»èƒ½å¤Ÿå‡†ç¡®åœ°è¯†åˆ«å®ƒä»¬ã€‚
///
/// ## æ‹¬å·çš„ä¸‰ç§èº«ä»½
///
/// 1.  **åˆ†ç»„ï¼ˆGroupingï¼‰ï¼š** `(1 + 2) * 3`
///     *   æ‹¬å·å¯ä»¥ç”¨æ¥å¼ºåˆ¶æ”¹å˜è¿ç®—çš„ä¼˜å…ˆçº§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‹¬å·å†…åªåŒ…å«**ä¸€ä¸ª**è¡¨è¾¾å¼ã€‚
///
/// 2.  **å…ƒç»„ï¼ˆTupleï¼‰ï¼š** `(1, "hello", true)`
///     *   å½“æ‹¬å·å†…åŒ…å«ç”±é€—å·åˆ†éš”çš„**å¤šä¸ª**è¡¨è¾¾å¼æ—¶ï¼Œå®ƒå°±æ„æˆäº†ä¸€ä¸ªå…ƒç»„ã€‚
///
/// 3.  **å•å…ƒç±»å‹ï¼ˆUnitï¼‰ï¼š** `()`
///     *   å½“æ‹¬å·å†…**æ²¡æœ‰ä»»ä½•å†…å®¹**æ—¶ï¼Œå®ƒä»£è¡¨ä¸€ä¸ªç‰¹æ®Šçš„å€¼å’Œç±»å‹ï¼š`Unit`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_atom_expr` ä¸­å¤„ç†æ‹¬å·
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨ `atom_expr.mbt` ä¸­ï¼Œé€šè¿‡ä¸€ä¸ªæ–°çš„è¾…åŠ©å‡½æ•° `parse_paren_expr` æ¥å®ç°å¯¹è¿™ä¸‰ç§æƒ…å†µçš„è§£æã€‚
/// `parse_atom_expr` å°†åœ¨é‡åˆ° `(` æ—¶è°ƒç”¨è¿™ä¸ªæ–°å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  **å…¥å£ï¼š** å½“ `parse_atom_expr` é‡åˆ° `(` æ—¶ï¼Œå®ƒåº”è¯¥å°†è§£æå·¥ä½œå§”æ‰˜ç»™ `parse_paren_expr`ã€‚
///
/// 2.  **`parse_paren_expr` çš„é€»è¾‘ï¼š**
///     *   é¦–å…ˆï¼Œè·³è¿‡å¼€å¤´çš„ `(`ã€‚
///     *   ç„¶åï¼Œè¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œå¼€å§‹è§£æå†…éƒ¨çš„è¡¨è¾¾å¼ã€‚è¿™é‡Œå¯ä»¥é€’å½’åœ°è°ƒç”¨ `parse_expr`ã€‚
///     *   æ¯è§£æå®Œä¸€ä¸ªè¡¨è¾¾å¼åï¼Œä½ éœ€è¦æ£€æŸ¥ä¸‹ä¸€ä¸ª Tokenï¼š
///         *   å¦‚æœæ˜¯ `)`ï¼Œé‚£ä¹ˆæ‹¬å·å†…çš„å†…å®¹è§£æå®Œæ¯•ï¼Œå¯ä»¥ç»“æŸå¾ªç¯äº†ã€‚
///         *   å¦‚æœæ˜¯ `,`ï¼Œé‚£ä¹ˆè¯´æ˜åé¢å¯èƒ½è¿˜æœ‰å¦ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä½ éœ€è¦è·³è¿‡è¿™ä¸ªé€—å·ï¼Œç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯ã€‚
///
/// 3.  **åŒºåˆ†ä¸‰ç§æƒ…å†µï¼š**
///     *   å¾ªç¯ç»“æŸåï¼Œæ£€æŸ¥ä½ è§£æå‡ºäº†å¤šå°‘ä¸ªè¡¨è¾¾å¼ï¼š
///         *   **0 ä¸ªï¼š** è¿™æ˜¯ä¸€ä¸ª `Unit`ã€‚
///         *   **1 ä¸ªï¼š** è¿™æ˜¯ä¸€ä¸ªåˆ†ç»„è¡¨è¾¾å¼ `Paren(Expr)`ã€‚
///         *   **å¤šä¸ªï¼š** è¿™æ˜¯ä¸€ä¸ª `Tuple(Array[Expr])`ã€‚
///
/// 4.  æœ€åï¼Œåˆ«å¿˜äº†è·³è¿‡ç»“å°¾çš„ `)`ã€‚
///
/// ## ğŸ¤” æ·±å…¥æ€è€ƒï¼šå°¾éšé€—å·ï¼ˆTrailing Commasï¼‰
///
/// åœ¨è®¾è®¡è§£æå™¨æ—¶ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘ä¸€äº›è¾¹ç•Œæƒ…å†µã€‚è®¸å¤šç°ä»£è¯­è¨€å…è®¸åœ¨åˆ—è¡¨æˆ–å…ƒç»„çš„æœ«å°¾æœ‰ä¸€ä¸ªå°¾éšçš„é€—å·ã€‚
///
/// *   `(1, 2, 3,)` åº”è¯¥æ˜¯åˆæ³•çš„å—ï¼Ÿ
/// *   å¦‚æœå…è®¸ä¸€ä¸ªå°¾éšé€—å·ï¼Œé‚£ä¹ˆ `(1, 2, 3,,)` è¿™ç§åŒ…å«å¤šä¸ªå°¾éšé€—å·çš„æƒ…å†µåˆè¯¥å¦‚ä½•å¤„ç†å‘¢ï¼Ÿ
///
/// åœ¨ä½ çš„å®ç°ä¸­ï¼Œå¯ä»¥æ€è€ƒä¸€ä¸‹å¦‚ä½•ä¼˜é›…åœ°å¤„ç†è¿™äº›æƒ…å†µã€‚ä¸€ä¸ªå¥å£®çš„è§£æå™¨é€šå¸¸ä¼šå…è®¸ä¸€ä¸ªå°¾éšé€—å·ï¼Œä½†ä¼šæ‹’ç»å¤šä¸ªã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_paren_expr_test.mbt
/// ```
///
/// **ç¥ä½ é¡ºåˆ©ï¼è§£æå™¨å¯¹è¯­è¨€çš„ç†è§£æ­£åœ¨å˜å¾—è¶Šæ¥è¶Šç²¾ç»†ï¼**
/// ================================================================================

///|
test "Tuple, Paren and Unit Expr Parisng Test " {
  let code =
    #|(42, 3.14, true)
    #|(foo)
    #|((3.15, false))
    #|()
    #|((), ())
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_atom_expr(tokens[:])
  assert_true(
    a.kind is Tuple(tup) &&
    tup is [e1, e2, e3] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(42) &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Double(3.14) &&
    e3.kind is ApplyExpr(app3) &&
    app3.kind is AtomExpr(atom3) &&
    atom3.kind is Bool(true),
  )
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is Paren(expr) &&
    expr.kind is ApplyExpr(app) &&
    app.kind is AtomExpr(atom) &&
    atom.kind is Ident("foo"),
  )
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is Paren(expr) &&
    expr.kind is ApplyExpr(app) &&
    app.kind is AtomExpr(atom) &&
    atom.kind is Tuple(tup) &&
    tup is [e1, e2] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Double(3.15) &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Bool(false),
  )
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(a.kind is Unit)
  let (a, _) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is Tuple(tup) &&
    tup is [e1, e2] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Unit &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Unit,
  )
}
