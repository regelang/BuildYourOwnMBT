/// ================================================================================
/// # èµ‹å€¼çš„å·¦ä¾§ï¼šè§£æ LeftValue
///
/// æˆ‘ä»¬å³å°†å¼€å§‹è§£æèµ‹å€¼è¯­å¥ï¼ˆAssignment Statementï¼‰ï¼Œè¿™æ˜¯å‘½ä»¤å¼ç¼–ç¨‹çš„æ ¸å¿ƒä¹‹ä¸€ã€‚
/// åœ¨ `let` è¯­å¥ä¸­ï¼Œæˆ‘ä»¬æ˜¯â€œå£°æ˜å¹¶ç»‘å®šâ€ï¼›è€Œåœ¨èµ‹å€¼è¯­å¥ä¸­ï¼Œæˆ‘ä»¬æ˜¯â€œä¿®æ”¹ä¸€ä¸ªå·²å­˜åœ¨çš„å€¼â€ã€‚
///
/// ## èµ‹å€¼è¯­å¥ä¸ LeftValue
///
/// èµ‹å€¼è¯­å¥çš„ç»“æ„å¦‚ä¸‹ï¼š
///
/// ```
/// assign_stmt ::= left_value assign_op expr ";"
/// ```
///
/// è¿™é‡Œçš„ `assign_op` åŒ…æ‹¬ `=`ã€`+=` ç­‰ã€‚
///
/// å…³é”®åœ¨äº `left_value`ï¼ˆå·¦å€¼ï¼‰ã€‚ä»€ä¹ˆæ˜¯å·¦å€¼ï¼Ÿç®€å•æ¥è¯´ï¼Œå°±æ˜¯**å¯ä»¥è¢«æ”¾åœ¨èµ‹å€¼ç¬¦å·å·¦è¾¹çš„ä¸œè¥¿**ã€‚
/// å¹¶ä¸æ˜¯æ‰€æœ‰çš„è¡¨è¾¾å¼éƒ½å¯ä»¥æ˜¯å·¦å€¼ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥å†™ `x = 1`ï¼Œä½†ä¸èƒ½å†™ `x + 1 = 2`ã€‚
///
/// åœ¨ MiniMoonBit ä¸­ï¼Œåˆæ³•çš„å·¦å€¼åŒ…æ‹¬ï¼š
/// 1.  **å˜é‡ï¼š** `x`
/// 2.  **æ•°ç»„å…ƒç´ ï¼š** `arr[i]`
/// 3.  **ç»“æ„ä½“å­—æ®µï¼š** `obj.field`
/// 4.  **ä»¥åŠå®ƒä»¬çš„ç»„åˆï¼š** `obj.arr[i].field`
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_left_value`
///
/// åœ¨è§£æå®Œæ•´çš„èµ‹å€¼è¯­å¥ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆåœ¨ `parser/left_value.mbt` ä¸­å®ç° `parse_left_value` å‡½æ•°ï¼Œ
/// ä¸“é—¨ç”¨äºè§£æèµ‹å€¼ç¬¦å·å·¦è¾¹çš„éƒ¨åˆ†ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// ä»”ç»†è§‚å¯Ÿå·¦å€¼çš„æ„æˆï¼Œä½ ä¼šå‘ç°å®ƒå’Œæˆ‘ä»¬ä¹‹å‰å®ç°çš„ `ApplyExpr` éå¸¸ç›¸ä¼¼ï¼
///
/// `ApplyExpr` æ˜¯ `atom_expr` åé¢è·Ÿç€ä¸€ç³»åˆ—çš„ `(...)`ã€`[...]` æˆ– `.ident`ã€‚
/// è€Œ `LeftValue` æ˜¯ä¸€ä¸ª `ident` åé¢è·Ÿç€ä¸€ç³»åˆ—çš„ `[...]` æˆ– `.ident`ã€‚
///
/// å®ƒå°±åƒä¸€ä¸ªç®€åŒ–ç‰ˆçš„ `ApplyExpr` è§£æå™¨ï¼š
/// 1.  **èµ·ç‚¹ï¼š** `LeftValue` å¿…é¡»ä»¥ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼ˆ`ident`ï¼‰å¼€å§‹ã€‚
/// 2.  **å¾ªç¯ï¼š** åœ¨è§£æå‡ºæ ‡è¯†ç¬¦åï¼Œè¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œå‘åæ£€æŸ¥æ˜¯å¦å­˜åœ¨ `[` æˆ– `.`ã€‚
/// 3.  **ç»„åˆï¼š** å¦‚æœå­˜åœ¨ï¼Œå°±è§£æå¯¹åº”çš„æ•°ç»„ç´¢å¼•æˆ–å­—æ®µè®¿é—®ï¼Œå¹¶ç”¨å®ƒ**åŒ…è£¹**ä½ä¹‹å‰è§£æå‡ºçš„ `LeftValue`ï¼Œå½¢æˆä¸€ä¸ªæ–°çš„ `LeftValue`ã€‚
/// 4.  **ç»“æŸï¼š** å¾ªç¯ç›´åˆ°åé¢å†ä¹Ÿæ²¡æœ‰ `[` æˆ– `.` ä¸ºæ­¢ã€‚
///
/// ç›¸ä¿¡è¿™ä¸ªè¿‡ç¨‹å¯¹ä½ æ¥è¯´å·²ç»éå¸¸ç†Ÿæ‚‰äº†ã€‚åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_left_value_test.mbt
/// ```
/// ================================================================================

///|
test "LeftValue Parsing Test" {
  let code =
    #|obj.field1[0] ;
    #|matrix[1][2] ;
    #|arr[3][5].field
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_left_value(tokens[:])
  assert_true(
    a.kind is ArrayAccess(array_access, index_expr) &&
    index_expr.kind is ApplyExpr(index_app) &&
    index_app.kind is AtomExpr(index_atom) &&
    index_atom.kind is Int(0) &&
    array_access.kind is FieldAccess(field_access, field_name) &&
    field_name is "field1" &&
    field_access.kind is Ident("obj"),
  )
  let (a, tok_view) = parse_left_value(tok_view[1:])
  assert_true(
    a.kind is ArrayAccess(array_access2, index_expr2) &&
    index_expr2.kind is ApplyExpr(index_app2) &&
    index_app2.kind is AtomExpr(index_atom2) &&
    index_atom2.kind is Int(2) &&
    array_access2.kind is ArrayAccess(array_access1, index_expr1) &&
    index_expr1.kind is ApplyExpr(index_app1) &&
    index_app1.kind is AtomExpr(index_atom1) &&
    index_atom1.kind is Int(1) &&
    array_access1.kind is Ident("matrix"),
  )
  let (a, _) = parse_left_value(tok_view[1:])
  assert_true(
    a.kind is FieldAccess(field_access2, field_name2) &&
    field_name2 is "field" &&
    field_access2.kind is ArrayAccess(array_access3, index_expr3) &&
    index_expr3.kind is ApplyExpr(index_app3) &&
    index_app3.kind is AtomExpr(index_atom3) &&
    index_atom3.kind is Int(5) &&
    array_access3.kind is ArrayAccess(array_access4, index_expr4) &&
    index_expr4.kind is ApplyExpr(index_app4) &&
    index_app4.kind is AtomExpr(index_atom4) &&
    index_atom4.kind is Int(3) &&
    array_access4.kind is Ident("arr"),
  )
}
