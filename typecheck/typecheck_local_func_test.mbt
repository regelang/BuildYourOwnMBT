/// ================================================================================
/// # ç»ˆæžæŒ‘æˆ˜ï¼šç±»åž‹æ£€æŸ¥å±€éƒ¨å‡½æ•°ä¸Žé—­åŒ…
///
/// æ¬¢è¿Žæ¥åˆ°ç±»åž‹æ£€æŸ¥é˜¶æ®µæœ€å…·æŒ‘æˆ˜æ€§ã€ä¹Ÿæœ€è§åŠŸåŠ›çš„éƒ¨åˆ†ï¼š**æ£€æŸ¥å±€éƒ¨å‡½æ•°ï¼ˆLocal Functionsï¼‰**ã€‚
///
/// ä¸Žå¿…é¡»æ˜Žç¡®æ ‡æ³¨æ‰€æœ‰ç±»åž‹çš„é¡¶å±‚å‡½æ•°ä¸åŒï¼Œå±€éƒ¨å‡½æ•°å…è®¸çœç•¥ç±»åž‹ï¼Œè¿™å°±è¦æ±‚æˆ‘ä»¬çš„ç¼–è¯‘å™¨å…·å¤‡çœŸæ­£çš„**ç±»åž‹æŽ¨æ–­**èƒ½åŠ›ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_local_function`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/local_function.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_local_function` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯ï¼šç«‹å³æ£€æŸ¥ä¸Žåˆä¸€
///
/// æ£€æŸ¥ä¸€ä¸ªå±€éƒ¨å‡½æ•° `fn f(a, b: T) { ... }` çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š
///
/// 1.  **åˆ›å»ºå‡½æ•°ç±»åž‹ï¼š**
///     *   éåŽ†å‡½æ•°çš„å‚æ•°åˆ—è¡¨ã€‚
///     *   å¦‚æžœå‚æ•°æœ‰ç±»åž‹æ³¨è§£ï¼ˆå¦‚ `b: T`ï¼‰ï¼Œåˆ™è½¬æ¢è¯¥ç±»åž‹ã€‚
///     *   å¦‚æžœå‚æ•°æ²¡æœ‰ç±»åž‹æ³¨è§£ï¼ˆå¦‚ `a`ï¼‰ï¼Œåˆ™**åˆ›å»ºä¸€ä¸ªæ–°çš„ç±»åž‹å˜é‡ `TypeVar`** ä½œä¸ºå…¶ç±»åž‹çš„å ä½ç¬¦ã€‚
///     *   å¯¹è¿”å›žå€¼æ‰§è¡ŒåŒæ ·çš„æ“ä½œï¼šæœ‰æ³¨è§£åˆ™ä½¿ç”¨ï¼Œæ— æ³¨è§£åˆ™åˆ›å»º `TypeVar`ã€‚
///     *   å°†è¿™äº›å‚æ•°ç±»åž‹å’Œè¿”å›žç±»åž‹ç»„åˆæˆä¸€ä¸ª `Function` ç±»åž‹ã€‚ä¾‹å¦‚ `fn f(a, b: Int)` çš„ç±»åž‹å°±æ˜¯ `Function([TypeVar(0), Int], TypeVar(1))`ã€‚
///
/// 2.  **æ›´æ–°çŽ¯å¢ƒï¼ˆä¸´æ—¶ï¼‰ï¼š**
///     *   å°†è¿™ä¸ªæ–°åˆ›å»ºçš„ã€å¯èƒ½åŒ…å« `TypeVar` çš„å‡½æ•°ç±»åž‹ï¼Œä¸Žå…¶åå­— `f` ä¸€èµ·ï¼Œæ·»åŠ åˆ°**å½“å‰**çš„ç±»åž‹çŽ¯å¢ƒä¸­ã€‚è¿™ä½¿å¾—å‡½æ•°å¯ä»¥é€’å½’åœ°è°ƒç”¨è‡ªå·±ã€‚
///
/// 3.  **æ£€æŸ¥å‡½æ•°ä½“ï¼ˆç«‹å³æ‰§è¡Œï¼ï¼‰ï¼š**
///     *   **è¿›å…¥æ–°ä½œç”¨åŸŸï¼š** è°ƒç”¨ `enter_scope()`ã€‚
///     *   **è®¾ç½®è¿”å›žç±»åž‹ï¼š** å°† `Context` çš„ `current_func_ret_ty` è®¾ç½®ä¸ºåˆšåˆšåˆ›å»ºçš„å‡½æ•°è¿”å›žç±»åž‹ï¼ˆå¯èƒ½æ˜¯ `TypeVar`ï¼‰ã€‚
///     *   **æ·»åŠ å‚æ•°åˆ°çŽ¯å¢ƒï¼š** å°†æ‰€æœ‰å‚æ•°ï¼ˆåŒ…æ‹¬ç±»åž‹ä¸º `TypeVar` çš„å‚æ•°ï¼‰æ·»åŠ åˆ°è¿™ä¸ªæ–°çš„ä½œç”¨åŸŸä¸­ã€‚
///     *   **æ£€æŸ¥å‡½æ•°ä½“ï¼š** è°ƒç”¨ `check_block_expr` æ£€æŸ¥å‡½æ•°ä½“ã€‚åœ¨æ£€æŸ¥è¿‡ç¨‹ä¸­ï¼Œ`is_type_compatible` ä¼šè¢«å¤§é‡è°ƒç”¨ï¼Œé©±åŠ¨ç±»åž‹å˜é‡çš„**åˆä¸€**ï¼ˆUnificationï¼‰ï¼Œä»Žè€ŒæŽ¨æ–­å‡ºå…·ä½“ç±»åž‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœå‡½æ•°ä½“ä¸­æœ‰ `a > b`ï¼Œé‚£ä¹ˆ `a` å’Œ `b` çš„ç±»åž‹å˜é‡å°±ä¼šè¢«åˆä¸€ã€‚
///     *   **éªŒè¯è¿”å›žç±»åž‹ï¼š** æ£€æŸ¥å‡½æ•°ä½“çš„æœ€ç»ˆç±»åž‹æ˜¯å¦ä¸Žå‡½æ•°çš„è¿”å›žç±»åž‹å…¼å®¹ã€‚
///     *   **ç¦»å¼€ä½œç”¨åŸŸï¼š** è°ƒç”¨ `exit_scope()`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_local_func_test.mbt
/// ```
/// ================================================================================

///|
test "Local Function Type Check Test" {
  let code =
    #|fn max(a, b) {
    #|  if a > b { a } else { b }
    #|}
    #|
    #|let _ = max(10, 20);
    #|let _ = max(1.0, 2.0); // This should raise a type error
  let ctx = Context::new()
  // Parse
  let tokens = @lexer.tokenize(code)
  let (local_func, tok_view) = @parser.parse_local_function(tokens[:])
  // TypeCheck
  let _ = ctx.check_local_function(local_func)
  // parse and check let statement
  let (let_stmt, tok_view) = @parser.parse_let_stmt(tok_view)
  let let_stmt = ctx.check_let_stmt(let_stmt)
  assert_true(let_stmt.ty is Int)
  let (let_stmt2, _) = @parser.parse_let_stmt(tok_view)
  let let_stmt2 = try? ctx.check_let_stmt(let_stmt2)
  assert_true(let_stmt2 is Err(_))
}
