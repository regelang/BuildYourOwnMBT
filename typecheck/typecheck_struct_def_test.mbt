/// ================================================================================
/// # ç±»å‹æ£€æŸ¥è‡ªå®šä¹‰ç±»å‹ï¼šç»“æ„ä½“
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿå°† parser è§£æå‡ºçš„ç±»å‹è½¬æ¢ä¸ºç±»å‹æ£€æŸ¥å™¨ä¸­çš„å†…éƒ¨è¡¨ç¤ºäº†ã€‚
/// ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å¤„ç†ä¸€ä¸ªæ›´é‡è¦çš„éƒ¨åˆ†ï¼š**æ£€æŸ¥ç”¨æˆ·è‡ªå®šä¹‰çš„ç»“æ„ä½“ï¼ˆStructï¼‰**ã€‚
///
/// å½“æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸ªç»“æ„ä½“å®šä¹‰æ—¶ï¼Œä¸»è¦ä»»åŠ¡æ˜¯éªŒè¯å…¶æ‰€æœ‰å­—æ®µçš„ç±»å‹éƒ½æ˜¯å·²çŸ¥çš„ã€åˆæ³•çš„ç±»å‹ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `check_struct_def`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/struct_def.mbt` æ–‡ä»¶ä¸­å®ç° `Context::check_struct_def` å‡½æ•°ã€‚
///
/// è¿™ä¸ªå‡½æ•°æ¥æ”¶ä¸€ä¸ªä» parser ä¼ æ¥çš„ `StructDef`ï¼Œç„¶åéœ€è¦ï¼š
/// 1.  éå†ç»“æ„ä½“çš„æ¯ä¸€ä¸ªå­—æ®µã€‚
/// 2.  è°ƒç”¨æˆ‘ä»¬ä¹‹å‰å®ç°çš„ `check_parser_type`ï¼Œå°†æ¯ä¸ªå­—æ®µçš„ parser ç±»å‹è½¬æ¢ä¸ºç±»å‹æ£€æŸ¥å™¨çš„å†…éƒ¨ç±»å‹ã€‚
/// 3.  æ„é€ å¹¶è¿”å›ä¸€ä¸ªæ–°çš„ã€å·²æ£€æŸ¥è¿‡çš„ `StructDef`ï¼ˆè¿™é‡Œçš„â€œæ–°â€æŒ‡çš„æ˜¯ç±»å‹æ£€æŸ¥å™¨å†…éƒ¨çš„ AST èŠ‚ç‚¹ï¼Œå…¶å®šä¹‰å¯èƒ½ä¸ parser çš„ç•¥æœ‰ä¸åŒï¼‰ã€‚
///
/// ---
///
/// ### ğŸ¤” æ·±å…¥æ€è€ƒï¼šå¾ªç¯å¼•ç”¨ä¸å‰å‘å¼•ç”¨
///
/// åœ¨å®ç° `check_struct_def` æ—¶ï¼Œä¸€ä¸ªéå¸¸ç»å…¸çš„ç¼–è¯‘å™¨é—®é¢˜ä¼šæ‘†åœ¨ä½ çš„é¢å‰ï¼š
///
/// è€ƒè™‘ä»¥ä¸‹ä»£ç ï¼š
///
/// ```moonbit
/// struct Node {
///   next: List; // `List` åœ¨è¿™é‡Œè¢«ä½¿ç”¨
/// }
///
/// struct List {
///   head: Node; // `Node` åœ¨è¿™é‡Œè¢«ä½¿ç”¨
/// }
/// ```
///
/// å½“ç±»å‹æ£€æŸ¥å™¨å¤„ç† `struct Node` æ—¶ï¼Œå®ƒé‡åˆ°äº† `List` ç±»å‹ã€‚ä½†æ­¤æ—¶ï¼Œ`List` ç»“æ„ä½“è¿˜å°šæœªè¢«å¤„ç†ï¼
/// è¿™ç§åœ¨å®šä¹‰ä¹‹å‰å°±è¢«å¼•ç”¨çš„æƒ…å†µï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º**å‰å‘å¼•ç”¨ï¼ˆForward Referenceï¼‰**ã€‚
///
/// **è¯·ä½ æƒ³ä¸€æƒ³ï¼š**
///
/// > æˆ‘ä»¬çš„ç±»å‹æ£€æŸ¥å™¨åº”è¯¥å¦‚ä½•è®¾è®¡ï¼Œæ‰èƒ½æ­£ç¡®å¤„ç†è¿™ç§æƒ…å†µï¼Ÿ
/// > å¦‚æœåªæ˜¯ç®€å•åœ°ä»ä¸Šåˆ°ä¸‹ä¾æ¬¡å¤„ç†æ¯ä¸ªç»“æ„ä½“å®šä¹‰ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
///
/// **ğŸ’¡ æç¤ºï¼šä¸¤é˜¶æ®µå¤„ç†ï¼ˆTwo-Passï¼‰**
///
/// è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªç»å…¸æ–¹æ³•æ˜¯é‡‡ç”¨â€œä¸¤é˜¶æ®µå¤„ç†â€ï¼š
///
/// 1.  **ç¬¬ä¸€é˜¶æ®µï¼ˆæ³¨å†Œé˜¶æ®µï¼‰ï¼š** éå†æ‰€æœ‰çš„ç»“æ„ä½“å®šä¹‰ï¼Œä½†åªè®°å½•ä¸‹å®ƒä»¬çš„**åå­—**ã€‚å°†æ‰€æœ‰ç»“æ„ä½“çš„åå­—æ³¨å†Œåˆ°ä¸€ä¸ªé›†åˆæˆ– `Map` ä¸­ï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±çŸ¥é“â€œå­˜åœ¨å“ªäº›ç»“æ„ä½“â€ã€‚
/// 2.  **ç¬¬äºŒé˜¶æ®µï¼ˆæ£€æŸ¥é˜¶æ®µï¼‰ï¼š** å†æ¬¡éå†æ‰€æœ‰çš„ç»“æ„ä½“å®šä¹‰ã€‚è¿™ä¸€æ¬¡ï¼Œæˆ‘ä»¬çœŸæ­£åœ°å»æ£€æŸ¥æ¯ä¸ªç»“æ„ä½“å†…éƒ¨çš„å­—æ®µã€‚å› ä¸ºåœ¨ç¬¬ä¸€é˜¶æ®µæˆ‘ä»¬å·²ç»æ³¨å†Œäº†æ‰€æœ‰ç»“æ„ä½“çš„åå­—ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬åœ¨ `Node` ä¸­é‡åˆ° `List` æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ³¨å†Œè¡¨ä¸­æŸ¥åˆ° `List` æ˜¯ä¸€ä¸ªå·²çŸ¥çš„ï¼ˆè™½ç„¶å¯èƒ½å°šæœªå®Œå…¨æ£€æŸ¥çš„ï¼‰ç±»å‹ï¼Œä»è€Œå…è®¸è¿™ç§å¼•ç”¨ã€‚
///
/// åœ¨æˆ‘ä»¬çš„ MiniMoonBit ç¼–è¯‘å™¨ä¸­ï¼Œ`check_program` å‡½æ•°ï¼ˆä½äº `typecheck/program.mbt`ï¼‰å·²ç»ä¸ºä½ æ­å»ºå¥½äº†è¿™ä¸ªä¸¤é˜¶æ®µå¤„ç†çš„æ¡†æ¶ã€‚
/// ä½ ç°åœ¨éœ€è¦å®ç°çš„ `check_struct_def` æ­£æ˜¯è¿™ä¸ªæ¡†æ¶ä¸­çš„ç¬¬äºŒé˜¶æ®µçš„æ ¸å¿ƒéƒ¨åˆ†ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p typecheck -f typecheck_struct_def_test.mbt
/// ```
///
/// åŠ æ²¹ï¼ä½ æ­£åœ¨å¤„ç†ç¼–è¯‘å™¨è®¾è®¡ä¸­ä¸€ä¸ªéå¸¸æ ¸å¿ƒä¸”æœ‰è¶£çš„é—®é¢˜ï¼
/// ================================================================================

///|
test "Struct Definition Typecheck" {
  let code =
    #|struct Point { x: Int; mut y: Int; }
    #|struct Queue { data: Array[Int]; mut front: Int; mut back: Int; }
  let tokens = @lexer.tokenize(code)
  let ctx = Context::new()
  // Parse
  let (struct_def, tok_view) = @parser.parse_struct_def(tokens[:])
  // Typecheck for `struct Point { x: Int; mut y: Int }`
  let struct_def = ctx.check_struct_def(struct_def)
  assert_true(struct_def.name is "Point")
  assert_true(struct_def.fields.length() is 2)
  assert_true(
    struct_def.fields is [f1, f2] &&
    f1 is { name: "x", ty: { kind: Int, mutable: false } } &&
    f2 is { name: "y", ty: { kind: Int, mutable: true } },
  )
  // Typecheck for `struct Queue { data: Array[Int]; mut front: Int; mut back: Int }`
  let (struct_def, _) = @parser.parse_struct_def(tok_view)
  let struct_def = ctx.check_struct_def(struct_def)
  assert_true(struct_def.name is "Queue")
  assert_true(struct_def.fields.length() is 3)
  assert_true(
    struct_def.fields is [f1, f2, f3] &&
    f1 is { name: "data", ty: { kind: Array(Int), mutable: false } } &&
    f2 is { name: "front", ty: { kind: Int, mutable: true } } &&
    f3 is { name: "back", ty: { kind: Int, mutable: true } },
  )
}
