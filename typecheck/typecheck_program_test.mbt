/// ================================================================================
/// # å€’æ•°ç¬¬äºŒç« ï¼šæ£€æŸ¥æ•´ä¸ªç¨‹åº
///
/// ðŸŽ‰ **ç¥è´ºä½ ï¼ä½ å·²ç»åˆ°è¾¾äº†ç±»åž‹æ£€æŸ¥é˜¶æ®µçš„é‡è¦é‡Œç¨‹ç¢‘ï¼** ðŸŽ‰
///
/// æˆ‘ä»¬å·²ç»åˆ†åˆ«æž„å»ºäº†ç”¨äºŽæ£€æŸ¥è¡¨è¾¾å¼ã€è¯­å¥ã€å‡½æ•°å’Œç»“æž„ä½“çš„æ‰€æœ‰ç»„ä»¶ã€‚
/// çŽ°åœ¨ï¼Œæ˜¯æ—¶å€™å°†å®ƒä»¬å…¨éƒ¨æ•´åˆèµ·æ¥ï¼Œåœ¨ `typecheck/program.mbt` ä¸­å®žçŽ°æœ€ç»ˆçš„å…¥å£å‡½æ•° `check_program`ï¼Œ
/// å®ƒå°†è´Ÿè´£å¯¹æ•´ä¸ªç¨‹åºè¿›è¡Œå®Œæ•´çš„ç±»åž‹æ£€æŸ¥ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_program`
///
/// `check_program` å‡½æ•°æ˜¯æ•´ä¸ªç±»åž‹æ£€æŸ¥é˜¶æ®µçš„æ€»æŒ‡æŒ¥ã€‚å®ƒçš„æ ¸å¿ƒæ˜¯é‡‡ç”¨ä¸€ä¸ªç»å…¸çš„ä¸¤é˜¶æ®µï¼ˆTwo-Passï¼‰ç­–ç•¥æ¥è§£å†³å‰å‘å¼•ç”¨ï¼ˆForward Referenceï¼‰å’Œäº’ç›¸é€’å½’çš„é—®é¢˜ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯ï¼šä¸¤é˜¶æ®µæ£€æŸ¥ï¼ˆTwo-Pass Checkingï¼‰
///
/// **ç¬¬ä¸€é˜¶æ®µï¼šæ³¨å†Œï¼ˆRegistration Passï¼‰**
///
/// åœ¨çœŸæ­£æ£€æŸ¥ä»»ä½•å‡½æ•°ä½“æˆ–è¡¨è¾¾å¼ä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦â€œæ€»è§ˆâ€æ•´ä¸ªç¨‹åºï¼Œäº†è§£æ‰€æœ‰é¡¶å±‚å®šä¹‰çš„åå­—å’Œâ€œç­¾åâ€ã€‚
///
/// 1.  **æ³¨å†Œç»“æž„ä½“ï¼š**
///     *   å®žçŽ°ä¸€ä¸ª `collect_struct_names` è¾…åŠ©å‡½æ•°ã€‚
///     *   éåŽ†ç¨‹åºä¸­æ‰€æœ‰çš„ `struct` å®šä¹‰ï¼Œå°†å®ƒä»¬çš„åå­—ï¼ˆ`name`ï¼‰è®°å½•åˆ° `Context` çš„ `struct_defs` è¡¨ä¸­ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬åªå…³å¿ƒåå­—ï¼Œä¸å…³å¿ƒå…¶å†…éƒ¨å­—æ®µã€‚
///
/// 2.  **æ³¨å†Œå‡½æ•°å’Œå…¨å±€å˜é‡ï¼š**
///     *   å®žçŽ°ä¸€ä¸ª `collect_function_types` è¾…åŠ©å‡½æ•°ã€‚
///     *   éåŽ†æ‰€æœ‰é¡¶å±‚çš„ `fn` å®šä¹‰ã€‚å¯¹äºŽæ¯ä¸€ä¸ªå‡½æ•°ï¼Œè½¬æ¢å…¶å‚æ•°å’Œè¿”å›žå€¼çš„ç±»åž‹ï¼Œæž„é€ å‡º `Function` ç±»åž‹ï¼Œç„¶åŽå°†å…¶åå­—å’Œç±»åž‹ç­¾åå­˜å…¥ `Context` çš„ `func_types` å’Œå…¨å±€ `type_env` ä¸­ã€‚
///     *   åŒæ ·ï¼ŒéåŽ†æ‰€æœ‰é¡¶å±‚çš„ `let` ç»‘å®šï¼Œæ£€æŸ¥å…¶ç±»åž‹å¹¶å­˜å…¥å…¨å±€ `type_env`ã€‚
///
/// > å®Œæˆç¬¬ä¸€é˜¶æ®µåŽï¼Œ`Context` å°±æœ‰äº†ä¸€å¼ â€œå…¨å±€ç¬¦å·è¡¨â€ï¼ŒçŸ¥é“äº†ç¨‹åºä¸­æ‰€æœ‰é¡¶å±‚â€œæœ‰ä»€ä¹ˆâ€ï¼Œå³ä½¿æˆ‘ä»¬è¿˜æ²¡æ£€æŸ¥å®ƒä»¬â€œåšä»€ä¹ˆâ€ã€‚
///
/// **ç¬¬äºŒé˜¶æ®µï¼šæ£€æŸ¥ï¼ˆChecking Passï¼‰**
///
/// çŽ°åœ¨ï¼Œæ‰€æœ‰å®šä¹‰éƒ½å·²â€œå¤‡æ¡ˆâ€ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹çœŸæ­£çš„æ£€æŸ¥äº†ã€‚
///
/// 1.  åœ¨ `check_program` å‡½æ•°ä¸­ï¼ŒæŒ‰é¡ºåºè°ƒç”¨ä½ ä¹‹å‰å®žçŽ°çš„æ£€æŸ¥å‡½æ•°ï¼š
/// 2.  éåŽ†å¹¶è°ƒç”¨ `check_struct_def` æ£€æŸ¥æ¯ä¸ªç»“æž„ä½“çš„å­—æ®µç±»åž‹ã€‚
/// 3.  éåŽ†å¹¶è°ƒç”¨ `check_top_let` æ£€æŸ¥æ¯ä¸ªå…¨å±€ `let` ç»‘å®šçš„è¡¨è¾¾å¼ã€‚
/// 4.  éåŽ†å¹¶è°ƒç”¨ `check_top_function` æ£€æŸ¥æ¯ä¸ªé¡¶å±‚å‡½æ•°çš„å‡½æ•°ä½“ã€‚ç”±äºŽæ‰€æœ‰å‡½æ•°ç­¾åéƒ½å·²åœ¨ç¬¬ä¸€é˜¶æ®µæ³¨å†Œï¼Œå‡½æ•°é—´çš„äº’ç›¸è°ƒç”¨å’Œé€’å½’è°ƒç”¨æ­¤æ—¶éƒ½å¯ä»¥è¢«æ­£ç¡®åœ°æ£€æŸ¥ã€‚
///
/// ---
///
/// ### ðŸš€ è§è¯ä½ çš„æˆæžœï¼
///
/// å®Œæˆ `check_program` åŽï¼Œä½ å°±æ‹¥æœ‰äº†ä¸€ä¸ªåŠŸèƒ½å®Œå¤‡çš„ MiniMoonBit ç±»åž‹æ£€æŸ¥å™¨ï¼
///
/// **å†æ¬¡ç¥è´ºä½ å®Œæˆäº†è¿™ä¸€é‡è¦çš„é‡Œç¨‹ç¢‘ï¼æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¿›å…¥ç±»åž‹æ£€æŸ¥çš„æœ€ç»ˆé˜¶æ®µï¼**
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_program_test.mbt
/// ```
/// ================================================================================

///|
test "Program TypeCheck Test" {
  let code =
    #|let a = 3;
    #|let b = 4;
    #|fn fold(arr: Array[Int], f: (Int, Int) -> Int, init: Int) -> Int { 
    #|  let mut result = init;
    #|  let mut i = 0; 
    #|  while i < arr.length() {
    #|    result = f(result, arr[i]);
    #|  }
    #|  result
    #|}
    #|
    #|fn main {
    #|  fn max(a, b) { if a > b { a } else { b } }
    #|  fn min(a, b) { if a < b { a } else { b } }
    #|  let numbers = [a, 1, b, 1, 5, 9, 2, 6, 5];
    #|  let maximum = fold(numbers, max, -1000);
    #|  let minimum = fold(numbers, min, 1000);
    #|  let max_min_diff = maximum - minimum;
    #|  print_int(max_min_diff);
    #|}
  let ctx = Context::new()
  ctx.type_env.set("print_int", Type::{
    kind: Function([Int], Unit),
    mutable: false,
  })
  ctx.func_types.set("print_int", Function([Int], Unit))
  // Type check the program
  let tokens = @lexer.tokenize(code)
  let program = @parser.parse(tokens)
  let _ = ctx.check_program(program)
}
