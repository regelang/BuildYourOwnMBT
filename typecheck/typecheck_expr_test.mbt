/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è¡¨è¾¾å¼ï¼šç»„åˆçš„åŠ›é‡
///
/// æˆ‘ä»¬å·²ç»ä¸º `check_expr` å’Œ `check_apply_expr` æ­å»ºäº†åŸºç¡€çš„æ¡†æž¶ã€‚
/// çŽ°åœ¨ï¼Œæ˜¯æ—¶å€™ä¸º `check_apply_expr` æ·»åŠ å¤„ç†å¤æ‚ç»„åˆçš„èƒ½åŠ›äº†ï¼Œä¾‹å¦‚å‡½æ•°è°ƒç”¨ã€æ•°ç»„ç´¢å¼•å’Œå­—æ®µè®¿é—®ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®Œæˆ `check_apply_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯å›žåˆ° `typecheck/apply_expr.mbt` æ–‡ä»¶ï¼Œå®Œæˆ `Context::check_apply_expr` å‡½æ•°ä¸­å‰©ä½™çš„ `match` åˆ†æ”¯ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// `check_apply_expr` çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªå¾ªçŽ¯æˆ–é€’å½’ç»“æž„ï¼Œå®ƒé¦–å…ˆæ£€æŸ¥ä¸€ä¸ªåŸºç¡€è¡¨è¾¾å¼ï¼ˆ`AtomExpr`ï¼‰ï¼Œç„¶åŽä¸æ–­æ£€æŸ¥åŽé¢æ˜¯å¦è·Ÿéš `()`ã€`[]` æˆ– `.`ï¼Œå¹¶æŒç»­å°†è¡¨è¾¾å¼â€œåŒ…è£…â€æˆæ›´å¤æ‚çš„ `ApplyExpr`ã€‚
///
/// 1.  **`ArrayAccess(array_expr, index_expr)` (æ•°ç»„ç´¢å¼•)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `array_expr`ï¼Œå¹¶è°ƒç”¨ `check_expr` æ£€æŸ¥ `index_expr`ã€‚
///     *   **ç±»åž‹è§„åˆ™**ï¼š
///         *   `array_expr` çš„ç±»åž‹å¿…é¡»æ˜¯ `Array[T]`ã€‚
///         *   `index_expr` çš„ç±»åž‹å¿…é¡»æ˜¯ `Int`ã€‚
///     *   **è¿”å›žç±»åž‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹æ˜¯æ•°ç»„çš„å…ƒç´ ç±»åž‹ `T`ã€‚
///
/// 2.  **`FieldAccess(struct_expr, field_name)` (å­—æ®µè®¿é—®)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `struct_expr`ã€‚
///     *   **ç±»åž‹è§„åˆ™**ï¼š`struct_expr` çš„ç±»åž‹å¿…é¡»æ˜¯æŸä¸ª `Struct(struct_name)`ã€‚
///     *   ä½ éœ€è¦ä»Ž `Context` çš„ `struct_defs` ä¸­æŸ¥æ‰¾è¯¥ç»“æž„ä½“çš„å®šä¹‰ï¼Œå¹¶æ‰¾åˆ° `field_name` å¯¹åº”çš„å­—æ®µç±»åž‹ã€‚
///     *   **è¿”å›žç±»åž‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹å°±æ˜¯è¯¥å­—æ®µçš„ç±»åž‹ã€‚
///
/// 3.  **`Call(callee_expr, arg_exprs)` (å‡½æ•°è°ƒç”¨)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `callee_expr`ï¼ˆè¢«è°ƒç”¨çš„å‡½æ•°ï¼‰ã€‚
///     *   **ç±»åž‹è§„åˆ™**ï¼š`callee_expr` çš„ç±»åž‹å¿…é¡»æ˜¯ `Function` ç±»åž‹ï¼Œä¾‹å¦‚ `Function([ArgT1, ArgT2], RetT)`ã€‚
///     *   éåŽ† `arg_exprs`ï¼Œå¯¹æ¯ä¸ªå‚æ•°è¡¨è¾¾å¼é€’å½’è°ƒç”¨ `check_expr`ã€‚
///     *   **å…³é”®ä¸€æ­¥**ï¼šæ£€æŸ¥æ¯ä¸ªä¼ å…¥å‚æ•°çš„ç±»åž‹æ˜¯å¦ä¸Žå‡½æ•°ç­¾åä¸­å¯¹åº”å‚æ•°çš„ç±»åž‹ `ArgT` **å…¼å®¹**ã€‚è¿™é‡Œéœ€è¦å¤§é‡ä½¿ç”¨ `is_type_compatible`ï¼Œå®ƒä¼šé©±åŠ¨æˆ‘ä»¬ä¸Šä¸€å…³å®žçŽ°çš„ç±»åž‹å˜é‡åˆä¸€ï¼ˆUnificationï¼‰é€»è¾‘ã€‚
///     *   å‚æ•°çš„æ•°é‡ä¹Ÿå¿…é¡»åŒ¹é…ã€‚
///     *   **è¿”å›žç±»åž‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹æ˜¯å‡½æ•°ç­¾åçš„è¿”å›žç±»åž‹ `RetT`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// æœ¬æ¬¡æµ‹è¯•åŒ…å«äº†å¤šç§å¤æ‚çš„è¡¨è¾¾å¼ç»„åˆï¼Œå°†å…¨é¢è€ƒéªŒä½ çš„ `check_apply_expr` å®žçŽ°ã€‚
///
/// ```bash
/// moon test -p typecheck -f typecheck_expr_test.mbt
/// ```
/// ================================================================================

///|
test "Expr TypeCheck Test" {
  let code =
    #|arr[3] + arr[5] ; fact(5) + fib(10) ; print_string("Hello, World!");
    #|mat.data[3][4] ; sum(arr); 3.0 > max(x, y);
  let ctx = Context::new()
  ctx.struct_defs.set("Matrix", StructDef::{
    name: "Matrix",
    type_params: [],
    fields: [{ name: "data", ty: { kind: Array(Array(Int)), mutable: false } }],
  })
  ctx.type_env.set("arr", { kind: Array(Int), mutable: false })
  ctx.type_env.set("mat", { kind: Struct("Matrix"), mutable: false })
  // Note: Matrix struct has a field `data` of type Array(Array(Int))
  ctx.type_env.set("fact", { kind: Function([TypeVar(0)], Int), mutable: false })
  ctx.type_env.set("fib", { kind: Function([Int], Int), mutable: false })
  ctx.type_env.set("print_string", {
    kind: Function([String], Unit),
    mutable: false,
  })
  ctx.type_env.set("sum", { kind: Function([Array(Int)], Int), mutable: false })
  // Note: max is local function without type annotations
  ctx.type_env.set("max", {
    kind: Function([TypeVar(1), TypeVar(2)], TypeVar(3)),
    mutable: false,
  })
  ctx.type_env.set("x", { kind: Double, mutable: true })
  ctx.type_env.set("y", { kind: Double, mutable: true })
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(1))
  ctx.type_vars.set(2, TypeVar(1))
  ctx.type_vars.set(3, TypeVar(1))

  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of arr[3] + arr[5]
  let (a, tok_view) = @parser.parse_expr(tokens[:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of fact(5) + fib(10)
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of print_string("Hello, World!")
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Unit)
  // Type of mat.data[3][4]
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of sum(arr)
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of 3.0 > max(x, y)
  let (a, _) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Bool)
  assert_true(ctx.lookup_type("x") is Some({ kind: Double, .. }))
  assert_true(ctx.lookup_type("y") is Some({ kind: Double, .. }))
}
