/// ================================================================================
/// # ç¬¬ä¸‰æŒ‘æˆ˜ï¼šç±»åž‹æ£€æŸ¥å™¨ï¼ˆType Checkerï¼‰
///
/// æ­å–œä½ å®Œæˆäº†è¯­æ³•åˆ†æžï¼ä½ å·²ç»æ‹¥æœ‰äº†ç¼–è¯‘å™¨å†’é™©çš„ç¬¬äºŒæŠŠé’¥åŒ™â€”â€”æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰ã€‚
/// çŽ°åœ¨ï¼Œæˆ‘ä»¬å°†èµ‹äºˆè¿™äº›ç»“æž„ä»¥â€œæ„ä¹‰â€ï¼š**ç±»åž‹æ£€æŸ¥ï¼ˆType Checkingï¼‰**ã€‚
///
/// ---
///
/// ## ç±»åž‹æ£€æŸ¥ï¼ˆType Checkingï¼‰ï¼šèµ‹äºˆç»“æž„ä»¥æ„ä¹‰
///
/// ç±»åž‹æ£€æŸ¥å™¨æ˜¯ç¼–è¯‘å™¨çš„â€œå®ˆæŠ¤è€…â€ã€‚å®ƒçš„ä½¿å‘½æ˜¯ç¡®ä¿ä»£ç åœ¨è¯­ä¹‰ä¸Šæ˜¯æ­£ç¡®çš„ï¼Œ
/// å³å˜é‡å’Œè¡¨è¾¾å¼çš„ç±»åž‹ç¬¦åˆé¢„æœŸã€‚
///
/// **ä¾‹å¦‚ï¼Œå¯¹äºŽä»¥ä¸‹ä»£ç ç‰‡æ®µï¼š**
///
/// ```
/// let triangle_area = base * height / 2.0;
/// ```
///
/// ç±»åž‹æ£€æŸ¥å™¨éœ€è¦ç¡®ä¿ï¼š
///
/// - `base` å’Œ `height` æ˜¯Doubleç±»åž‹
/// - ä¹˜æ³•å’Œé™¤æ³•æ“ä½œç¬¦é€‚ç”¨äºŽDoubleç±»åž‹
/// - æ•´ä¸ªè¡¨è¾¾å¼çš„ç»“æžœä¹Ÿæ˜¯Doubleç±»åž‹
/// - å˜é‡ `triangle_area` è¢«æ­£ç¡®åœ°æŽ¨æ–­ä¸ºDoubleç±»åž‹
///
/// å¦‚æžœç±»åž‹æ£€æŸ¥å™¨å‘çŽ°ä»»ä½•ä¸åŒ¹é…çš„ç±»åž‹ï¼ˆä¾‹å¦‚ï¼Œå°†å­—ç¬¦ä¸²ä¸Žæ•´æ•°ç›¸ä¹˜ï¼‰ï¼Œ
/// å®ƒå°†æŠ›å‡ºé”™è¯¯ï¼Œé˜»æ­¢ç¼–è¯‘è¿‡ç¨‹ç»§ç»­è¿›è¡Œã€‚
///
/// åœ¨å·¥ä¸šçº§ç¼–è¯‘å™¨ä¸­ï¼Œè¿˜ä¼šç»™å‡ºè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼Œå¸®åŠ©å¼€å‘è€…å®šä½å’Œä¿®å¤ç±»åž‹é”™è¯¯ã€‚
///
/// ä¼˜ç§€çš„ç±»åž‹æ£€æŸ¥å™¨èƒ½å¤Ÿå¤§å¹…æå‡ä»£ç çš„å¯é æ€§å’Œå®‰å…¨æ€§ï¼Œä¸Žæ­¤åŒæ—¶ï¼Œä¹Ÿæ˜¯å­¦æœ¯ç ”ç©¶çš„çƒ­é—¨é¢†åŸŸã€‚
///
/// åœ¨æˆ‘ä»¬çš„MiniMoonBitç¼–è¯‘å™¨ä¸­ï¼Œæ‰€è®¾è®¡çš„ç±»åž‹ç³»ç»Ÿç›¸å¯¹ç®€å•ï¼Œä¸»è¦æ˜¯æ²¡æœ‰æ³›åž‹ï¼Œä½†ä¾ç„¶æœ‰ä¸€å®šçš„æŒ‘æˆ˜æ€§ã€‚
///
/// ä¾‹å¦‚ï¼ŒMiniMoonBitæ”¯æŒå¯¹letè¯­å¥ä¸è¿›è¡Œæ˜¾å¼ç±»åž‹å£°æ˜Žï¼š
///
/// ```
/// let a = 42; // aè¢«æŽ¨æ–­ä¸ºIntç±»åž‹
/// ```
///
/// å†æ¯”å¦‚ï¼ŒMiniMoonBitæ”¯æŒå®šä¹‰é—­åŒ…ï¼Œä¸”å¯ä»¥ä¸è¿›è¡Œæ˜¾å¼ç±»åž‹å£°æ˜Žï¼š
///
/// ```
/// fn max(x, y) { if x > y { x } else { y } }
/// ...
/// let _ = max(10, 20); // ç›´åˆ°è¿™ä¸€å¥ï¼Œmaxæ‰è¢«æŽ¨æ–­ä¸º (Int, Int) -> Int ç±»åž‹
/// ```
///
/// é‚£ä¹ˆï¼Œç±»åž‹æ£€æŸ¥å™¨ï¼Œåˆ°åº•è¦å¦‚ä½•å®žçŽ°å‘¢ï¼Ÿ
///
/// æˆ‘ä»¬è¿™ä¸€ç« ï¼Œå°±æ¥å¸¦ä½ ä¸€æ­¥ä¸€æ­¥åœ°å®žçŽ°ä¸€ä¸ªç®€å•çš„ç±»åž‹æ£€æŸ¥å™¨ï¼
/// 
/// ---
///
/// ## ðŸŽ¯ ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼šè½¬æ¢ç±»åž‹è¡¨ç¤º
///
/// æˆ‘ä»¬çš„ç±»åž‹æ£€æŸ¥å™¨ä¹Ÿéœ€è¦æœ‰è‡ªå·±çš„ç±»åž‹è¡¨ç¤ºã€‚
/// ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œå°±æ˜¯å®žçŽ°ä¸€ä¸ªè½¬æ¢å‡½æ•°ï¼Œå°† `Parser` è§£æžå‡ºçš„ç±»åž‹ï¼Œè½¬æ¢ä¸º `TypeChecker` å†…éƒ¨çš„ç±»åž‹è¡¨ç¤ºã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// 1.  **å¯¹æ¯”ç±»åž‹å®šä¹‰ï¼š**
///     *   è¯·æ‰“å¼€ `parser/typedef.mbt` å’Œ `typecheck/typedef.mbt`ã€‚
///     *   ä½ ä¼šå‘çŽ° `parser::TypeKind` å’Œ `typecheck::TypeKind` çš„å®šä¹‰éžå¸¸ç›¸ä¼¼ï¼Œä½†åŽè€…é¢å¤–å¢žåŠ äº† `Struct`ã€`Any` å’Œ `TypeVar` ç­‰æž„é€ å™¨ã€‚è¿™ä¸ºæˆ‘ä»¬åŽç»­å®žçŽ°æ›´å¼ºå¤§çš„ç±»åž‹åŠŸèƒ½ï¼ˆå¦‚ç»“æž„ä½“å’Œç±»åž‹æŽ¨æ–­ï¼‰é¢„ç•™äº†ç©ºé—´ã€‚
///
/// 2.  **ä¸Šä¸‹æ–‡ `Context` çš„ä½œç”¨ï¼š**
///     *   åœ¨ `typecheck/typedef.mbt` ä¸­ï¼Œæˆ‘ä»¬å¼•å…¥äº†ä¸€ä¸ªæ ¸å¿ƒæ•°æ®ç»“æž„ `Context`ã€‚
///     *   `Context` ç”¨äºŽåœ¨ç±»åž‹æ£€æŸ¥è¿‡ç¨‹ä¸­å­˜å‚¨å’Œç®¡ç†ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä¾‹å¦‚å·²çŸ¥çš„ç»“æž„ä½“å®šä¹‰ã€å‡½æ•°ç­¾åã€å˜é‡ç±»åž‹ç­‰ã€‚
///     *   åœ¨æœ¬æ¬¡ä»»åŠ¡ä¸­ï¼Œæˆ‘ä»¬æš‚æ—¶ä¸ä¼šç”¨åˆ° `Context` çš„å¤æ‚åŠŸèƒ½ï¼Œä½†è½¬æ¢å‡½æ•°ä¼šä½œä¸º `Context` çš„æ–¹æ³•æ¥å®žçŽ°ã€‚
///
/// ### ðŸš€ å…·ä½“æ“ä½œ
///
/// è¯·åœ¨ `typecheck/typedef.mbt` æ–‡ä»¶ä¸­ï¼Œå®Œæˆä»¥ä¸‹ä¸¤ä¸ªå‡½æ•°çš„å®žçŽ°ï¼š
///
/// *   `Context::check_parser_type`
/// *   `Context::check_parser_typekind`
///
/// ä½ çš„ç›®æ ‡æ˜¯é€’å½’åœ°å°† `parser` AST ä¸­çš„ `Type` å’Œ `TypeKind`ï¼Œè½¬æ¢ä¸º `typecheck` AST ä¸­å¯¹åº”çš„ `Type` å’Œ `TypeKind`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// åœ¨ä½ å®žçŽ°å®ŒæˆåŽï¼Œä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤æ¥å•ç‹¬è¿è¡Œå½“å‰æµ‹è¯•ï¼š
///
/// ```
/// moon test -p typecheck -f typecheck_normal_type_test.mbt
/// ```
///
/// å‡†å¤‡å¥½äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹ä¸ºä»£ç èµ‹äºˆâ€œæ„ä¹‰â€çš„ç¬¬ä¸€æ­¥ï¼
/// ================================================================================

///|
test "TypeCheck Normal Type Test" {
  let ctx = Context::new()
  let code =
    #|Unit Int Bool Double String
    #|(Int, Bool, String) Array[Int]
    #|Array[(Int, Double)]
    #|(Int, Bool) -> Double
  let tokens = @lexer.tokenize(code)
  let (t, tok_view) = @parser.parse_type(tokens)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Unit)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Int)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Bool)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Double)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is String)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Tuple([t1, t2, t3]) && t1 is Int && t2 is Bool && t3 is String,
  )
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Array(t1) && t1 is Int)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Array(t1) && t1 is Tuple([t2, t3]) && t2 is Int && t3 is Double,
  )
  let (t, _) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Function([t1, t2], t3) && t1 is Int && t2 is Bool && t3 is Double,
  )
}

///|
test "TypeCheck Defined Type Test" {
  let ctx = Context::new()
  ctx.struct_defs.set("Point", StructDef::{ name: "Point", type_params: [], fields: [] })
  ctx.struct_defs.set("Circle", StructDef::{ name: "Circle", type_params: [], fields: [] })
  ctx.struct_defs.set("Rectangle", StructDef::{ name: "Rectangle", type_params: [], fields: [] })
  // Note: No Triangle
  let code =
    #|Point Circle Rectangle Triangle
    #|Array[Point] (Point, Circle)
    #|(Rectangle, Point) -> Circle
    #|Array[Triangle]
  let tokens = @lexer.tokenize(code)
  let (t, tok_view) = @parser.parse_type(tokens)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Struct("Point"))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Struct("Circle"))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Struct("Rectangle"))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = try? ctx.check_parser_type(t)
  assert_true(t is Err(_)) // Triangle is not defined
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Array(t1) && t1 is Struct("Point"))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Tuple([t1, t2]) && t1 is Struct("Point") && t2 is Struct("Circle"),
  )
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Function([t1, t2], t3) &&
    t1 is Struct("Rectangle") &&
    t2 is Struct("Point") &&
    t3 is Struct("Circle"),
  )
  let (t, _) = @parser.parse_type(tok_view)
  let t = try? ctx.check_parser_type(t)
  assert_true(t is Err(_)) // Triangle is not defined
}
