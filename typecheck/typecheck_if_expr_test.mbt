/// ================================================================================
/// # ç±»å‹æ£€æŸ¥æ§åˆ¶æµï¼šif-else è¡¨è¾¾å¼
///
/// `if-else` æ˜¯æˆ‘ä»¬è¯­è¨€ä¸­ç¬¬ä¸€ä¸ªçœŸæ­£çš„æ§åˆ¶æµç»“æ„ã€‚åœ¨ MiniMoonBit ä¸­ï¼Œ`if-else` è‡ªèº«ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒå¯ä»¥äº§ç”Ÿä¸€ä¸ªå€¼ã€‚
/// ç±»å‹æ£€æŸ¥å™¨å¿…é¡»ä¿è¯å®ƒçš„é€»è¾‘æ˜¯å¥å…¨çš„ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `check_if_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/if_expr.mbt` æ–‡ä»¶ä¸­å®ç° `Context::check_if_expr` å‡½æ•°ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// æ£€æŸ¥ `if-else` è¡¨è¾¾å¼éœ€è¦éµå¾ªå‡ æ¡æ ¸å¿ƒè§„åˆ™ï¼š
///
/// 1.  **æ£€æŸ¥æ¡ä»¶ï¼š**
///     *   `if` åé¢çš„æ¡ä»¶è¡¨è¾¾å¼å¿…é¡»æ˜¯ä¸€ä¸ª `Bool` ç±»å‹ã€‚ä½ éœ€è¦é¦–å…ˆè°ƒç”¨ `check_expr` æ£€æŸ¥æ¡ä»¶ï¼Œå¹¶éªŒè¯å…¶ç±»å‹ã€‚
///
/// 2.  **æ£€æŸ¥ `then` åˆ†æ”¯ï¼š**
///     *   è°ƒç”¨ `check_block_expr` æ¥æ£€æŸ¥ `then` ä»£ç å—ï¼Œå¹¶è®°å½•ä¸‹å®ƒçš„ç±»å‹ `T_then`ã€‚
///
/// 3.  **æ£€æŸ¥ `else` åˆ†æ”¯ï¼š**
///     *   **å¦‚æœå­˜åœ¨ `else` åˆ†æ”¯**ï¼ˆæ— è®ºæ˜¯ `else if` è¿˜æ˜¯ `else`ï¼‰ï¼š
///         *   ä½ éœ€è¦é€’å½’åœ°æ£€æŸ¥ `else` åˆ†æ”¯ï¼ˆè°ƒç”¨ `check_if_expr` æˆ– `check_block_expr`ï¼‰ï¼Œå¹¶è·å¾—å…¶ç±»å‹ `T_else`ã€‚
///         *   **æ ¸å¿ƒè§„åˆ™ï¼š** `then` åˆ†æ”¯çš„ç±»å‹ `T_then` å¿…é¡»ä¸ `else` åˆ†æ”¯çš„ç±»å‹ `T_else` å…¼å®¹ã€‚ä½ éœ€è¦è°ƒç”¨ `self.is_type_compatible(T_then, T_else)`ã€‚
///         *   **è¡¨è¾¾å¼ç±»å‹ï¼š** æ•´ä¸ª `if-else` è¡¨è¾¾å¼çš„ç±»å‹å°±æ˜¯ `T_then`ï¼ˆåœ¨åˆä¸€åå¯èƒ½è¢«æ›´æ–°çš„ `T_then`ï¼‰ã€‚
///
///     *   **å¦‚æœä¸å­˜åœ¨ `else` åˆ†æ”¯**ï¼š
///         *   è¿™æ„å‘³ç€ `if` è¡¨è¾¾å¼åœ¨æ¡ä»¶ä¸º `false` æ—¶ä¸äº§ç”Ÿä»»ä½•å€¼ã€‚
///         *   **æ ¸å¿ƒè§„åˆ™ï¼š** åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ•´ä¸ª `if` è¡¨è¾¾å¼çš„ç±»å‹è¢«å®šä¸º `Unit`ã€‚
///         *   è¿™ä¹Ÿåè¿‡æ¥å¯¹ `then` åˆ†æ”¯æ–½åŠ äº†ä¸€ä¸ªçº¦æŸï¼šå®ƒçš„ç±»å‹ `T_then` å¿…é¡»ä¸ `Unit` å…¼å®¹ã€‚ä¸€ä¸ªè¿”å› `Int` çš„ `then` åˆ†æ”¯ä¸èƒ½åœ¨æ²¡æœ‰ `else` çš„æƒ…å†µä¸‹ç‹¬ç«‹å­˜åœ¨ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_if_expr_test.mbt
/// ```
/// ================================================================================

///|
test "If Expr TypeCheck Test" {
  let code =
    #|let arr = [];
    #|
    #|if a > b {
    #|  arr.push(1);
    #|} else {
    #|  arr.push(2);
    #|}
    #|
    #|if a < b {
    #|  arr.push(a);
    #|  a
    #|}else if a == b {
    #|  arr.push(1);
    #|  a - b
    #|} else {
    #|  arr.push(b);
    #|  b
    #|}
    #|
  let ctx = Context::new()
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(1))
  ctx.type_env.set("a", { kind: TypeVar(0), mutable: false })
  ctx.type_env.set("b", { kind: TypeVar(1), mutable: false })
  // Parse
  let tokens = @lexer.tokenize(code)
  let (let_stmt, tok_view) = @parser.parse_let_stmt(tokens[:])
  let _ = ctx.check_let_stmt(let_stmt)
  // TypeCheck first if expr
  let (if_expr1, tok_view) = @parser.parse_if_expr(tok_view)
  let checked_if1 = ctx.check_if_expr(if_expr1)
  assert_true(checked_if1.ty is Unit)
  assert_true(ctx.lookup_type("arr") is Some({ kind: Array(Int), .. }))
  // TypeCheck second if expr
  let (if_expr2, _) = @parser.parse_if_expr(tok_view)
  let checked_if2 = ctx.check_if_expr(if_expr2)
  assert_true(checked_if2.ty is Int)
  assert_true(ctx.lookup_type("a") is Some({ kind: Int, .. }))
  assert_true(ctx.lookup_type("b") is Some({ kind: Int, .. }))
}
