/// ================================================================================
/// # ç±»å‹æ£€æŸ¥åŸå­è¡¨è¾¾å¼ï¼šå®Œæ•´ç¯‡
///
/// æˆ‘ä»¬å·²ç»å®ç°äº† `check_atom_expr` çš„åŸºç¡€éƒ¨åˆ†ï¼Œèƒ½å¤Ÿå¤„ç†å­—é¢é‡å’Œæ ‡è¯†ç¬¦ã€‚
/// ç°åœ¨ï¼Œæ˜¯æ—¶å€™å®Œæˆ `check_atom_expr` çš„æ‰€æœ‰å‰©ä½™åˆ†æ”¯ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†æ‰€æœ‰ç±»å‹çš„åŸå­è¡¨è¾¾å¼äº†ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®Œæˆ `check_atom_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯å›åˆ° `typecheck/atom_expr.mbt` æ–‡ä»¶ï¼Œå®Œæˆ `Context::check_atom_expr` å‡½æ•°ä¸­å‰©ä½™çš„ `match` åˆ†æ”¯ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// ä½ éœ€è¦ä¸º `check_atom_expr` ä¸­çš„ä»¥ä¸‹ `AtomExprKind` åˆ†æ”¯ç¼–å†™ç±»å‹æ£€æŸ¥é€»è¾‘ï¼š
///
/// 1.  **`Paren(expr)` (æ‹¬å·è¡¨è¾¾å¼ `(expr)`)**
///     *   é€’å½’è°ƒç”¨ `self.check_expr(expr)` æ£€æŸ¥å†…éƒ¨è¡¨è¾¾å¼ã€‚
///     *   `Paren` è¡¨è¾¾å¼çš„ç±»å‹å°±æ˜¯å…¶å†…éƒ¨è¡¨è¾¾å¼çš„ç±»å‹ã€‚
///
/// 2.  **`Tuple(exprs)` (å…ƒç»„è¡¨è¾¾å¼ `(expr1, expr2, ...)`)**
///     *   éå† `exprs` æ•°ç»„ï¼Œå¯¹æ¯ä¸ªå­è¡¨è¾¾å¼é€’å½’è°ƒç”¨ `self.check_expr`ã€‚
///     *   å°†æ‰€æœ‰å­è¡¨è¾¾å¼çš„ç±»å‹æ”¶é›†èµ·æ¥ï¼Œæ„æˆä¸€ä¸ª `TypeKind::Tuple` ç±»å‹ã€‚
///     *   **æç¤ºï¼š** ä½ å¯ä»¥å®ç°ä¸€ä¸ªè¾…åŠ©å‡½æ•° `check_tuple_expr` æ¥å¤„ç†è¿™ä¸ªé€»è¾‘ã€‚
///
/// 3.  **`Array(exprs)` (æ•°ç»„å­—é¢é‡ `[expr1, expr2, ...]`)**
///     *   éå† `exprs` æ•°ç»„ï¼Œå¯¹æ¯ä¸ªå­è¡¨è¾¾å¼é€’å½’è°ƒç”¨ `self.check_expr`ã€‚
///     *   **ç±»å‹è§„åˆ™ï¼š** æ•°ç»„çš„æ‰€æœ‰å…ƒç´ å¿…é¡»å…·æœ‰å…¼å®¹çš„ç±»å‹ã€‚ä½ éœ€è¦ä½¿ç”¨ `self.is_type_compatible` æ¥ç¡®ä¿è¿™ä¸€ç‚¹ã€‚
///     *   **ç©ºæ•°ç»„ `[]` çš„ç‰¹æ®Šå¤„ç†ï¼š** å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œå®ƒçš„å…ƒç´ ç±»å‹æ˜¯æœªçŸ¥çš„ã€‚æ­¤æ—¶ï¼Œä½ åº”è¯¥åˆ›å»ºä¸€ä¸ª `TypeVar` ä½œä¸ºå…¶å…ƒç´ ç±»å‹çš„å ä½ç¬¦ï¼Œä¾‹å¦‚ `Array(TypeVar(N))`ã€‚
///     *   **æç¤ºï¼š** ä½ å¯ä»¥å®ç°ä¸€ä¸ªè¾…åŠ©å‡½æ•° `check_array_expr` æ¥å¤„ç†è¿™ä¸ªé€»è¾‘ã€‚
///
/// 4.  **`ArrayMake(size_expr, init_expr)` (`Array::make(size, init)`)**
///     *   è°ƒç”¨ `self.check_expr` æ£€æŸ¥ `size_expr`ï¼Œå…¶ç±»å‹å¿…é¡»æ˜¯ `Int`ã€‚
///     *   è°ƒç”¨ `self.check_expr` æ£€æŸ¥ `init_expr`ã€‚
///     *   æ•´ä¸ª `ArrayMake` è¡¨è¾¾å¼çš„ç±»å‹æ˜¯ `Array(init_expr.ty)`ã€‚
///     *   **æç¤ºï¼š** ä½ å¯ä»¥å®ç°ä¸€ä¸ªè¾…åŠ©å‡½æ•° `check_array_make_expr` æ¥å¤„ç†è¿™ä¸ªé€»è¾‘ã€‚
///
/// 5.  **`StructConstruct(sc_expr)` (`StructName::{ field: value, ... }`)**
///     *   è°ƒç”¨ `self.check_struct_construct_expr(sc_expr)` æ¥æ£€æŸ¥ç»“æ„ä½“æ„é€ è¡¨è¾¾å¼ã€‚
///     *   **æç¤ºï¼š** è¿™ä¸ªå‡½æ•°æˆ‘ä»¬å·²ç»åœ¨ä¹‹å‰çš„æŒ‘æˆ˜ä¸­å®ç°è¿‡äº†ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_atom_expr_test.mbt
/// ```
/// ================================================================================

///|
test "Atom Expression Type Check" {
  let code =
    #|[1, 2+3, 3+4+5, 6*7+8] (1+3, !y, "Hello") Array::make(5, 0) []
  let ctx = Context::new()
  ctx.type_env.set("x", { kind: Double, mutable: false })
  ctx.type_env.set("y", { kind: Bool, mutable: false })
  ctx.type_env.set("z", { kind: String, mutable: false })
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of [1, 2+3, 3+4+5, 6*7+8]
  let (a, tok_view) = @parser.parse_atom_expr(tokens[:])
  let a = ctx.check_atom_expr(a)
  assert_true(a.ty is Array(Int))
  // Type of (1+3, !y, "Hello")
  let (b, tok_view) = @parser.parse_atom_expr(tok_view)
  let b = ctx.check_atom_expr(b)
  assert_true(b.ty is Tuple([Int, Bool, String]))
  // Type of Array::make(5, 0)
  let (c, tok_view) = @parser.parse_atom_expr(tok_view)
  let c = ctx.check_atom_expr(c)
  assert_true(c.ty is Array(Int))
  // Type of []
  let (d, _) = @parser.parse_atom_expr(tok_view)
  let d = ctx.check_atom_expr(d)
  assert_true(d.ty is Array(TypeVar(_)))
}
