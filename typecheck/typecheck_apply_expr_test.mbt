/// ================================================================================
/// # ç±»å‹æ£€æŸ¥ Apply è¡¨è¾¾å¼ï¼šæœ€ç»ˆç« 
///
/// æˆ‘ä»¬å·²ç»ä¸º `check_apply_expr` å®ç°äº†åŸºç¡€çš„ `AtomExpr` åŒ…è£…ã€‚
/// ç°åœ¨ï¼Œæ˜¯æ—¶å€™å®Œæˆ `check_apply_expr` çš„æ‰€æœ‰å‰©ä½™åˆ†æ”¯ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†æ‰€æœ‰å¤æ‚çš„ `ApplyExpr` ç±»å‹äº†ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®Œæˆ `check_apply_expr` çš„æ‰€æœ‰åˆ†æ”¯
///
/// ä½ çš„ä»»åŠ¡æ˜¯å›åˆ° `typecheck/apply_expr.mbt` æ–‡ä»¶ï¼Œå®Œæˆ `Context::check_apply_expr` å‡½æ•°ä¸­å‰©ä½™çš„ `match` åˆ†æ”¯ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// `check_apply_expr` çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªå¾ªç¯æˆ–é€’å½’ç»“æ„ï¼Œå®ƒé¦–å…ˆæ£€æŸ¥ä¸€ä¸ªåŸºç¡€è¡¨è¾¾å¼ï¼ˆ`AtomExpr`ï¼‰ï¼Œç„¶åä¸æ–­æ£€æŸ¥åé¢æ˜¯å¦è·Ÿéš `()`ã€`[]` æˆ– `.`ï¼Œå¹¶æŒç»­å°†è¡¨è¾¾å¼â€œåŒ…è£…â€æˆæ›´å¤æ‚çš„ `ApplyExpr`ã€‚
///
/// ä½ éœ€è¦ä¸º `check_apply_expr` ä¸­çš„ä»¥ä¸‹ `ApplyExprKind` åˆ†æ”¯ç¼–å†™ç±»å‹æ£€æŸ¥é€»è¾‘ï¼š
///
/// 1.  **`ArrayAccess(array_expr, index_expr)` (æ•°ç»„ç´¢å¼• `array[index]`)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `array_expr`ï¼Œå¹¶è°ƒç”¨ `check_expr` æ£€æŸ¥ `index_expr`ã€‚
///     *   **ç±»å‹è§„åˆ™**ï¼š
///         *   `array_expr` çš„ç±»å‹å¿…é¡»æ˜¯ `Array[T]`ã€‚
///         *   `index_expr` çš„ç±»å‹å¿…é¡»æ˜¯ `Int`ã€‚
///     *   **è¿”å›ç±»å‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»å‹æ˜¯æ•°ç»„çš„å…ƒç´ ç±»å‹ `T`ã€‚
///
/// 2.  **`FieldAccess(object_expr, field_name)` (å­—æ®µè®¿é—® `object.field`)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `object_expr`ã€‚
///     *   **ç±»å‹è§„åˆ™**ï¼š
///         *   å¦‚æœ `object_expr` çš„ç±»å‹æ˜¯ `Struct(struct_name)`ï¼šä½ éœ€è¦ä» `Context` çš„ `struct_defs` ä¸­æŸ¥æ‰¾è¯¥ç»“æ„ä½“çš„å®šä¹‰ï¼Œå¹¶æ‰¾åˆ° `field_name` å¯¹åº”çš„å­—æ®µç±»å‹ã€‚
///         *   **ç‰¹æ®Šæƒ…å†µï¼šæ•°ç»„çš„å†…ç½®æ–¹æ³•**ã€‚åœ¨ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ `FieldAccess` è¯­æ³•æ¥è®¿é—®æ•°ç»„çš„å†…ç½®æ–¹æ³•ï¼Œä¾‹å¦‚ `arr.push(value)` å’Œ `arr.length()`ã€‚ä½ éœ€è¦è¯†åˆ« `object_expr` çš„ç±»å‹æ˜¯å¦ä¸º `Array[T]`ï¼Œç„¶åæ ¹æ® `field_name`ï¼ˆ`"push"` æˆ– `"length"`ï¼‰è¿”å›å¯¹åº”çš„å‡½æ•°ç±»å‹ã€‚
///     *   **è¿”å›ç±»å‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»å‹å°±æ˜¯è¯¥å­—æ®µæˆ–æ–¹æ³•çš„ç±»å‹ã€‚
///
/// 3.  **`Call(callee_expr, arg_exprs)` (å‡½æ•°è°ƒç”¨ `func(arg1, arg2, ...)`)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `callee_expr`ï¼ˆè¢«è°ƒç”¨çš„å‡½æ•°ï¼‰ã€‚
///     *   **ç±»å‹è§„åˆ™**ï¼š
///         *   `callee_expr` çš„ç±»å‹å¿…é¡»æ˜¯ `Function` ç±»å‹ï¼Œä¾‹å¦‚ `Function([ArgT1, ArgT2], RetT)`ã€‚
///         *   éå† `arg_exprs`ï¼Œå¯¹æ¯ä¸ªå‚æ•°è¡¨è¾¾å¼é€’å½’è°ƒç”¨ `check_expr`ã€‚
///         *   **å…³é”®ä¸€æ­¥**ï¼šæ£€æŸ¥æ¯ä¸ªä¼ å…¥å‚æ•°çš„ç±»å‹æ˜¯å¦ä¸å‡½æ•°ç­¾åä¸­å¯¹åº”å‚æ•°çš„ç±»å‹ `ArgT` **å…¼å®¹**ã€‚è¿™é‡Œéœ€è¦å¤§é‡ä½¿ç”¨ `is_type_compatible`ï¼Œå®ƒä¼šé©±åŠ¨æˆ‘ä»¬ä¹‹å‰å®ç°çš„ç±»å‹å˜é‡åˆä¸€ï¼ˆUnificationï¼‰é€»è¾‘ã€‚
///         *   å‚æ•°çš„æ•°é‡ä¹Ÿå¿…é¡»åŒ¹é…ã€‚
///     *   **è¿”å›ç±»å‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»å‹æ˜¯å‡½æ•°ç­¾åçš„è¿”å›ç±»å‹ `RetT`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_apply_expr_test.mbt
/// ```
/// ================================================================================

///|
test "Apply Expression Type Check" {
  let code =
    #|arr[3] ; fact(5) ; print("Hello, World!")
    #|mat[3][4] ; sum(arr); max(x, y);
    #|arr.push(10); mat.length();
  let ctx = Context::new()
  ctx.type_env.set("arr", { kind: Array(Int), mutable: false })
  ctx.type_env.set("mat", { kind: Array(Array(Int)), mutable: false })
  ctx.type_env.set("fact", { kind: Function([Int], Int), mutable: false })
  ctx.type_env.set("print", { kind: Function([String], Unit), mutable: false })
  ctx.type_env.set("sum", { kind: Function([Array(Int)], Int), mutable: false })
  // Note: max is local function without type annotations
  // like: fn max(a, b) { ... }
  ctx.type_env.set("max", {
    kind: Function([TypeVar(0), TypeVar(1)], TypeVar(2)),
    mutable: false,
  })
  ctx.type_env.set("x", { kind: Double, mutable: true })
  ctx.type_env.set("y", { kind: Double, mutable: true })
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(0))
  ctx.type_vars.set(2, TypeVar(0))
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of arr[3]
  let (a, tok_view) = @parser.parse_apply_expr(tokens[:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of fact(5)
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of print("Hello, World!")
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Unit)
  // Type of mat[3][4]
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of sum(arr)
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of max(x, y)
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Double)
  // Type of arr.push(10)
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Unit)
  // Type of mat.length()
  let (a, _) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
}
