/// ================================================================================
/// # ç±»å‹æ£€æŸ¥è¯­å¥ï¼šèµ‹å€¼è¯­å¥
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿé€šè¿‡ `let` å’Œ `let mut` å‘ç¯å¢ƒä¸­æ·»åŠ æ–°çš„å˜é‡äº†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬è¦æ£€æŸ¥å¯¹è¿™äº›å˜é‡çš„**èµ‹å€¼ï¼ˆAssignmentï¼‰**æ“ä½œã€‚
///
/// èµ‹å€¼è¯­å¥æ˜¯å‘½ä»¤å¼ç¼–ç¨‹çš„æ ¸å¿ƒï¼Œå®ƒä¼šæ”¹å˜ä¸€ä¸ªå·²å­˜åœ¨å˜é‡çš„å€¼ã€‚ç±»å‹æ£€æŸ¥å™¨çš„èŒè´£æ˜¯ç¡®ä¿è¿™ç§æ”¹å˜æ˜¯**ç±»å‹å®‰å…¨**ä¸”**åˆæ³•**çš„ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `check_assign_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/assign_stmt.mbt` æ–‡ä»¶ä¸­å®ç° `Context::check_assign_stmt` å‡½æ•°ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// 1.  **æ£€æŸ¥å·¦å€¼ï¼ˆL-Valueï¼‰ï¼š**
///     *   èµ‹å€¼è¯­å¥çš„å·¦ä¾§ä¸æ˜¯ä»»æ„è¡¨è¾¾å¼ï¼Œè€Œæ˜¯ä¸€ä¸ªâ€œå·¦å€¼â€â€”â€”å¯ä»¥è¢«èµ‹å€¼çš„ç›®æ ‡ï¼Œä¾‹å¦‚å˜é‡ `x`ã€æ•°ç»„å…ƒç´  `arr[0]` æˆ–ç»“æ„ä½“å­—æ®µ `obj.field`ã€‚
///     *   ä½ éœ€è¦é¦–å…ˆå®ç°ä¸€ä¸ª `check_left_value` è¾…åŠ©å‡½æ•°ï¼Œå®ƒè´Ÿè´£æ£€æŸ¥å·¦å€¼çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¯¹äº `x`ï¼Œå®ƒéœ€è¦åˆ°ç±»å‹ç¯å¢ƒä¸­æŸ¥æ‰¾ `x` çš„ç±»å‹ã€‚
///
/// 2.  **æ£€æŸ¥å¯å˜æ€§ï¼ˆMutabilityï¼‰ï¼š**
///     *   **è¿™æ˜¯èµ‹å€¼æ£€æŸ¥ä¸­æœ€å…³é”®çš„ä¸€æ­¥ï¼** ä½ ä¸èƒ½ç»™ä¸€ä¸ªä¸å¯å˜çš„å˜é‡èµ‹å€¼ã€‚
///     *   å½“ä½ ä»ç±»å‹ç¯å¢ƒä¸­æŸ¥æ‰¾åˆ°å·¦ä¾§å˜é‡çš„ç±»å‹åï¼Œå¿…é¡»æ£€æŸ¥å…¶ `mutable` æ ‡å¿—æ˜¯å¦ä¸º `true`ã€‚å¦‚æœä¸æ˜¯ï¼Œå°±åº”è¯¥æŠ›å‡ºç±»å‹é”™è¯¯ã€‚
///     *   æ€è€ƒä¸€ä¸‹ï¼šå¯¹äº `arr[0]` è¿™æ ·çš„å·¦å€¼ï¼Œå®ƒçš„å¯å˜æ€§åº”è¯¥å¦‚ä½•ç¡®å®šï¼Ÿï¼ˆæç¤ºï¼šå®ƒå–å†³äº `arr` æœ¬èº«æ˜¯å¦å¯å˜ï¼Œè¿˜æ˜¯æ•°ç»„å…ƒç´ æ€»æ˜¯å¯å˜çš„ï¼Ÿï¼‰åœ¨æˆ‘ä»¬çš„ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬åšä¸€ä¸ªç®€åŒ–ï¼Œè®¤ä¸ºåªè¦æ•°ç»„æœ¬èº«æ˜¯å¯è®¿é—®çš„ï¼Œå…¶å…ƒç´ å°±æ˜¯å¯å˜çš„ã€‚
///
/// 3.  **æ£€æŸ¥å³å€¼ï¼ˆR-Valueï¼‰ï¼š**
///     *   è°ƒç”¨ `self.check_expr` æ£€æŸ¥ `=` å³ä¾§è¡¨è¾¾å¼çš„ç±»å‹ã€‚
///
/// 4.  **æ£€æŸ¥ç±»å‹å…¼å®¹æ€§ï¼š**
///     *   ç¡®ä¿å³ä¾§è¡¨è¾¾å¼çš„ç±»å‹ä¸å·¦å€¼çš„ç±»å‹æ˜¯å…¼å®¹çš„ã€‚
///
/// 5.  **å¤„ç†å¤åˆèµ‹å€¼ï¼ˆCompound Assignmentï¼‰ï¼š**
///     *   å¯¹äº `+=`, `-=` ç­‰æ“ä½œï¼Œä½ è¿˜éœ€è¦é¢å¤–æ£€æŸ¥å·¦å³ä¸¤ä¾§çš„ç±»å‹æ˜¯å¦é€‚ç”¨äºè¯¥ç®—æœ¯è¿ç®—ï¼ˆä¾‹å¦‚ï¼Œå®ƒä»¬å¿…é¡»æ˜¯ `Int` æˆ– `Double`ï¼‰ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_assign_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "Assign Stmt Type Check" {
  let code =
    #|let mut x = 10;
    #|x = 5;
    #|let arr = [1, 2, 3];
    #|arr[0] = 10;
    #|x += true;  // Shoule fail
    #|let mut a = xxx;  // xxx's type is typevar
    #|a += 33;  // `a` and `xxx` should be inferred as Int
  let ctx = Context::new()
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of let mut x = 10; x = 5; 
  let (s, tok_view) = @parser.parse_let_mut_stmt(tokens[:])
  let _ = ctx.check_let_mut_stmt(s)
  let (a, tok_view) = @parser.parse_assign_stmt(tok_view)
  let a = ctx.check_assign_stmt(a)
  assert_true(a.left_value.ty.kind is Int)
  assert_true(a.expr.ty is Int)
  // Type of `let arr = [1, 2, 3]; arr[0] = 10;`
  let (s, tok_view) = @parser.parse_let_stmt(tok_view)
  let _ = ctx.check_let_stmt(s)
  let (a, tok_view) = @parser.parse_assign_stmt(tok_view)
  let a = ctx.check_assign_stmt(a)
  assert_true(a.left_value.ty.kind is Int)
  assert_true(a.left_value.ty.mutable is true)
  assert_true(a.expr.ty is Int)
  // Type of `x += true;` should fail
  let (a, tok_view) = @parser.parse_assign_stmt(tok_view)
  let t = try? ctx.check_assign_stmt(a)
  assert_true(t is Err(_))
  // Type of `let mut a = xxx; a += 33;`
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_env.set("xxx", { kind: TypeVar(0), mutable: false })
  let (s, tok_view) = @parser.parse_let_mut_stmt(tok_view)
  let _ = ctx.check_let_mut_stmt(s)
  let (a, _) = @parser.parse_assign_stmt(tok_view)
  let _ = ctx.check_assign_stmt(a)
  assert_true(ctx.lookup_type("a") is Some({ kind: Int, .. }))
  assert_true(ctx.lookup_type("xxx") is Some({ kind: Int, .. }))
}
