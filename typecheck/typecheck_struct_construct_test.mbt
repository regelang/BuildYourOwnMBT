/// ================================================================================
/// # ç±»å‹æ£€æŸ¥ï¼šç»“æ„ä½“æ„é€ 
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥å®šä¹‰ç»“æ„ä½“äº†ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦æ£€æŸ¥å®ƒçš„**æ„é€ ï¼ˆConstructionï¼‰**è¿‡ç¨‹ã€‚
/// ç±»å‹æ£€æŸ¥å™¨å¿…é¡»ç¡®ä¿æˆ‘ä»¬ç”¨äºæ„é€ ç»“æ„ä½“çš„å­—æ®µåå’Œå€¼çš„ç±»å‹éƒ½æ˜¯æ­£ç¡®çš„ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `check_struct_construct_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/struct_construct_expr.mbt` æ–‡ä»¶ä¸­å®ç° `Context::check_struct_construct_expr` å‡½æ•°ã€‚
///
/// è¿™ä¸ªå‡½æ•°åœ¨ `check_atom_expr` å†…éƒ¨è¢«è°ƒç”¨ï¼Œå½“é‡åˆ° `StructName::{...}` è¯­æ³•æ—¶è§¦å‘ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// æ£€æŸ¥ `MyStruct::{ field1: value1, ... }` çš„é€»è¾‘å¦‚ä¸‹ï¼š
///
/// 1.  **æŸ¥æ‰¾ç»“æ„ä½“å®šä¹‰ï¼š**
///     *   ä» `Context` çš„ `struct_defs` è¡¨ä¸­ï¼Œæ ¹æ®åå­— `MyStruct` æŸ¥æ‰¾åˆ°å®ƒçš„å®šä¹‰ã€‚å¦‚æœæ‰¾ä¸åˆ°ï¼Œè¯´æ˜è¯¥ç»“æ„ä½“æœªå®šä¹‰ï¼Œåº”æŠ›å‡ºé”™è¯¯ã€‚
///
/// 2.  **éå†å¹¶æ£€æŸ¥æ‰€æœ‰å­—æ®µï¼š**
///     *   éå†æ„é€ è¡¨è¾¾å¼ä¸­æä¾›çš„æ¯ä¸€ä¸ª `field: value` å¯¹ã€‚
///     *   å¯¹äºæ¯ä¸ªå­—æ®µï¼Œé¦–å…ˆæ£€æŸ¥ç»“æ„ä½“å®šä¹‰ä¸­æ˜¯å¦å­˜åœ¨åŒåå­—æ®µã€‚å¦‚æœä¸å­˜åœ¨ï¼ŒæŠ›å‡ºé”™è¯¯ã€‚
///     *   è°ƒç”¨ `check_expr` æ£€æŸ¥ `value` çš„ç±»å‹ã€‚
///     *   ä½¿ç”¨ `is_type_compatible` éªŒè¯ `value` çš„ç±»å‹æ˜¯å¦ä¸ç»“æ„ä½“å®šä¹‰ä¸­è¯¥å­—æ®µçš„ç±»å‹ç›¸åŒ¹é…ã€‚å¦‚æœä¸åŒ¹é…ï¼ŒæŠ›å‡ºé”™è¯¯ã€‚
///
/// 3.  **æ£€æŸ¥å­—æ®µå®Œæ•´æ€§ï¼š**
///     *   ä¸€ä¸ªå®Œæ•´çš„å®ç°è¿˜éœ€è¦æ£€æŸ¥ï¼Œæ„é€ è¡¨è¾¾å¼ä¸­æä¾›çš„å­—æ®µæ˜¯å¦åŒ…å«äº†ç»“æ„ä½“å®šä¹‰ä¸­æ‰€æœ‰æœªå£°æ˜ä¸ºå¯é€‰çš„å­—æ®µã€‚
///     *   ä¸ºäº†ç®€åŒ–ï¼Œåœ¨æˆ‘ä»¬çš„ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚æ„é€ æ—¶å¿…é¡»æä¾›æ‰€æœ‰å­—æ®µã€‚ä½ å¯ä»¥é€šè¿‡æ¯”è¾ƒæ„é€ è¡¨è¾¾å¼ä¸­çš„å­—æ®µæ•°é‡å’Œå®šä¹‰ä¸­çš„å­—æ®µæ•°é‡æ¥åšä¸€ä¸ªç®€å•çš„æ£€æŸ¥ã€‚
///
/// 4.  **ç¡®å®šè¡¨è¾¾å¼ç±»å‹ï¼š**
///     *   å¦‚æœæ‰€æœ‰æ£€æŸ¥éƒ½é€šè¿‡ï¼Œé‚£ä¹ˆæ•´ä¸ªæ„é€ è¡¨è¾¾å¼çš„ç±»å‹å°±æ˜¯è¯¥ç»“æ„ä½“æœ¬èº«çš„ç±»å‹ï¼Œå³ `TypeKind::Struct("MyStruct")`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_struct_construct_test.mbt
/// ```
/// ================================================================================

///|
test "Struct Construct TypeCheck Test" {
  let code =
    #|struct Point { x: Int; y: Int; }
    #|let p1 = Point::{ x: 1, y: 2 };
    #|let p2 = Point::{ x: 1, y: true };
  let tokens = @lexer.tokenize(code)
  let ctx = Context::new()

  // 1. Parse and check the struct definition to populate the context
  let (struct_def, tok_view1) = @parser.parse_struct_def(tokens)
  let _ = ctx.check_struct_def(struct_def) // Assumes check_struct_def works

  // 2. Parse and check the valid `let p1 = ...` statement
  let (let_stmt1, tok_view2) = @parser.parse_let_stmt(tok_view1)
  let _ = ctx.check_let_stmt(let_stmt1)
  let p1_type = ctx.lookup_type("p1")
  assert_true(p1_type is Some({ kind: Struct("Point"), .. }))

  // 3. Parse and check the invalid `let p2 = ...` statement
  let (let_stmt2, _) = @parser.parse_let_stmt(tok_view2)
  let result = try? ctx.check_let_stmt(let_stmt2)
  assert_true(result is Err(_))
}
