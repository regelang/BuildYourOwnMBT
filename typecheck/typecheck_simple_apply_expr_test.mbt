/// ================================================================================
/// # ç±»å‹æ£€æŸ¥è¡¨è¾¾å¼ï¼šApplyExpr
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿæ£€æŸ¥æœ€åŸºæœ¬çš„åŸå­è¡¨è¾¾å¼äº†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å‘ä¸Šèµ°ä¸€æ­¥ï¼Œå¼€å§‹å¤„ç† `ApplyExpr`ã€‚
///
/// åœ¨è¯­æ³•åˆ†æé˜¶æ®µï¼Œ`ApplyExpr` æ˜¯ä¸€ä¸ªå¤åˆæ¦‚å¿µï¼Œå®ƒä»¥ä¸€ä¸ª `AtomExpr` ä¸ºåŸºç¡€ï¼Œåé¢å¯ä»¥è·Ÿéšä¸€ç³»åˆ—çš„å‡½æ•°è°ƒç”¨ `()`ã€æ•°ç»„ç´¢å¼• `[]` æˆ–å­—æ®µè®¿é—® `.`ã€‚
///
/// åœ¨ç±»å‹æ£€æŸ¥é˜¶æ®µï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦ä¸€ä¸ª `check_apply_expr` å‡½æ•°æ¥å¤„ç†å®ƒã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `check_apply_expr` çš„åŸºç¡€æƒ…å†µ
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/apply_expr.mbt` æ–‡ä»¶ä¸­å®ç° `Context::check_apply_expr` å‡½æ•°ã€‚
///
/// ### ğŸ’¡ å®ç°æ€è·¯
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„æµ‹è¯•ç”¨ä¾‹éå¸¸ç®€å•ï¼Œåªæ¶‰åŠ `ApplyExpr` æœ€åŸºç¡€çš„å½¢å¼ï¼šå³å®ƒä»…ä»…æ˜¯ `AtomExpr` çš„ä¸€ä¸ªåŒ…è£…ã€‚
///
/// å› æ­¤ï¼Œä½ çš„ `check_apply_expr` å‡½æ•°ç°åœ¨åªéœ€è¦å¤„ç† `parser::ApplyExprKind::AtomExpr` è¿™ä¸€ç§æƒ…å†µã€‚
///
/// 1.  åœ¨ `check_apply_expr` ä¸­ï¼Œ`match` ä¼ å…¥çš„ `apply_expr.kind`ã€‚
/// 2.  å½“å®ƒæ˜¯ `AtomExpr(atom_expr)` æ—¶ï¼Œç›´æ¥è°ƒç”¨æˆ‘ä»¬ä¸Šä¸€å…³å®ç°çš„ `self.check_atom_expr(atom_expr)`ã€‚
/// 3.  `check_atom_expr` ä¼šè¿”å›ä¸€ä¸ªå¸¦ç±»å‹çš„åŸå­è¡¨è¾¾å¼ã€‚ä½ éœ€è¦ç”¨å®ƒæ¥æ„å»ºä¸€ä¸ªæ–°çš„ã€å¸¦ç±»å‹çš„ `typecheck::ApplyExpr`ï¼Œå¹¶å°†å…¶ç±»å‹ï¼ˆ`ty`ï¼‰è®¾ç½®ä¸ºåˆšåˆšè¿”å›çš„åŸå­è¡¨è¾¾å¼çš„ç±»å‹ã€‚
///
/// æˆ‘ä»¬å°†åœ¨åç»­æŒ‘æˆ˜ä¸­é€æ­¥ä¸º `check_apply_expr` æ·»åŠ å¤„ç†å‡½æ•°è°ƒç”¨ã€æ•°ç»„è®¿é—®ç­‰æ›´å¤æ‚çš„èƒ½åŠ›ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p typecheck -f typecheck_simple_apply_expr_test.mbt
/// ```
///
/// åŠ æ²¹ï¼æˆ‘ä»¬æ­£åœ¨ç¨³æ­¥æ„å»ºç±»å‹æ£€æŸ¥å™¨çš„å±‚æ¬¡ç»“æ„ã€‚
/// ================================================================================

///|
test "Simple Apply Expression Type Check" {
  let code =
    #|42 3.14 true "Hello" x y z
  let ctx = Context::new()
  ctx.type_env.set("x", { kind: TypeKind::Double, mutable: false })
  ctx.type_env.set("y", { kind: TypeKind::Bool, mutable: false })
  ctx.type_env.set("z", { kind: TypeKind::String, mutable: false })
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of 42
  let (a, tok_view) = @parser.parse_apply_expr(tokens[:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of 3.14
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Double)
  // Type of true
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Bool)
  // Type of "Hello"
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is String)
  // Type of x
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Double)
  // Type of y
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Bool)
  // Type of z
  let (a, _) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is String)
}
