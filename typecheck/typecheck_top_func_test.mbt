/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥ï¼šé¡¶å±‚å‡½æ•°
///
/// æˆ‘ä»¬å·²ç»æ”»å…‹äº†æœ€å¤æ‚çš„å±€éƒ¨å‡½æ•°ï¼ŒçŽ°åœ¨å›žåˆ°é¡¶å±‚å‡½æ•°çš„ç±»åž‹æ£€æŸ¥ï¼Œå®ƒè¦ç®€å•å¾—å¤šã€‚
///
/// é¡¶å±‚å‡½æ•°æ˜¯æž„æˆç¨‹åºçš„ä¸»ä½“ã€‚å¯¹å®ƒä»¬çš„æ£€æŸ¥æ˜¯ç±»åž‹æ£€æŸ¥æµç¨‹ä¸­éžå¸¸é‡è¦çš„ä¸€çŽ¯ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_top_function`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/top_function.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_top_function` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// æ£€æŸ¥é¡¶å±‚å‡½æ•°çš„ä¸»ä½“ä¸Žæ£€æŸ¥å±€éƒ¨å‡½æ•°éžå¸¸ç›¸ä¼¼ï¼Œä½†ç”±äºŽé¡¶å±‚å‡½æ•°ï¼ˆ`main`é™¤å¤–ï¼‰çš„æ‰€æœ‰ç±»åž‹éƒ½å¿…é¡»æ˜¾å¼æ³¨è§£ï¼Œæˆ‘ä»¬æ— éœ€è¿›è¡Œå¤æ‚çš„ç±»åž‹æŽ¨æ–­ã€‚
///
/// æ•´ä¸ªæµç¨‹å¦‚ä¸‹ï¼š
///
/// 1.  **æŸ¥æ‰¾å‡½æ•°ç­¾åï¼š**
///     *   åœ¨æ£€æŸ¥å‡½æ•°ä½“ä¹‹å‰ï¼Œæˆ‘ä»¬å‡è®¾å·²ç»é€šè¿‡ä¸€ä¸ªâ€œé¢„å¤„ç†â€é˜¶æ®µï¼Œå°†æ‰€æœ‰é¡¶å±‚å‡½æ•°çš„ç­¾åï¼ˆå‡½æ•°åã€å‚æ•°ç±»åž‹ã€è¿”å›žç±»åž‹ï¼‰éƒ½æ³¨å†Œåˆ°äº† `Context` çš„ `func_types` è¡¨ä¸­ã€‚
///     *   å› æ­¤ï¼Œå‡½æ•°çš„ç¬¬ä¸€æ­¥æ˜¯ä»Ž `func_types` ä¸­æŸ¥æ‰¾åˆ°å½“å‰è¦æ£€æŸ¥çš„å‡½æ•° `func` çš„ç­¾åã€‚
///
/// 2.  **åˆ›å»ºå‡½æ•°ä½œç”¨åŸŸï¼š**
///     *   è°ƒç”¨ `enter_scope()` ä¸ºå‡½æ•°ä½“åˆ›å»ºä¸€ä¸ªæ–°çš„ã€ç‹¬ç«‹çš„ä½œç”¨åŸŸã€‚
///
/// 3.  **è®¾ç½®ä¸Šä¸‹æ–‡å¹¶å¡«å……ä½œç”¨åŸŸï¼š**
///     *   å°† `Context` çš„ `current_func_ret_ty` è®¾ç½®ä¸ºä»Žå‡½æ•°ç­¾åä¸­æŸ¥åˆ°çš„è¿”å›žç±»åž‹ã€‚
///     *   éåŽ†å‡½æ•°çš„æ‰€æœ‰å‚æ•°ï¼Œå°†å®ƒä»¬çš„åå­—å’Œç±»åž‹æ·»åŠ åˆ°æ–°çš„ä½œç”¨åŸŸä¸­ã€‚
///
/// 4.  **æ£€æŸ¥å‡½æ•°ä½“ï¼š**
///     *   è°ƒç”¨ `check_block_expr` å¯¹æ•´ä¸ªå‡½æ•°ä½“è¿›è¡Œç±»åž‹æ£€æŸ¥ã€‚
///
/// 5.  **éªŒè¯è¿”å›žç±»åž‹ï¼š**
///     *   æ£€æŸ¥ `check_block_expr` è¿”å›žçš„å‡½æ•°ä½“ç±»åž‹ï¼Œæ˜¯å¦ä¸Žå‡½æ•°ç­¾åçš„è¿”å›žç±»åž‹å…¼å®¹ã€‚
///
/// 6.  **æ¸…ç†ï¼š**
///     *   è°ƒç”¨ `exit_scope()` é€€å‡ºå‡½æ•°ä½œç”¨åŸŸã€‚
///     *   å°† `current_func_ret_ty` é‡ç½®ä¸º `None`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_top_func_test.mbt
/// ```
/// ================================================================================

///|
test "Top Function TypeCheck Test" {
  let code =
    #|fn fib(n : Int) -> Int {
    #|  if n <= 1 {
    #|    return n;
    #|  } else {
    #|    return fib(n - 1) + fib(n - 2);
    #|  }
    #|}
  let ctx = Context::new()
  ctx.func_types.set("fib", Function([Int], Int))
  ctx.type_env.set("fib", { kind: Function([Int], Int), mutable: false })
  // parse
  let tokens = @lexer.tokenize(code)
  let (top_func, _) = @parser.parse_top_function(tokens[:])
  let _ = ctx.check_top_function(top_func)

}
