/// ================================================================================
/// # ç±»å‹æ¨æ–­çš„é­”æ³•ï¼šç±»å‹å˜é‡ä¸åˆä¸€ï¼ˆUnificationï¼‰
///
/// æ¬¢è¿æ¥åˆ°æˆ‘ä»¬ç¼–è¯‘å™¨ä¸­æœ€æ¿€åŠ¨äººå¿ƒçš„éƒ¨åˆ†ä¹‹ä¸€ï¼š**ç±»å‹æ¨æ–­ï¼ˆType Inferenceï¼‰**ã€‚
/// ç±»å‹æ¨æ–­å…è®¸ç¨‹åºå‘˜çœç•¥éƒ¨åˆ†æˆ–å…¨éƒ¨çš„ç±»å‹æ³¨è§£ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ¨å¯¼å‡ºè¿™äº›å˜é‡çš„ç±»å‹ã€‚
/// å®ƒçš„æ ¸å¿ƒé­”æ³•ï¼Œå°±æ˜¯**ç±»å‹å˜é‡ï¼ˆType Variablesï¼‰**å’Œ**åˆä¸€ï¼ˆUnificationï¼‰**ç®—æ³•ã€‚
///
/// ## ğŸ¤” ä¸ºä»€ä¹ˆéœ€è¦ç±»å‹å˜é‡ï¼Ÿ
///
/// æƒ³è±¡ä¸€ä¸‹è¿™ä¸ªåœºæ™¯ï¼š
///
/// ```moonbit
/// let a = [];
/// ```
///
/// åœ¨è¿™ä¸€è¡Œï¼Œ`a` çš„ç±»å‹æ˜¯ `Array[?]`ã€‚ä½†æˆ‘ä»¬å®Œå…¨ä¸çŸ¥é“ `?` åº”è¯¥æ˜¯ä»€ä¹ˆç±»å‹ã€‚
/// ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¼•å…¥ä¸€ä¸ªâ€œå ä½ç¬¦â€ç±»å‹ï¼Œç§°ä¹‹ä¸º**ç±»å‹å˜é‡**ã€‚
/// æˆ‘ä»¬å¯ä»¥è¯´ `a` çš„ç±»å‹æ˜¯ `Array[TypeVar(0)]`ï¼Œå…¶ä¸­ `0` æ˜¯è¿™ä¸ªç±»å‹å˜é‡çš„å”¯ä¸€IDã€‚
/// æˆ‘ä»¬å°†è¿™ä¸ªä¿¡æ¯è®°å½•åœ¨ `Context` çš„ä¸€å¼ è¡¨é‡Œï¼ˆä¾‹å¦‚ `type_vars: Map[Int, TypeKind]`ï¼‰ã€‚
///
/// ## âš™ï¸ ç±»å‹å˜é‡å¦‚ä½•å·¥ä½œï¼šåˆä¸€ï¼ˆUnificationï¼‰
///
/// ç±»å‹å˜é‡çš„çœŸæ­£å¨åŠ›åœ¨äºå®ƒä»¬å¦‚ä½•é€šè¿‡ä»£ç çš„ä¸Šä¸‹æ–‡æ¥è·å¾—å…·ä½“çš„ç±»å‹ã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºâ€œåˆä¸€â€ã€‚
///
/// **åœºæ™¯1ï¼šæ¨æ–­å‡ºå…·ä½“ç±»å‹**
///
/// å¦‚æœæˆ‘ä»¬æ¥ä¸‹æ¥çœ‹åˆ° `a.push(1)`ï¼Œç±»å‹æ£€æŸ¥å™¨ä¼šåˆ†æ `push` å‡½æ•°ã€‚å®ƒçŸ¥é“ `push` çš„å‚æ•°ç±»å‹åº”è¯¥ä¸æ•°ç»„çš„å…ƒç´ ç±»å‹ç›¸åŒã€‚
/// å› æ­¤ï¼Œ`Int` ç±»å‹å¿…é¡»ä¸ `TypeVar(0)` å…¼å®¹ã€‚
/// æ­¤æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥**åˆä¸€** `TypeVar(0)` å’Œ `Int`ï¼Œåœ¨æˆ‘ä»¬çš„è¡¨ä¸­è®°å½•ä¸‹ï¼š`TypeVar(0) = Int`ã€‚
/// `a` çš„ç±»å‹ä¹‹è°œå°±æ­¤è§£å¼€ï¼Œå®ƒæ˜¯ä¸€ä¸ª `Array[Int]`ã€‚
///
/// **åœºæ™¯2ï¼šå…³è”ä¸¤ä¸ªæœªçŸ¥ç±»å‹**
///
/// å‡è®¾æˆ‘ä»¬æœ‰ `let b = []`ï¼Œå®ƒçš„ç±»å‹æ˜¯ `Array[TypeVar(1)]`ã€‚
/// å¦‚æœä»£ç ä¸­å‡ºç°äº† `a == b`ï¼Œè¿™æ„å‘³ç€ `a` å’Œ `b` çš„ç±»å‹å¿…é¡»å…¼å®¹ã€‚
/// ä¹Ÿå°±æ˜¯è¯´ `Array[TypeVar(0)]` å¿…é¡»ä¸ `Array[TypeVar(1)]` å…¼å®¹ï¼Œè¿™è¿›ä¸€æ­¥è¦æ±‚ `TypeVar(0)` å¿…é¡»ä¸ `TypeVar(1)` å…¼å®¹ã€‚
///
/// æ­¤æ—¶ï¼Œæˆ‘ä»¬å°† `TypeVar(0)` å’Œ `TypeVar(1)` **åˆä¸€**ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¡¨ä¸­è®°å½• `TypeVar(1) = TypeVar(0)`ã€‚
/// è¿™å°±åƒå»ºç«‹äº†ä¸€ä¸ªâ€œç­‰ä»·å…³ç³»â€ã€‚ç°åœ¨ï¼Œä»»ä½•å…³äº `TypeVar(0)` çš„ä¿¡æ¯ï¼Œéƒ½å°†è‡ªåŠ¨ä¼ é€’ç»™ `TypeVar(1)`ã€‚
///
/// **åœºæ™¯3ï¼šä¿¡æ¯ä¼ é€’**
///
/// å»¶ç»­åœºæ™¯2ï¼Œå¦‚æœæˆ‘ä»¬ç¨åçœ‹åˆ°äº† `a.push(1)`ï¼Œæˆ‘ä»¬æ¨æ–­å‡º `TypeVar(0) = Int`ã€‚
/// å› ä¸ºæˆ‘ä»¬å·²ç»çŸ¥é“ `TypeVar(1) = TypeVar(0)`ï¼Œæ‰€ä»¥æˆ‘ä»¬ç«‹åˆ»ä¹ŸçŸ¥é“äº† `TypeVar(1) = Int`ã€‚
/// `b` çš„ç±»å‹ä¹Ÿéšä¹‹ç¡®å®šä¸º `Array[Int]`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `is_type_compatible` ä¸­çš„ `TypeVar` é€»è¾‘
///
/// ä½ çš„ä»»åŠ¡å°±æ˜¯å°†ä¸Šè¿°é€»è¾‘åœ¨ `typecheck/typedef.mbt` çš„ `is_type_compatible` å‡½æ•°ä¸­å®ç°ã€‚
/// ä½ éœ€è¦ä¸º `match (a, b)` æ·»åŠ å¤„ç† `TypeVar` çš„åˆ†æ”¯ï¼š
///
/// *   **`TypeVar` vs. å…·ä½“ç±»å‹ï¼ˆä¾‹å¦‚ `(TypeVar(id), Int)`ï¼‰ï¼š**
///     å°†ç±»å‹å˜é‡ `id` ä¸è¯¥å…·ä½“ç±»å‹è¿›è¡Œåˆä¸€ã€‚
/// *   **`TypeVar` vs. `TypeVar`ï¼ˆä¾‹å¦‚ `(TypeVar(id_a), TypeVar(id_b))`ï¼‰ï¼š**
///     å°†ä¸¤ä¸ªç±»å‹å˜é‡è¿›è¡Œåˆä¸€ã€‚
///
/// ä½ å¯èƒ½éœ€è¦ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œä¾‹å¦‚ `set_var_type_to_typekind`ï¼Œæ¥æ›´æ–°ä½ çš„ç±»å‹å˜é‡è¡¨ï¼Œå¹¶å¤„ç†å¥½â€œç­‰ä»·å…³ç³»â€çš„ä¼ é€’ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// æœ¬æ¬¡çš„æµ‹è¯•ç”¨ä¾‹ä¼šç›´æ¥è°ƒç”¨ `is_type_compatible` æ¥éªŒè¯ä½ çš„åˆä¸€ç®—æ³•æ˜¯å¦æ­£ç¡®ã€‚
///
/// ```bash
/// moon test -p typecheck -f typecheck_type_var_test.mbt
/// ```
///
/// åŠ æ²¹ï¼è¿™æ˜¯é€šå¾€ç°ä»£ç±»å‹ç³»ç»Ÿæœ€å…³é”®ã€ä¹Ÿæœ€æœ‰è¶£çš„ä¸€æ­¥ï¼
/// ================================================================================

///|
test "Type Var Test - 1" {
  let ctx = Context::new()
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(1))
  ctx.type_vars.set(2, TypeVar(2))
  ctx.type_vars.set(3, TypeVar(3))
  // TVar(0) = Double
  let t1 = ctx.is_type_compatible(TypeVar(0), Double)
  assert_true(t1 is true)
  assert_true(ctx.type_vars.get(0).unwrap() is Double)
  // TVar(1) = TVar(0)
  let t2 = ctx.is_type_compatible(TypeVar(1), TypeVar(0))
  assert_true(t2 is true)
  assert_true(ctx.type_vars.get(1).unwrap() is Double)
  // TVar(2) = TVar(3)
  let t3 = ctx.is_type_compatible(TypeVar(2), TypeVar(3))
  assert_true(t3 is true)
  // TVAr(3) = Int, therefore TVar(2) = Int
  let t4 = ctx.is_type_compatible(TypeVar(3), Int)
  assert_true(t4 is true)
  assert_true(ctx.type_vars.get(2).unwrap() is Int)
  assert_true(ctx.type_vars.get(3).unwrap() is Int)
  let t5 = ctx.is_type_compatible(TypeVar(2), Double)
  assert_true(t5 is false)
}

///|
///
/// 0 == 1 == 2 == 3
/// 2 == (Double, Int)
///
/// 0, 1, 2, 3 should all resolve to (Double, Int)
test "Type Var Test - 2" {
  let ctx = Context::new()
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(1))
  ctx.type_vars.set(2, TypeVar(2))
  ctx.type_vars.set(3, TypeVar(3))
  //
  let _ = ctx.is_type_compatible(TypeVar(0), TypeVar(1))
  let _ = ctx.is_type_compatible(TypeVar(1), TypeVar(2))
  let _ = ctx.is_type_compatible(TypeVar(2), TypeVar(3))
  let _ = ctx.is_type_compatible(TypeVar(3), TypeVar(0))
  let _ = ctx.is_type_compatible(TypeVar(2), Tuple([Double, Int]))
  let t0 = ctx.type_vars.get(0).unwrap()
  let t1 = ctx.type_vars.get(1).unwrap()
  let t2 = ctx.type_vars.get(2).unwrap()
  let t3 = ctx.type_vars.get(3).unwrap()
  assert_true(t0 is Tuple([Double, Int]))
  assert_true(t1 is Tuple([Double, Int]))
  assert_true(t2 is Tuple([Double, Int]))
  assert_true(t3 is Tuple([Double, Int]))
}
